// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

function Rule(name2, symbols, postprocess) {
    this.id = ++Rule.highestId;
    this.name = name2;
    this.symbols = symbols;
    this.postprocess = postprocess;
    return this;
}
Rule.highestId = 0;
Rule.prototype.toString = function(withCursorAt) {
    var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(' ') : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ') + " ● " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ');
    return this.name + " → " + symbolSequence;
};
function State(rule, dot, reference, wantedBy) {
    this.rule = rule;
    this.dot = dot;
    this.reference = reference;
    this.data = [];
    this.wantedBy = wantedBy;
    this.isComplete = this.dot === rule.symbols.length;
}
State.prototype.toString = function() {
    return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
};
State.prototype.nextState = function(child) {
    var state1 = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
    state1.left = this;
    state1.right = child;
    if (state1.isComplete) {
        state1.data = state1.build();
        state1.right = undefined;
    }
    return state1;
};
State.prototype.build = function() {
    var children = [];
    var node = this;
    do {
        children.push(node.right.data);
        node = node.left;
    }while (node.left)
    children.reverse();
    return children;
};
State.prototype.finish = function() {
    if (this.rule.postprocess) {
        this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
    }
};
function Column(grammar, index) {
    this.grammar = grammar;
    this.index = index;
    this.states = [];
    this.wants = {};
    this.scannable = [];
    this.completed = {};
}
Column.prototype.process = function(nextColumn) {
    var states = this.states;
    var wants = this.wants;
    var completed = this.completed;
    for(var w = 0; w < states.length; w++){
        var state2 = states[w];
        if (state2.isComplete) {
            state2.finish();
            if (state2.data !== Parser.fail) {
                var wantedBy = state2.wantedBy;
                for(var i2 = wantedBy.length; i2--;){
                    var left = wantedBy[i2];
                    this.complete(left, state2);
                }
                if (state2.reference === this.index) {
                    var exp = state2.rule.name;
                    (this.completed[exp] = this.completed[exp] || []).push(state2);
                }
            }
        } else {
            var exp = state2.rule.symbols[state2.dot];
            if (typeof exp !== 'string') {
                this.scannable.push(state2);
                continue;
            }
            if (wants[exp]) {
                wants[exp].push(state2);
                if (completed.hasOwnProperty(exp)) {
                    var nulls = completed[exp];
                    for(var i2 = 0; i2 < nulls.length; i2++){
                        var right = nulls[i2];
                        this.complete(state2, right);
                    }
                }
            } else {
                wants[exp] = [
                    state2
                ];
                this.predict(exp);
            }
        }
    }
};
Column.prototype.predict = function(exp) {
    var rules = this.grammar.byName[exp] || [];
    for(var i3 = 0; i3 < rules.length; i3++){
        var r = rules[i3];
        var wantedBy = this.wants[exp];
        var s = new State(r, 0, this.index, wantedBy);
        this.states.push(s);
    }
};
Column.prototype.complete = function(left, right) {
    var copy1 = left.nextState(right);
    this.states.push(copy1);
};
function Grammar(rules, start) {
    this.rules = rules;
    this.start = start || this.rules[0].name;
    var byName = this.byName = {};
    this.rules.forEach(function(rule) {
        if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
        }
        byName[rule.name].push(rule);
    });
}
Grammar.fromCompiled = function(rules, start) {
    var lexer5 = rules.Lexer;
    if (rules.ParserStart) {
        start = rules.ParserStart;
        rules = rules.ParserRules;
    }
    var rules = rules.map(function(r) {
        return new Rule(r.name, r.symbols, r.postprocess);
    });
    var g = new Grammar(rules, start);
    g.lexer = lexer5;
    return g;
};
function StreamLexer() {
    this.reset("");
}
StreamLexer.prototype.reset = function(data1, state3) {
    this.buffer = data1;
    this.index = 0;
    this.line = state3 ? state3.line : 1;
    this.lastLineBreak = state3 ? -state3.col : 0;
};
StreamLexer.prototype.next = function() {
    if (this.index < this.buffer.length) {
        var ch = this.buffer[this.index++];
        if (ch === '\n') {
            this.line += 1;
            this.lastLineBreak = this.index;
        }
        return {
            value: ch
        };
    }
};
StreamLexer.prototype.save = function() {
    return {
        line: this.line,
        col: this.index - this.lastLineBreak
    };
};
StreamLexer.prototype.formatError = function(token, message) {
    var buffer1 = this.buffer;
    if (typeof buffer1 === 'string') {
        var lines = buffer1.split("\n").slice(Math.max(0, this.line - 5), this.line);
        var nextLineBreak = buffer1.indexOf('\n', this.index);
        if (nextLineBreak === -1) nextLineBreak = buffer1.length;
        var col = this.index - this.lastLineBreak;
        var lastLineDigits = String(this.line).length;
        message += " at line " + this.line + " col " + col + ":\n\n";
        message += lines.map(function(line, i4) {
            return pad(this.line - lines.length + i4 + 1, lastLineDigits) + " " + line;
        }, this).join("\n");
        message += "\n" + pad("", lastLineDigits + col) + "^\n";
        return message;
    } else {
        return message + " at index " + (this.index - 1);
    }
    function pad(n, length) {
        var s = String(n);
        return Array(length - s.length + 1).join(" ") + s;
    }
};
function Parser(rules, start, options) {
    if (rules instanceof Grammar) {
        var grammar = rules;
        var options = start;
    } else {
        var grammar = Grammar.fromCompiled(rules, start);
    }
    this.grammar = grammar;
    this.options = {
        keepHistory: false,
        lexer: grammar.lexer || new StreamLexer
    };
    for(var key in options || {}){
        this.options[key] = options[key];
    }
    this.lexer = this.options.lexer;
    this.lexerState = undefined;
    var column = new Column(grammar, 0);
    this.table = [
        column
    ];
    column.wants[grammar.start] = [];
    column.predict(grammar.start);
    column.process();
    this.current = 0;
}
Parser.fail = {};
Parser.prototype.feed = function(chunk) {
    var lexer6 = this.lexer;
    lexer6.reset(chunk, this.lexerState);
    var token;
    while(true){
        try {
            token = lexer6.next();
            if (!token) {
                break;
            }
        } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
        }
        var column = this.table[this.current];
        if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
        }
        var n = this.current + 1;
        var nextColumn = new Column(this.grammar, n);
        this.table.push(nextColumn);
        var literal2 = token.text !== undefined ? token.text : token.value;
        var value = lexer6.constructor === StreamLexer ? token.value : token;
        var scannable = column.scannable;
        for(var w = scannable.length; w--;){
            var state4 = scannable[w];
            var expect = state4.rule.symbols[state4.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal2) {
                var next = state4.nextState({
                    data: value,
                    token: token,
                    isToken: true,
                    reference: n - 1
                });
                nextColumn.states.push(next);
            }
        }
        nextColumn.process();
        if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
        }
        if (this.options.keepHistory) {
            column.lexerState = lexer6.save();
        }
        this.current++;
    }
    if (column) {
        this.lexerState = lexer6.save();
    }
    this.results = this.finish();
    return this;
};
Parser.prototype.reportLexerError = function(lexerError) {
    var tokenDisplay, lexerMessage;
    var token = lexerError.token;
    if (token) {
        tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
        lexerMessage = this.lexer.formatError(token, "Syntax error");
    } else {
        tokenDisplay = "input (lexer error)";
        lexerMessage = lexerError.message;
    }
    return this.reportErrorCommon(lexerMessage, tokenDisplay);
};
Parser.prototype.reportError = function(token) {
    var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== undefined ? token.value : token);
    var lexerMessage = this.lexer.formatError(token, "Syntax error");
    return this.reportErrorCommon(lexerMessage, tokenDisplay);
};
Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
    var lines = [];
    lines.push(lexerMessage);
    var lastColumnIndex = this.table.length - 2;
    var lastColumn = this.table[lastColumnIndex];
    var expectantStates = lastColumn.states.filter(function(state5) {
        var nextSymbol = state5.rule.symbols[state5.dot];
        return nextSymbol && typeof nextSymbol !== "string";
    });
    if (expectantStates.length === 0) {
        lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\n');
        this.displayStateStack(lastColumn.states, lines);
    } else {
        lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\n');
        var stateStacks = expectantStates.map(function(state6) {
            return this.buildFirstStateStack(state6, []) || [
                state6
            ];
        }, this);
        stateStacks.forEach(function(stateStack) {
            var state7 = stateStack[0];
            var nextSymbol = state7.rule.symbols[state7.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push('A ' + symbolDisplay + ' based on:');
            this.displayStateStack(stateStack, lines);
        }, this);
    }
    lines.push("");
    return lines.join("\n");
};
Parser.prototype.displayStateStack = function(stateStack, lines) {
    var lastDisplay;
    var sameDisplayCount = 0;
    for(var j = 0; j < stateStack.length; j++){
        var state8 = stateStack[j];
        var display = state8.rule.toString(state8.dot);
        if (display === lastDisplay) {
            sameDisplayCount++;
        } else {
            if (sameDisplayCount > 0) {
                lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');
            }
            sameDisplayCount = 0;
            lines.push('    ' + display);
        }
        lastDisplay = display;
    }
};
Parser.prototype.getSymbolDisplay = function(symbol) {
    return getSymbolLongDisplay(symbol);
};
Parser.prototype.buildFirstStateStack = function(state9, visited) {
    if (visited.indexOf(state9) !== -1) {
        return null;
    }
    if (state9.wantedBy.length === 0) {
        return [
            state9
        ];
    }
    var prevState = state9.wantedBy[0];
    var childVisited = [
        state9
    ].concat(visited);
    var childResult = this.buildFirstStateStack(prevState, childVisited);
    if (childResult === null) {
        return null;
    }
    return [
        state9
    ].concat(childResult);
};
Parser.prototype.save = function() {
    var column = this.table[this.current];
    column.lexerState = this.lexerState;
    return column;
};
Parser.prototype.restore = function(column) {
    var index = column.index;
    this.current = index;
    this.table[index] = column;
    this.table.splice(index + 1);
    this.lexerState = column.lexerState;
    this.results = this.finish();
};
Parser.prototype.rewind = function(index) {
    if (!this.options.keepHistory) {
        throw new Error('set option `keepHistory` to enable rewinding');
    }
    this.restore(this.table[index]);
};
Parser.prototype.finish = function() {
    var considerations = [];
    var start = this.grammar.start;
    var column = this.table[this.table.length - 1];
    column.states.forEach(function(t) {
        if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser.fail) {
            considerations.push(t);
        }
    });
    return considerations.map(function(c) {
        return c.data;
    });
};
function getSymbolLongDisplay(symbol) {
    var type1 = typeof symbol;
    if (type1 === "string") {
        return symbol;
    } else if (type1 === "object") {
        if (symbol.literal) {
            return JSON.stringify(symbol.literal);
        } else if (symbol instanceof RegExp) {
            return 'character matching ' + symbol;
        } else if (symbol.type) {
            return symbol.type + ' token';
        } else if (symbol.test) {
            return 'token matching ' + String(symbol.test);
        } else {
            throw new Error('Unknown symbol type: ' + symbol);
        }
    }
}
function getSymbolShortDisplay(symbol) {
    var type2 = typeof symbol;
    if (type2 === "string") {
        return symbol;
    } else if (type2 === "object") {
        if (symbol.literal) {
            return JSON.stringify(symbol.literal);
        } else if (symbol instanceof RegExp) {
            return symbol.toString();
        } else if (symbol.type) {
            return '%' + symbol.type;
        } else if (symbol.test) {
            return '<' + String(symbol.test) + '>';
        } else {
            throw new Error('Unknown symbol type: ' + symbol);
        }
    }
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
var hasSticky = typeof new RegExp().sticky === 'boolean';
function isRegExp(o) {
    return o && toString.call(o) === '[object RegExp]';
}
function isObject(o) {
    return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o);
}
function reEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}
function reGroups(s) {
    var re = new RegExp('|' + s);
    return re.exec('').length - 1;
}
function reCapture(s) {
    return '(' + s + ')';
}
function reUnion(regexps) {
    if (!regexps.length) return '(?!)';
    var source = regexps.map(function(s) {
        return "(?:" + s + ")";
    }).join('|');
    return "(?:" + source + ")";
}
function regexpOrLiteral(obj) {
    if (typeof obj === 'string') {
        return '(?:' + reEscape(obj) + ')';
    } else if (isRegExp(obj)) {
        if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed');
        if (obj.global) throw new Error('RegExp /g flag is implied');
        if (obj.sticky) throw new Error('RegExp /y flag is implied');
        if (obj.multiline) throw new Error('RegExp /m flag is implied');
        return obj.source;
    } else {
        throw new Error('Not a pattern: ' + obj);
    }
}
function objectToRules(object) {
    var keys = Object.getOwnPropertyNames(object);
    var result = [];
    for(var i5 = 0; i5 < keys.length; i5++){
        var key = keys[i5];
        var thing = object[key];
        var rules = [].concat(thing);
        if (key === 'include') {
            for(var j = 0; j < rules.length; j++){
                result.push({
                    include: rules[j]
                });
            }
            continue;
        }
        var match = [];
        rules.forEach(function(rule) {
            if (isObject(rule)) {
                if (match.length) result.push(ruleOptions(key, match));
                result.push(ruleOptions(key, rule));
                match = [];
            } else {
                match.push(rule);
            }
        });
        if (match.length) result.push(ruleOptions(key, match));
    }
    return result;
}
function arrayToRules(array) {
    var result = [];
    for(var i6 = 0; i6 < array.length; i6++){
        var obj = array[i6];
        if (obj.include) {
            var include = [].concat(obj.include);
            for(var j = 0; j < include.length; j++){
                result.push({
                    include: include[j]
                });
            }
            continue;
        }
        if (!obj.type) {
            throw new Error('Rule has no type: ' + JSON.stringify(obj));
        }
        result.push(ruleOptions(obj.type, obj));
    }
    return result;
}
function ruleOptions(type3, obj) {
    if (!isObject(obj)) {
        obj = {
            match: obj
        };
    }
    if (obj.include) {
        throw new Error('Matching rules cannot also include states');
    }
    var options = {
        defaultType: type3,
        lineBreaks: !!obj.error || !!obj.fallback,
        pop: false,
        next: null,
        push: null,
        error: false,
        fallback: false,
        value: null,
        type: null,
        shouldThrow: false
    };
    for(var key in obj){
        if (hasOwnProperty.call(obj, key)) {
            options[key] = obj[key];
        }
    }
    if (typeof options.type === 'string' && type3 !== options.type) {
        throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type3 + "')");
    }
    var match = options.match;
    options.match = Array.isArray(match) ? match : match ? [
        match
    ] : [];
    options.match.sort(function(a, b1) {
        return isRegExp(a) && isRegExp(b1) ? 0 : isRegExp(b1) ? -1 : isRegExp(a) ? +1 : b1.length - a.length;
    });
    return options;
}
function toRules(spec) {
    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
}
var defaultErrorRule = ruleOptions('error', {
    lineBreaks: true,
    shouldThrow: true
});
function compileRules(rules, hasStates) {
    var errorRule = null;
    var fast = Object.create(null);
    var fastAllowed = true;
    var unicodeFlag = null;
    var groups = [];
    var parts = [];
    for(var i7 = 0; i7 < rules.length; i7++){
        if (rules[i7].fallback) {
            fastAllowed = false;
        }
    }
    for(var i7 = 0; i7 < rules.length; i7++){
        var options = rules[i7];
        if (options.include) {
            throw new Error('Inheritance is not allowed in stateless lexers');
        }
        if (options.error || options.fallback) {
            if (errorRule) {
                if (!options.fallback === !errorRule.fallback) {
                    throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
                } else {
                    throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
                }
            }
            errorRule = options;
        }
        var match = options.match.slice();
        if (fastAllowed) {
            while(match.length && typeof match[0] === 'string' && match[0].length === 1){
                var word = match.shift();
                fast[word.charCodeAt(0)] = options;
            }
        }
        if (options.pop || options.push || options.next) {
            if (!hasStates) {
                throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
            }
            if (options.fallback) {
                throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
            }
        }
        if (match.length === 0) {
            continue;
        }
        fastAllowed = false;
        groups.push(options);
        for(var j = 0; j < match.length; j++){
            var obj = match[j];
            if (!isRegExp(obj)) {
                continue;
            }
            if (unicodeFlag === null) {
                unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
                throw new Error('If one rule is /u then all must be');
            }
        }
        var pat = reUnion(match.map(regexpOrLiteral));
        var regexp = new RegExp(pat);
        if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
        }
        var groupCount = reGroups(pat);
        if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: … ) instead");
        }
        if (!options.lineBreaks && regexp.test('\n')) {
            throw new Error('Rule should declare lineBreaks: ' + regexp);
        }
        parts.push(reCapture(pat));
    }
    var fallbackRule = errorRule && errorRule.fallback;
    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm';
    var suffix = hasSticky || fallbackRule ? '' : '|';
    if (unicodeFlag === true) flags += "u";
    var combined = new RegExp(reUnion(parts) + suffix, flags);
    return {
        regexp: combined,
        groups: groups,
        fast: fast,
        error: errorRule || defaultErrorRule
    };
}
function compile(rules) {
    var result = compileRules(toRules(rules));
    return new Lexer({
        start: result
    }, 'start');
}
function keywords(map) {
    var reverseMap = Object.create(null);
    var byLength = Object.create(null);
    var types1 = Object.getOwnPropertyNames(map);
    for(var i8 = 0; i8 < types1.length; i8++){
        var tokenType = types1[i8];
        var item = map[tokenType];
        var keywordList = Array.isArray(item) ? item : [
            item
        ];
        keywordList.forEach(function(keyword) {
            (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword);
            if (typeof keyword !== 'string') {
                throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            reverseMap[keyword] = tokenType;
        });
    }
    function str(x) {
        return JSON.stringify(x);
    }
    var source = '';
    source += 'switch (value.length) {\n';
    for(var length in byLength){
        var keywords1 = byLength[length];
        source += 'case ' + length + ':\n';
        source += 'switch (value) {\n';
        keywords1.forEach(function(keyword) {
            var tokenType = reverseMap[keyword];
            source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\n';
        });
        source += '}\n';
    }
    source += '}\n';
    return Function('value', source);
}
var Lexer = function(states, state10) {
    this.startState = state10;
    this.states = states;
    this.buffer = '';
    this.stack = [];
    this.reset();
};
Lexer.prototype.reset = function(data2, info) {
    this.buffer = data2 || '';
    this.index = 0;
    this.line = info ? info.line : 1;
    this.col = info ? info.col : 1;
    this.queuedToken = info ? info.queuedToken : null;
    this.queuedThrow = info ? info.queuedThrow : null;
    this.setState(info ? info.state : this.startState);
    this.stack = info && info.stack ? info.stack.slice() : [];
    return this;
};
Lexer.prototype.save = function() {
    return {
        line: this.line,
        col: this.col,
        state: this.state,
        stack: this.stack.slice(),
        queuedToken: this.queuedToken,
        queuedThrow: this.queuedThrow
    };
};
Lexer.prototype.setState = function(state11) {
    if (!state11 || this.state === state11) return;
    this.state = state11;
    var info = this.states[state11];
    this.groups = info.groups;
    this.error = info.error;
    this.re = info.regexp;
    this.fast = info.fast;
};
Lexer.prototype.popState = function() {
    this.setState(this.stack.pop());
};
Lexer.prototype.pushState = function(state12) {
    this.stack.push(this.state);
    this.setState(state12);
};
var eat = hasSticky ? function(re, buffer2) {
    return re.exec(buffer2);
} : function(re, buffer3) {
    var match = re.exec(buffer3);
    if (match[0].length === 0) {
        return null;
    }
    return match;
};
Lexer.prototype._getGroup = function(match) {
    var groupCount = this.groups.length;
    for(var i9 = 0; i9 < groupCount; i9++){
        if (match[i9 + 1] !== undefined) {
            return this.groups[i9];
        }
    }
    throw new Error('Cannot find token type for matched text');
};
function tokenToString() {
    return this.value;
}
Lexer.prototype.next = function() {
    var index = this.index;
    if (this.queuedGroup) {
        var token = this._token(this.queuedGroup, this.queuedText, index);
        this.queuedGroup = null;
        this.queuedText = "";
        return token;
    }
    var buffer4 = this.buffer;
    if (index === buffer4.length) {
        return;
    }
    var group = this.fast[buffer4.charCodeAt(index)];
    if (group) {
        return this._token(group, buffer4.charAt(index), index);
    }
    var re = this.re;
    re.lastIndex = index;
    var match = eat(re, buffer4);
    var error1 = this.error;
    if (match == null) {
        return this._token(error1, buffer4.slice(index, buffer4.length), index);
    }
    var group = this._getGroup(match);
    var text = match[0];
    if (error1.fallback && match.index !== index) {
        this.queuedGroup = group;
        this.queuedText = text;
        return this._token(error1, buffer4.slice(index, match.index), index);
    }
    return this._token(group, text, index);
};
Lexer.prototype._token = function(group, text, offset) {
    var lineBreaks = 0;
    if (group.lineBreaks) {
        var matchNL = /\n/g;
        var nl = 1;
        if (text === '\n') {
            lineBreaks = 1;
        } else {
            while(matchNL.exec(text)){
                lineBreaks++;
                nl = matchNL.lastIndex;
            }
        }
    }
    var token = {
        type: typeof group.type === 'function' && group.type(text) || group.defaultType,
        value: typeof group.value === 'function' ? group.value(text) : text,
        text: text,
        toString: tokenToString,
        offset: offset,
        lineBreaks: lineBreaks,
        line: this.line,
        col: this.col
    };
    var size1 = text.length;
    this.index += size1;
    this.line += lineBreaks;
    if (lineBreaks !== 0) {
        this.col = size1 - nl + 1;
    } else {
        this.col += size1;
    }
    if (group.shouldThrow) {
        throw new Error(this.formatError(token, "invalid syntax"));
    }
    if (group.pop) this.popState();
    else if (group.push) this.pushState(group.push);
    else if (group.next) this.setState(group.next);
    return token;
};
if (typeof Symbol !== 'undefined' && Symbol.iterator) {
    var LexerIterator = function(lexer7) {
        this.lexer = lexer7;
    };
    LexerIterator.prototype.next = function() {
        var token = this.lexer.next();
        return {
            value: token,
            done: !token
        };
    };
    LexerIterator.prototype[Symbol.iterator] = function() {
        return this;
    };
    Lexer.prototype[Symbol.iterator] = function() {
        return new LexerIterator(this);
    };
}
Lexer.prototype.formatError = function(token, message) {
    if (token == null) {
        var text = this.buffer.slice(this.index);
        var token = {
            text: text,
            offset: this.index,
            lineBreaks: text.indexOf('\n') === -1 ? 0 : 1,
            line: this.line,
            col: this.col
        };
    }
    var start = Math.max(0, token.offset - token.col + 1);
    var eol = token.lineBreaks ? token.text.indexOf('\n') : token.text.length;
    var firstLine = this.buffer.substring(start, token.offset + eol);
    message += " at line " + token.line + " col " + token.col + ":\n\n";
    message += "  " + firstLine + "\n";
    message += "  " + Array(token.col).join(" ") + "^";
    return message;
};
Lexer.prototype.clone = function() {
    return new Lexer(this.states, this.state);
};
Lexer.prototype.has = function(tokenType) {
    return true;
};
Object.freeze({
    error: true
});
Object.freeze({
    fallback: true
});
const sqlKeywords = [
    "ALL",
    "ANALYSE",
    "ANALYZE",
    "AND",
    "ANY",
    "ARRAY",
    "AS",
    "ASC",
    "ASYMMETRIC",
    "AUTHORIZATION",
    "BINARY",
    "BOTH",
    "CASE",
    "CAST",
    "CHECK",
    "COLLATE",
    "COLLATION",
    "CONCURRENTLY",
    "CONSTRAINT",
    "CREATE",
    "CROSS",
    "CURRENT_CATALOG",
    "CURRENT_DATE",
    "CURRENT_ROLE",
    "CURRENT_SCHEMA",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "DEFAULT",
    "DEFERRABLE",
    "DESC",
    "DISTINCT",
    "DO",
    "ELSE",
    "END",
    "EXCEPT",
    "FALSE",
    "FETCH",
    "FOR",
    "FOREIGN",
    "FREEZE",
    "FROM",
    "FULL",
    "GRANT",
    "GROUP",
    "HAVING",
    "ILIKE",
    "IN",
    "INITIALLY",
    "INNER",
    "INTERSECT",
    "INTO",
    "IS",
    "ISNULL",
    "JOIN",
    "LATERAL",
    "LEADING",
    "LEFT",
    "LIKE",
    "LIMIT",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "NATURAL",
    "NOT",
    "NOTNULL",
    "NULL",
    "OFFSET",
    "ON",
    "ONLY",
    "OR",
    "ORDER",
    "OUTER",
    "OVERLAPS",
    "PLACING",
    "PRIMARY",
    "REFERENCES",
    "RETURNING",
    "RIGHT",
    "SELECT",
    "SESSION_USER",
    "SIMILAR",
    "SOME",
    "SYMMETRIC",
    "TABLE",
    "TABLESAMPLE",
    "THEN",
    "TO",
    "TRAILING",
    "TRUE",
    "UNION",
    "UNIQUE",
    "USER",
    "USING",
    "VARIADIC",
    "VERBOSE",
    "WHEN",
    "WHERE",
    "WINDOW",
    "WITH",
    "PRECISION"
];
const keywordsMap = {};
for (const k of sqlKeywords){
    keywordsMap['kw_' + k.toLowerCase()] = k;
}
const caseInsensitiveKeywords = (map)=>{
    const transform = keywords(map);
    return (text)=>transform(text.toUpperCase());
};
const lexer = compile({
    word: {
        match: /[eE](?!')[A-Za-z0-9_]*|[a-df-zA-DF-Z_][A-Za-z0-9_]*/,
        type: caseInsensitiveKeywords(keywordsMap),
        value: (x)=>x.toLowerCase()
    },
    wordQuoted: {
        match: /"(?:[^"\*]|"")+"/,
        type: ()=>'word'
    },
    string: {
        match: /'(?:[^']|\'\')*'/,
        value: (x)=>{
            return x.substr(1, x.length - 2).replace(/''/g, '\'');
        }
    },
    eString: {
        match: /\b(?:e|E)'(?:[^'\\]|[\r\n\s]|(?:\\\s)|(?:\\\n)|(?:\\.)|(?:\'\'))+'/,
        value: (x1)=>{
            return x1.substr(2, x1.length - 3).replace(/''/g, '\'').replace(/\\([\s\n])/g, (_, x)=>x).replace(/\\./g, (m)=>JSON.parse('"' + m + '"'));
        }
    },
    qparam: {
        match: /\$\d+/
    },
    commentLine: /\-\-.*?$[\s\r\n]*/,
    commentFullOpen: /(?<!\/)\/\*/,
    commentFullClose: /\*\/[\s\r\n]*/,
    star: '*',
    comma: ',',
    space: {
        match: /[\s\t\n\v\f\r]+/,
        lineBreaks: true
    },
    int: /\-?\d+(?![\.\d])/,
    float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
    lparen: '(',
    rparen: ')',
    lbracket: '[',
    rbracket: ']',
    semicolon: ';',
    dot: /\.(?!\d)/,
    op_cast: '::',
    op_plus: '+',
    op_eq: '=',
    op_neq: {
        match: /(?:!=)|(?:\<\>)/,
        value: ()=>'!='
    },
    op_minus: /(?<!\-)\-(?!\-)(?!\>)/,
    op_div: /(?<!\/)\/(?!\/)/,
    op_like: /(?<!\!)~~(?!\*)/,
    op_ilike: /(?<!\!)~~\*/,
    op_not_like: /\!~~(?!\*)/,
    op_not_ilike: /\!~~\*/,
    op_mod: '%',
    op_exp: '^',
    op_member: /\-\>(?!\>)/,
    op_membertext: '->>',
    op_additive: {
        match: [
            '||',
            '-',
            '#-',
            '&&'
        ]
    },
    op_compare: {
        match: [
            '>',
            '>=',
            '<',
            '<=',
            '@>',
            '<@',
            '?',
            '?|',
            '?&',
            '#>>',
            '>>',
            '<<',
            '~'
        ]
    },
    ops_others: {
        match: [
            '|',
            '&',
            '^',
            '#'
        ]
    },
    codeblock: {
        match: /\$\$(?:.|[\s\t\n\v\f\r])*?\$\$/s,
        lineBreaks: true,
        value: (x)=>x.substr(2, x.length - 4)
    }
});
lexer.next = ((next)=>()=>{
        let tok;
        let commentFull = null;
        while(tok = next.call(lexer)){
            if (tok.type === 'commentFullOpen') {
                if (commentFull === null) {
                    commentFull = {
                        nested: 0,
                        offset: tok.offset,
                        text: tok.text
                    };
                    continue;
                }
                commentFull.nested++;
            }
            if (commentFull != null) {
                commentFull.text += tok.text;
                if (tok.type === 'commentFullClose') {
                    if (commentFull.nested === 0) {
                        comments?.push(makeComment(commentFull));
                        commentFull = null;
                        continue;
                    }
                    commentFull.nested--;
                }
                continue;
            }
            if (tok.type === 'space') {
                continue;
            }
            if (tok.type === 'commentLine') {
                comments?.push(makeComment(tok));
                continue;
            }
            break;
        }
        if (trackingLoc && tok) {
            const start = tok.offset;
            const loc = {
                start,
                end: start + tok.text.length
            };
            tok._location = loc;
        }
        return tok;
    })(lexer.next);
const lexerAny = lexer;
let comments = null;
const makeComment = ({ offset , text  })=>({
        _location: {
            start: offset,
            end: offset + text.length
        },
        comment: text
    });
let trackingLoc = false;
function track(xs, ret1) {
    if (!trackingLoc || !ret1 || typeof ret1 !== 'object') {
        return ret1;
    }
    const start = seek(xs, true);
    const end = seek(xs, false);
    if (!start || !end) {
        return ret1;
    }
    if (start === end) {
        ret1._location = start;
    } else {
        const loc = {
            start: start.start,
            end: end.end
        };
        ret1._location = loc;
    }
    return ret1;
}
const literal = Symbol('_literal');
function box(xs, value) {
    if (!trackingLoc) {
        return value;
    }
    return track(xs, {
        [literal]: value
    });
}
function unbox(value) {
    if (!trackingLoc) {
        return value;
    }
    if (typeof value === 'object') {
        return value?.[literal] ?? value;
    }
    return value;
}
function seek(xs, start) {
    if (!xs) {
        return null;
    }
    if (Array.isArray(xs)) {
        const diff1 = start ? 1 : -1;
        for(let i10 = start ? 0 : xs.length - 1; i10 >= 0 && i10 < xs.length; i10 += diff1){
            const v = seek(xs[i10], start);
            if (v) {
                return v;
            }
        }
        return null;
    }
    if (typeof xs !== 'object') {
        return null;
    }
    return xs._location;
}
function id(d) {
    return d[0];
}
function asName(val) {
    const name3 = toStr(val);
    return track(val, {
        name: name3
    });
}
function asLit(val) {
    const value1 = toStr(val);
    return track(val, {
        value: value1
    });
}
function unwrap(e) {
    if (Array.isArray(e) && e.length === 1) {
        e = unwrap(e[0]);
    }
    if (Array.isArray(e) && !e.length) {
        return null;
    }
    return unbox(e);
}
const get = (i11)=>(x)=>track(x, x[i11]);
const last = (x)=>Array.isArray(x) ? track(x[x.length - 1], x[x.length - 1]) : x;
function flatten(e) {
    if (Array.isArray(e)) {
        const ret2 = [];
        for (const i12 of e){
            ret2.push(...flatten(i12));
        }
        return ret2;
    }
    if (!e) {
        return [];
    }
    return [
        e
    ];
}
function asStr(value2) {
    value2 = unbox(value2);
    return value2?.value ?? value2;
}
function flattenStr(e) {
    const fl = flatten(unbox(e));
    return fl.filter((x)=>!!x).map((x)=>asStr(x)).filter((x)=>typeof x === 'string').map((x)=>x.trim()).filter((x)=>!!x);
}
function toStr(e, join11) {
    return flattenStr(e).join(join11 || '');
}
function fromEntries(vals) {
    const ret3 = {};
    for (const [k4, v] of vals){
        ret3[k4] = v;
    }
    return ret3;
}
const kwSensitivity = {
    sensitivity: 'accent'
};
const eqInsensitive = (a, b2)=>a.localeCompare(b2, undefined, kwSensitivity) === 0;
const notReservedKw = (kw1)=>(x, _, rej)=>{
        const val = asStr(x[0]);
        if (eqInsensitive(val, kw1)) {
            return box(x, kw1);
        }
        return rej;
    };
const kw = notReservedKw;
const anyKw = (...kw2)=>{
    const kwSet1 = new Set(kw2);
    return (x, _, rej)=>{
        const val = typeof x[0] === 'string' ? x[0] : x[0].value;
        return kwSet1.has(val) ? val : rej;
    };
};
function setSeqOpts(ret4, opts) {
    const defs = new Set();
    const unboxed = opts.map(unbox);
    for (const [k5, v] of unboxed){
        if (defs.has(k5)) {
            throw new Error('conflicting or redundant options');
        }
        defs.add(k5);
        ret4[k5] = unbox(v);
    }
}
({
    Lexer: lexerAny,
    ParserRules: [
        {
            "name": "lparen",
            "symbols": [
                lexerAny.has("lparen") ? {
                    type: "lparen"
                } : lparen
            ]
        },
        {
            "name": "rparen",
            "symbols": [
                lexerAny.has("rparen") ? {
                    type: "rparen"
                } : rparen
            ]
        },
        {
            "name": "number$subexpression$1",
            "symbols": [
                "float"
            ]
        },
        {
            "name": "number$subexpression$1",
            "symbols": [
                "int"
            ]
        },
        {
            "name": "number",
            "symbols": [
                "number$subexpression$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "dot",
            "symbols": [
                lexerAny.has("dot") ? {
                    type: "dot"
                } : dot
            ],
            "postprocess": id
        },
        {
            "name": "float",
            "symbols": [
                lexerAny.has("float") ? {
                    type: "float"
                } : __float
            ],
            "postprocess": (x)=>box(x, parseFloat(unwrap(x)))
        },
        {
            "name": "int",
            "symbols": [
                lexerAny.has("int") ? {
                    type: "int"
                } : __int
            ],
            "postprocess": (x)=>box(x, parseInt(unwrap(x), 10))
        },
        {
            "name": "comma",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma
            ],
            "postprocess": id
        },
        {
            "name": "star",
            "symbols": [
                lexerAny.has("star") ? {
                    type: "star"
                } : star
            ],
            "postprocess": (x)=>box(x, x[0].value)
        },
        {
            "name": "string$subexpression$1",
            "symbols": [
                lexerAny.has("string") ? {
                    type: "string"
                } : string
            ]
        },
        {
            "name": "string$subexpression$1",
            "symbols": [
                lexerAny.has("eString") ? {
                    type: "eString"
                } : eString
            ]
        },
        {
            "name": "string",
            "symbols": [
                "string$subexpression$1"
            ],
            "postprocess": (x)=>box(x, unwrap(x[0]).value)
        },
        {
            "name": "ident",
            "symbols": [
                "word"
            ],
            "postprocess": get(0)
        },
        {
            "name": "word",
            "symbols": [
                lexerAny.has("kw_primary") ? {
                    type: "kw_primary"
                } : kw_primary
            ],
            "postprocess": (x)=>box(x, 'primary')
        },
        {
            "name": "word",
            "symbols": [
                lexerAny.has("kw_unique") ? {
                    type: "kw_unique"
                } : kw_unique
            ],
            "postprocess": (x)=>box(x, 'unique')
        },
        {
            "name": "word",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": (x)=>{
                const val = x[0].value;
                return box(x, val[0] === '"' ? val.substr(1, val.length - 2) : val);
            }
        },
        {
            "name": "collist_paren",
            "symbols": [
                "lparen",
                "collist",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "collist$ebnf$1",
            "symbols": []
        },
        {
            "name": "collist$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "ident"
            ],
            "postprocess": last
        },
        {
            "name": "collist$ebnf$1",
            "symbols": [
                "collist$ebnf$1",
                "collist$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "collist",
            "symbols": [
                "ident",
                "collist$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "kw_between",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('between')
        },
        {
            "name": "kw_conflict",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('conflict')
        },
        {
            "name": "kw_nothing",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('nothing')
        },
        {
            "name": "kw_begin",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('begin')
        },
        {
            "name": "kw_if",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('if')
        },
        {
            "name": "kw_exists",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('exists')
        },
        {
            "name": "kw_key",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('key')
        },
        {
            "name": "kw_index",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('index')
        },
        {
            "name": "kw_extension",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('extension')
        },
        {
            "name": "kw_schema",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('schema')
        },
        {
            "name": "kw_nulls",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('nulls')
        },
        {
            "name": "kw_first",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('first')
        },
        {
            "name": "kw_last",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('last')
        },
        {
            "name": "kw_start",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('start')
        },
        {
            "name": "kw_restart",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('restart')
        },
        {
            "name": "kw_filter",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('filter')
        },
        {
            "name": "kw_commit",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('commit')
        },
        {
            "name": "kw_tablespace",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('tablespace')
        },
        {
            "name": "kw_transaction",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('transaction')
        },
        {
            "name": "kw_work",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('work')
        },
        {
            "name": "kw_read",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('read')
        },
        {
            "name": "kw_write",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('write')
        },
        {
            "name": "kw_isolation",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('isolation')
        },
        {
            "name": "kw_level",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('level')
        },
        {
            "name": "kw_serializable",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('serializable')
        },
        {
            "name": "kw_rollback",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('rollback')
        },
        {
            "name": "kw_insert",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('insert')
        },
        {
            "name": "kw_value",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('value')
        },
        {
            "name": "kw_values",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('values')
        },
        {
            "name": "kw_update",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('update')
        },
        {
            "name": "kw_column",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('column')
        },
        {
            "name": "kw_set",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('set')
        },
        {
            "name": "kw_version",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('version')
        },
        {
            "name": "kw_alter",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('alter')
        },
        {
            "name": "kw_rename",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('rename')
        },
        {
            "name": "kw_sequence",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('sequence')
        },
        {
            "name": "kw_temp",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('temp')
        },
        {
            "name": "kw_temporary",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('temporary')
        },
        {
            "name": "kw_add",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('add')
        },
        {
            "name": "kw_owner",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('owner')
        },
        {
            "name": "kw_owned",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('owned')
        },
        {
            "name": "kw_including",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('including')
        },
        {
            "name": "kw_excluding",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('excluding')
        },
        {
            "name": "kw_none",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('none')
        },
        {
            "name": "kw_drop",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('drop')
        },
        {
            "name": "kw_operator",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('operator')
        },
        {
            "name": "kw_minvalue",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('minvalue')
        },
        {
            "name": "kw_maxvalue",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('maxvalue')
        },
        {
            "name": "kw_data",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('data')
        },
        {
            "name": "kw_type",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('type')
        },
        {
            "name": "kw_delete",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('delete')
        },
        {
            "name": "kw_cache",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('cache')
        },
        {
            "name": "kw_cascade",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('cascade')
        },
        {
            "name": "kw_no",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('no')
        },
        {
            "name": "kw_timestamp",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('timestamp')
        },
        {
            "name": "kw_cycle",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('cycle')
        },
        {
            "name": "kw_function",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('function')
        },
        {
            "name": "kw_returns",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('returns')
        },
        {
            "name": "kw_language",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('language')
        },
        {
            "name": "kw_out",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('out')
        },
        {
            "name": "kw_inout",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('inout')
        },
        {
            "name": "kw_variadic",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('variadic')
        },
        {
            "name": "kw_action",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('action')
        },
        {
            "name": "kw_restrict",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('restrict')
        },
        {
            "name": "kw_truncate",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('truncate')
        },
        {
            "name": "kw_increment",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('increment')
        },
        {
            "name": "kw_by",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('by')
        },
        {
            "name": "kw_row",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('row')
        },
        {
            "name": "kw_rows",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('rows')
        },
        {
            "name": "kw_next",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('next')
        },
        {
            "name": "kw_match",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('match')
        },
        {
            "name": "kw_replace",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('replace')
        },
        {
            "name": "kw_recursive",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('recursive')
        },
        {
            "name": "kw_view",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('view')
        },
        {
            "name": "kw_cascaded",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('cascaded')
        },
        {
            "name": "kw_unlogged",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('unlogged')
        },
        {
            "name": "kw_global",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('global')
        },
        {
            "name": "kw_option",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('option')
        },
        {
            "name": "kw_materialized",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('materialized')
        },
        {
            "name": "kw_partial",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('partial')
        },
        {
            "name": "kw_partition",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('partition')
        },
        {
            "name": "kw_simple",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('simple')
        },
        {
            "name": "kw_generated",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('generated')
        },
        {
            "name": "kw_always",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('always')
        },
        {
            "name": "kw_identity",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('identity')
        },
        {
            "name": "kw_name",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('name')
        },
        {
            "name": "kw_enum",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('enum')
        },
        {
            "name": "kw_show",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('show')
        },
        {
            "name": "kw_overriding",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('overriding')
        },
        {
            "name": "kw_over",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('over')
        },
        {
            "name": "kw_system",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('system')
        },
        {
            "name": "kw_comment",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('comment')
        },
        {
            "name": "kw_time",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('time')
        },
        {
            "name": "kw_at",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('at')
        },
        {
            "name": "kw_zone",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('zone')
        },
        {
            "name": "kw_interval",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('interval')
        },
        {
            "name": "kw_hour",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('hour')
        },
        {
            "name": "kw_minute",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('minute')
        },
        {
            "name": "kw_local",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('local')
        },
        {
            "name": "kw_prepare",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('prepare')
        },
        {
            "name": "kw_deallocate",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('deallocate')
        },
        {
            "name": "kw_raise",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('raise')
        },
        {
            "name": "kw_continue",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('continue')
        },
        {
            "name": "kw_share",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('share')
        },
        {
            "name": "kw_refresh",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": notReservedKw('refresh')
        },
        {
            "name": "kw_ifnotexists",
            "symbols": [
                "kw_if",
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not,
                "kw_exists"
            ]
        },
        {
            "name": "kw_ifexists",
            "symbols": [
                "kw_if",
                "kw_exists"
            ]
        },
        {
            "name": "kw_not_null",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not,
                lexerAny.has("kw_null") ? {
                    type: "kw_null"
                } : kw_null
            ]
        },
        {
            "name": "kw_primary_key",
            "symbols": [
                lexerAny.has("kw_primary") ? {
                    type: "kw_primary"
                } : kw_primary,
                "kw_key"
            ]
        },
        {
            "name": "data_type$ebnf$1$subexpression$1$macrocall$2",
            "symbols": [
                "int"
            ]
        },
        {
            "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "data_type$ebnf$1$subexpression$1$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1",
            "symbols": [
                "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1",
                "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "data_type$ebnf$1$subexpression$1$macrocall$1",
            "symbols": [
                "data_type$ebnf$1$subexpression$1$macrocall$2",
                "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "data_type$ebnf$1$subexpression$1",
            "symbols": [
                "lparen",
                "data_type$ebnf$1$subexpression$1$macrocall$1",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "data_type$ebnf$1",
            "symbols": [
                "data_type$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "data_type$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "data_type$ebnf$2$subexpression$1",
            "symbols": [
                lexerAny.has("kw_array") ? {
                    type: "kw_array"
                } : kw_array
            ]
        },
        {
            "name": "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("lbracket") ? {
                    type: "lbracket"
                } : lbracket,
                lexerAny.has("rbracket") ? {
                    type: "rbracket"
                } : rbracket
            ]
        },
        {
            "name": "data_type$ebnf$2$subexpression$1$ebnf$1",
            "symbols": [
                "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$1"
            ]
        },
        {
            "name": "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$2",
            "symbols": [
                lexerAny.has("lbracket") ? {
                    type: "lbracket"
                } : lbracket,
                lexerAny.has("rbracket") ? {
                    type: "rbracket"
                } : rbracket
            ]
        },
        {
            "name": "data_type$ebnf$2$subexpression$1$ebnf$1",
            "symbols": [
                "data_type$ebnf$2$subexpression$1$ebnf$1",
                "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$2"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "data_type$ebnf$2$subexpression$1",
            "symbols": [
                "data_type$ebnf$2$subexpression$1$ebnf$1"
            ]
        },
        {
            "name": "data_type$ebnf$2",
            "symbols": [
                "data_type$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "data_type$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "data_type",
            "symbols": [
                "data_type_simple",
                "data_type$ebnf$1",
                "data_type$ebnf$2"
            ],
            "postprocess": (x)=>{
                let asArray = x[2];
                const name4 = unwrap(x[0]);
                let ret5;
                ret5 = {
                    ...name4,
                    ...Array.isArray(x[1]) && x[1].length ? {
                        config: x[1].map(unwrap)
                    } : {}
                };
                if (asArray) {
                    if (asArray[0].type === 'kw_array') {
                        asArray = [
                            [
                                'array'
                            ]
                        ];
                    }
                    for (const _ of asArray[0]){
                        ret5 = {
                            kind: 'array',
                            arrayOf: ret5
                        };
                    }
                }
                return track(x, ret5);
            }
        },
        {
            "name": "data_type_list$ebnf$1",
            "symbols": []
        },
        {
            "name": "data_type_list$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "data_type"
            ],
            "postprocess": last
        },
        {
            "name": "data_type_list$ebnf$1",
            "symbols": [
                "data_type_list$ebnf$1",
                "data_type_list$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "data_type_list",
            "symbols": [
                "data_type",
                "data_type_list$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "data_type_simple",
            "symbols": [
                "data_type_text"
            ],
            "postprocess": (x)=>track(x, {
                    name: toStr(x, ' ')
                })
        },
        {
            "name": "data_type_simple",
            "symbols": [
                "data_type_numeric"
            ],
            "postprocess": (x)=>track(x, {
                    name: toStr(x, ' ')
                })
        },
        {
            "name": "data_type_simple",
            "symbols": [
                "data_type_date"
            ]
        },
        {
            "name": "data_type_simple",
            "symbols": [
                "qualified_name"
            ]
        },
        {
            "name": "data_type_numeric$subexpression$1",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": kw('double')
        },
        {
            "name": "data_type_numeric",
            "symbols": [
                "data_type_numeric$subexpression$1",
                lexerAny.has("kw_precision") ? {
                    type: "kw_precision"
                } : kw_precision
            ]
        },
        {
            "name": "data_type_text$subexpression$1",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": anyKw('character', 'bit')
        },
        {
            "name": "data_type_text$subexpression$2",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": kw('varying')
        },
        {
            "name": "data_type_text",
            "symbols": [
                "data_type_text$subexpression$1",
                "data_type_text$subexpression$2"
            ]
        },
        {
            "name": "data_type_date$subexpression$1",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": anyKw('timestamp', 'time')
        },
        {
            "name": "data_type_date$subexpression$2",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with
            ]
        },
        {
            "name": "data_type_date$subexpression$2",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": kw('without')
        },
        {
            "name": "data_type_date$subexpression$3",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": kw('time')
        },
        {
            "name": "data_type_date$subexpression$4",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": kw('zone')
        },
        {
            "name": "data_type_date",
            "symbols": [
                "data_type_date$subexpression$1",
                "data_type_date$subexpression$2",
                "data_type_date$subexpression$3",
                "data_type_date$subexpression$4"
            ],
            "postprocess": (x)=>track(x, {
                    name: toStr(x, ' ')
                })
        },
        {
            "name": "data_type_date$subexpression$5",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": anyKw('timestamp', 'time')
        },
        {
            "name": "data_type_date$subexpression$6",
            "symbols": [
                "lparen",
                "int",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "data_type_date$subexpression$7",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with
            ]
        },
        {
            "name": "data_type_date$subexpression$7",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": kw('without')
        },
        {
            "name": "data_type_date$subexpression$8",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": kw('time')
        },
        {
            "name": "data_type_date$subexpression$9",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": kw('zone')
        },
        {
            "name": "data_type_date",
            "symbols": [
                "data_type_date$subexpression$5",
                "data_type_date$subexpression$6",
                "data_type_date$subexpression$7",
                "data_type_date$subexpression$8",
                "data_type_date$subexpression$9"
            ],
            "postprocess": (x)=>track(x, {
                    name: `timestamp ${toStr(x[2])} time zone`,
                    config: [
                        unbox(x[1])
                    ]
                })
        },
        {
            "name": "ident_aliased$subexpression$1",
            "symbols": [
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "ident"
            ],
            "postprocess": last
        },
        {
            "name": "ident_aliased",
            "symbols": [
                "ident_aliased$subexpression$1"
            ]
        },
        {
            "name": "ident_aliased",
            "symbols": [
                "ident"
            ],
            "postprocess": unwrap
        },
        {
            "name": "table_ref",
            "symbols": [
                "qualified_name"
            ],
            "postprocess": unwrap
        },
        {
            "name": "qcolumn$ebnf$1$subexpression$1",
            "symbols": [
                "dot",
                "ident"
            ],
            "postprocess": last
        },
        {
            "name": "qcolumn$ebnf$1",
            "symbols": [
                "qcolumn$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "qcolumn$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "qcolumn",
            "symbols": [
                "ident",
                "dot",
                "ident",
                "qcolumn$ebnf$1"
            ],
            "postprocess": (x)=>{
                if (!x[3]) {
                    return track(x, {
                        table: unbox(x[0]),
                        column: unbox(x[2])
                    });
                }
                return track(x, {
                    schema: unbox(x[0]),
                    table: unbox(x[2]),
                    column: unbox(x[3])
                });
            }
        },
        {
            "name": "table_ref_aliased$ebnf$1",
            "symbols": [
                "ident_aliased"
            ],
            "postprocess": id
        },
        {
            "name": "table_ref_aliased$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "table_ref_aliased",
            "symbols": [
                "table_ref",
                "table_ref_aliased$ebnf$1"
            ],
            "postprocess": (x)=>{
                const alias = unwrap(x[1]);
                return track(x, {
                    ...unwrap(x[0]),
                    ...alias ? {
                        alias
                    } : {}
                });
            }
        },
        {
            "name": "qualified_name",
            "symbols": [
                "qname_ident"
            ],
            "postprocess": (x)=>track(x, {
                    name: toStr(x)
                })
        },
        {
            "name": "qualified_name",
            "symbols": [
                "ident",
                "dot",
                "ident_extended"
            ],
            "postprocess": (x)=>{
                const schema = toStr(x[0]);
                const name5 = toStr(x[2]);
                return track(x, {
                    schema,
                    name: name5
                });
            }
        },
        {
            "name": "qualified_name",
            "symbols": [
                lexerAny.has("kw_current_schema") ? {
                    type: "kw_current_schema"
                } : kw_current_schema
            ],
            "postprocess": (x)=>track(x, {
                    name: 'current_schema'
                })
        },
        {
            "name": "qname_ident",
            "symbols": [
                "ident"
            ]
        },
        {
            "name": "qname_ident",
            "symbols": [
                lexerAny.has("kw_precision") ? {
                    type: "kw_precision"
                } : kw_precision
            ]
        },
        {
            "name": "qname",
            "symbols": [
                "qualified_name"
            ],
            "postprocess": unwrap
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_all") ? {
                    type: "kw_all"
                } : kw_all
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_analyse") ? {
                    type: "kw_analyse"
                } : kw_analyse
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_analyze") ? {
                    type: "kw_analyze"
                } : kw_analyze
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_and") ? {
                    type: "kw_and"
                } : kw_and
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_any") ? {
                    type: "kw_any"
                } : kw_any
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_array") ? {
                    type: "kw_array"
                } : kw_array
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_asc") ? {
                    type: "kw_asc"
                } : kw_asc
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_asymmetric") ? {
                    type: "kw_asymmetric"
                } : kw_asymmetric
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_authorization") ? {
                    type: "kw_authorization"
                } : kw_authorization
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_binary") ? {
                    type: "kw_binary"
                } : kw_binary
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_both") ? {
                    type: "kw_both"
                } : kw_both
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_case") ? {
                    type: "kw_case"
                } : kw_case
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_cast") ? {
                    type: "kw_cast"
                } : kw_cast
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_check") ? {
                    type: "kw_check"
                } : kw_check
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_collate") ? {
                    type: "kw_collate"
                } : kw_collate
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_collation") ? {
                    type: "kw_collation"
                } : kw_collation
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_concurrently") ? {
                    type: "kw_concurrently"
                } : kw_concurrently
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_constraint") ? {
                    type: "kw_constraint"
                } : kw_constraint
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_cross") ? {
                    type: "kw_cross"
                } : kw_cross
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_current_catalog") ? {
                    type: "kw_current_catalog"
                } : kw_current_catalog
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_current_date") ? {
                    type: "kw_current_date"
                } : kw_current_date
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_current_role") ? {
                    type: "kw_current_role"
                } : kw_current_role
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_current_schema") ? {
                    type: "kw_current_schema"
                } : kw_current_schema
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_current_time") ? {
                    type: "kw_current_time"
                } : kw_current_time
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_current_timestamp") ? {
                    type: "kw_current_timestamp"
                } : kw_current_timestamp
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_current_user") ? {
                    type: "kw_current_user"
                } : kw_current_user
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_deferrable") ? {
                    type: "kw_deferrable"
                } : kw_deferrable
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_desc") ? {
                    type: "kw_desc"
                } : kw_desc
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_distinct") ? {
                    type: "kw_distinct"
                } : kw_distinct
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_do") ? {
                    type: "kw_do"
                } : kw_do
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_else") ? {
                    type: "kw_else"
                } : kw_else
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_end") ? {
                    type: "kw_end"
                } : kw_end
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_except") ? {
                    type: "kw_except"
                } : kw_except
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_false") ? {
                    type: "kw_false"
                } : kw_false
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_fetch") ? {
                    type: "kw_fetch"
                } : kw_fetch
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_for") ? {
                    type: "kw_for"
                } : kw_for
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_foreign") ? {
                    type: "kw_foreign"
                } : kw_foreign
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_freeze") ? {
                    type: "kw_freeze"
                } : kw_freeze
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_from") ? {
                    type: "kw_from"
                } : kw_from
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_full") ? {
                    type: "kw_full"
                } : kw_full
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_grant") ? {
                    type: "kw_grant"
                } : kw_grant
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_group") ? {
                    type: "kw_group"
                } : kw_group
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_having") ? {
                    type: "kw_having"
                } : kw_having
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_ilike") ? {
                    type: "kw_ilike"
                } : kw_ilike
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_in") ? {
                    type: "kw_in"
                } : kw_in
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_initially") ? {
                    type: "kw_initially"
                } : kw_initially
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_inner") ? {
                    type: "kw_inner"
                } : kw_inner
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_intersect") ? {
                    type: "kw_intersect"
                } : kw_intersect
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_into") ? {
                    type: "kw_into"
                } : kw_into
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_is") ? {
                    type: "kw_is"
                } : kw_is
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_isnull") ? {
                    type: "kw_isnull"
                } : kw_isnull
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_join") ? {
                    type: "kw_join"
                } : kw_join
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_lateral") ? {
                    type: "kw_lateral"
                } : kw_lateral
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_leading") ? {
                    type: "kw_leading"
                } : kw_leading
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_left") ? {
                    type: "kw_left"
                } : kw_left
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_like") ? {
                    type: "kw_like"
                } : kw_like
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_limit") ? {
                    type: "kw_limit"
                } : kw_limit
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_localtime") ? {
                    type: "kw_localtime"
                } : kw_localtime
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_localtimestamp") ? {
                    type: "kw_localtimestamp"
                } : kw_localtimestamp
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_natural") ? {
                    type: "kw_natural"
                } : kw_natural
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_notnull") ? {
                    type: "kw_notnull"
                } : kw_notnull
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_null") ? {
                    type: "kw_null"
                } : kw_null
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_offset") ? {
                    type: "kw_offset"
                } : kw_offset
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_only") ? {
                    type: "kw_only"
                } : kw_only
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_or") ? {
                    type: "kw_or"
                } : kw_or
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_order") ? {
                    type: "kw_order"
                } : kw_order
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_outer") ? {
                    type: "kw_outer"
                } : kw_outer
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_overlaps") ? {
                    type: "kw_overlaps"
                } : kw_overlaps
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_placing") ? {
                    type: "kw_placing"
                } : kw_placing
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_primary") ? {
                    type: "kw_primary"
                } : kw_primary
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_references") ? {
                    type: "kw_references"
                } : kw_references
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_returning") ? {
                    type: "kw_returning"
                } : kw_returning
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_right") ? {
                    type: "kw_right"
                } : kw_right
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_select") ? {
                    type: "kw_select"
                } : kw_select
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_session_user") ? {
                    type: "kw_session_user"
                } : kw_session_user
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_similar") ? {
                    type: "kw_similar"
                } : kw_similar
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_some") ? {
                    type: "kw_some"
                } : kw_some
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_symmetric") ? {
                    type: "kw_symmetric"
                } : kw_symmetric
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_table") ? {
                    type: "kw_table"
                } : kw_table
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_tablesample") ? {
                    type: "kw_tablesample"
                } : kw_tablesample
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_then") ? {
                    type: "kw_then"
                } : kw_then
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_trailing") ? {
                    type: "kw_trailing"
                } : kw_trailing
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_true") ? {
                    type: "kw_true"
                } : kw_true
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_union") ? {
                    type: "kw_union"
                } : kw_union
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_unique") ? {
                    type: "kw_unique"
                } : kw_unique
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_user") ? {
                    type: "kw_user"
                } : kw_user
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_using") ? {
                    type: "kw_using"
                } : kw_using
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_variadic") ? {
                    type: "kw_variadic"
                } : kw_variadic
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_verbose") ? {
                    type: "kw_verbose"
                } : kw_verbose
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_when") ? {
                    type: "kw_when"
                } : kw_when
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_where") ? {
                    type: "kw_where"
                } : kw_where
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_window") ? {
                    type: "kw_window"
                } : kw_window
            ]
        },
        {
            "name": "any_keyword",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with
            ]
        },
        {
            "name": "ident_extended",
            "symbols": [
                "ident"
            ]
        },
        {
            "name": "ident_extended",
            "symbols": [
                "any_keyword"
            ]
        },
        {
            "name": "select_statement$ebnf$1",
            "symbols": [
                "select_from"
            ],
            "postprocess": id
        },
        {
            "name": "select_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_statement$ebnf$2",
            "symbols": [
                "select_where"
            ],
            "postprocess": id
        },
        {
            "name": "select_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_statement$ebnf$3",
            "symbols": [
                "select_groupby"
            ],
            "postprocess": id
        },
        {
            "name": "select_statement$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_statement$ebnf$4",
            "symbols": [
                "select_order_by"
            ],
            "postprocess": id
        },
        {
            "name": "select_statement$ebnf$4",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_statement$ebnf$5",
            "symbols": [
                "select_limit_offset"
            ],
            "postprocess": id
        },
        {
            "name": "select_statement$ebnf$5",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_statement$ebnf$6",
            "symbols": [
                "select_for"
            ],
            "postprocess": id
        },
        {
            "name": "select_statement$ebnf$6",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_statement",
            "symbols": [
                "select_what",
                "select_statement$ebnf$1",
                "select_statement$ebnf$2",
                "select_statement$ebnf$3",
                "select_statement$ebnf$4",
                "select_statement$ebnf$5",
                "select_statement$ebnf$6"
            ],
            "postprocess": (x)=>{
                let [what, from, where, groupBy, orderBy, limit, selectFor] = x;
                from = unwrap(from);
                groupBy = groupBy && (groupBy.length === 1 && groupBy[0].type === 'list' ? groupBy[0].expressions : groupBy);
                return track(x, {
                    ...what,
                    ...from ? {
                        from: Array.isArray(from) ? from : [
                            from
                        ]
                    } : {},
                    ...groupBy ? {
                        groupBy
                    } : {},
                    ...limit ? {
                        limit: unwrap(limit)
                    } : {},
                    ...orderBy ? {
                        orderBy
                    } : {},
                    ...where ? {
                        where
                    } : {},
                    ...selectFor ? {
                        for: selectFor[1]
                    } : {},
                    type: 'select'
                });
            }
        },
        {
            "name": "select_from",
            "symbols": [
                lexerAny.has("kw_from") ? {
                    type: "kw_from"
                } : kw_from,
                "select_from_items"
            ],
            "postprocess": last
        },
        {
            "name": "select_from_items$ebnf$1",
            "symbols": []
        },
        {
            "name": "select_from_items$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "select_from_item"
            ],
            "postprocess": last
        },
        {
            "name": "select_from_items$ebnf$1",
            "symbols": [
                "select_from_items$ebnf$1",
                "select_from_items$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "select_from_items",
            "symbols": [
                "select_from_item",
                "select_from_items$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    ...head,
                    ...flatten(tail) || []
                ];
            }
        },
        {
            "name": "select_from_item",
            "symbols": [
                "select_from_subject"
            ]
        },
        {
            "name": "select_from_item",
            "symbols": [
                "select_from_item_joins"
            ],
            "postprocess": get(0)
        },
        {
            "name": "select_from_item_joins$subexpression$1",
            "symbols": [
                "select_from_item"
            ],
            "postprocess": get(0)
        },
        {
            "name": "select_from_item_joins",
            "symbols": [
                "select_from_item_joins$subexpression$1",
                "select_table_join"
            ],
            "postprocess": flatten
        },
        {
            "name": "select_from_item_joins",
            "symbols": [
                "lparen",
                "select_from_item_joins",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "select_from_subject",
            "symbols": [
                "stb_table"
            ],
            "postprocess": unwrap
        },
        {
            "name": "select_from_subject",
            "symbols": [
                "stb_statement"
            ],
            "postprocess": unwrap
        },
        {
            "name": "select_from_subject",
            "symbols": [
                "stb_call"
            ],
            "postprocess": unwrap
        },
        {
            "name": "stb_opts$ebnf$1",
            "symbols": [
                "collist_paren"
            ],
            "postprocess": id
        },
        {
            "name": "stb_opts$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "stb_opts",
            "symbols": [
                "ident_aliased",
                "stb_opts$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    alias: toStr(x[0]),
                    ...x[1] && {
                        columnNames: unbox(x[1]).map(asName)
                    }
                })
        },
        {
            "name": "stb_table$ebnf$1",
            "symbols": [
                "stb_opts"
            ],
            "postprocess": id
        },
        {
            "name": "stb_table$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "stb_table",
            "symbols": [
                "table_ref",
                "stb_table$ebnf$1"
            ],
            "postprocess": (x)=>{
                return track(x, {
                    type: 'table',
                    name: track(x, {
                        ...x[0],
                        ...x[1]
                    })
                });
            }
        },
        {
            "name": "stb_statement",
            "symbols": [
                "selection_paren",
                "stb_opts"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'statement',
                    statement: unwrap(x[0]),
                    ...x[1]
                })
        },
        {
            "name": "select_values",
            "symbols": [
                "kw_values",
                "insert_values"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'values',
                    values: x[1]
                })
        },
        {
            "name": "stb_call$ebnf$1$subexpression$1$ebnf$1",
            "symbols": [
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as
            ],
            "postprocess": id
        },
        {
            "name": "stb_call$ebnf$1$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "stb_call$ebnf$1$subexpression$1",
            "symbols": [
                "stb_call$ebnf$1$subexpression$1$ebnf$1",
                "ident"
            ],
            "postprocess": last
        },
        {
            "name": "stb_call$ebnf$1",
            "symbols": [
                "stb_call$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "stb_call$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "stb_call",
            "symbols": [
                "expr_call",
                "stb_call$ebnf$1"
            ],
            "postprocess": (x)=>!x[1] ? x[0] : track(x, {
                    ...x[0],
                    alias: asName(x[1])
                })
        },
        {
            "name": "select_table_join$ebnf$1",
            "symbols": [
                "select_table_join_clause"
            ],
            "postprocess": id
        },
        {
            "name": "select_table_join$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_table_join",
            "symbols": [
                "select_join_op",
                lexerAny.has("kw_join") ? {
                    type: "kw_join"
                } : kw_join,
                "select_from_subject",
                "select_table_join$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    ...unwrap(x[2]),
                    join: {
                        type: toStr(x[0], ' '),
                        ...x[3] && unwrap(x[3])
                    }
                })
        },
        {
            "name": "select_table_join_clause",
            "symbols": [
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on,
                "expr"
            ],
            "postprocess": (x)=>track(x, {
                    on: last(x)
                })
        },
        {
            "name": "select_table_join_clause$macrocall$2",
            "symbols": [
                "ident"
            ]
        },
        {
            "name": "select_table_join_clause$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "select_table_join_clause$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "select_table_join_clause$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "select_table_join_clause$macrocall$1$ebnf$1",
            "symbols": [
                "select_table_join_clause$macrocall$1$ebnf$1",
                "select_table_join_clause$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "select_table_join_clause$macrocall$1",
            "symbols": [
                "select_table_join_clause$macrocall$2",
                "select_table_join_clause$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "select_table_join_clause",
            "symbols": [
                lexerAny.has("kw_using") ? {
                    type: "kw_using"
                } : kw_using,
                "lparen",
                "select_table_join_clause$macrocall$1",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    using: x[2].map(asName)
                })
        },
        {
            "name": "select_join_op$subexpression$1$ebnf$1",
            "symbols": [
                lexerAny.has("kw_inner") ? {
                    type: "kw_inner"
                } : kw_inner
            ],
            "postprocess": id
        },
        {
            "name": "select_join_op$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_join_op$subexpression$1",
            "symbols": [
                "select_join_op$subexpression$1$ebnf$1"
            ],
            "postprocess": (x)=>box(x, 'INNER JOIN')
        },
        {
            "name": "select_join_op",
            "symbols": [
                "select_join_op$subexpression$1"
            ]
        },
        {
            "name": "select_join_op$subexpression$2",
            "symbols": [
                lexerAny.has("kw_cross") ? {
                    type: "kw_cross"
                } : kw_cross
            ],
            "postprocess": (x)=>box(x, 'CROSS JOIN')
        },
        {
            "name": "select_join_op",
            "symbols": [
                "select_join_op$subexpression$2"
            ]
        },
        {
            "name": "select_join_op$subexpression$3$ebnf$1",
            "symbols": [
                lexerAny.has("kw_outer") ? {
                    type: "kw_outer"
                } : kw_outer
            ],
            "postprocess": id
        },
        {
            "name": "select_join_op$subexpression$3$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_join_op$subexpression$3",
            "symbols": [
                lexerAny.has("kw_left") ? {
                    type: "kw_left"
                } : kw_left,
                "select_join_op$subexpression$3$ebnf$1"
            ],
            "postprocess": (x)=>box(x, 'LEFT JOIN')
        },
        {
            "name": "select_join_op",
            "symbols": [
                "select_join_op$subexpression$3"
            ]
        },
        {
            "name": "select_join_op$subexpression$4$ebnf$1",
            "symbols": [
                lexerAny.has("kw_outer") ? {
                    type: "kw_outer"
                } : kw_outer
            ],
            "postprocess": id
        },
        {
            "name": "select_join_op$subexpression$4$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_join_op$subexpression$4",
            "symbols": [
                lexerAny.has("kw_right") ? {
                    type: "kw_right"
                } : kw_right,
                "select_join_op$subexpression$4$ebnf$1"
            ],
            "postprocess": (x)=>box(x, 'RIGHT JOIN')
        },
        {
            "name": "select_join_op",
            "symbols": [
                "select_join_op$subexpression$4"
            ]
        },
        {
            "name": "select_join_op$subexpression$5$ebnf$1",
            "symbols": [
                lexerAny.has("kw_outer") ? {
                    type: "kw_outer"
                } : kw_outer
            ],
            "postprocess": id
        },
        {
            "name": "select_join_op$subexpression$5$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_join_op$subexpression$5",
            "symbols": [
                lexerAny.has("kw_full") ? {
                    type: "kw_full"
                } : kw_full,
                "select_join_op$subexpression$5$ebnf$1"
            ],
            "postprocess": (x)=>box(x, 'FULL JOIN')
        },
        {
            "name": "select_join_op",
            "symbols": [
                "select_join_op$subexpression$5"
            ]
        },
        {
            "name": "select_what$ebnf$1",
            "symbols": [
                "select_distinct"
            ],
            "postprocess": id
        },
        {
            "name": "select_what$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_what$ebnf$2",
            "symbols": [
                "select_expr_list_aliased"
            ],
            "postprocess": id
        },
        {
            "name": "select_what$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_what",
            "symbols": [
                lexerAny.has("kw_select") ? {
                    type: "kw_select"
                } : kw_select,
                "select_what$ebnf$1",
                "select_what$ebnf$2"
            ],
            "postprocess": (x)=>track(x, {
                    columns: x[2],
                    ...x[1] && {
                        distinct: unbox(x[1])
                    }
                })
        },
        {
            "name": "select_expr_list_aliased$ebnf$1",
            "symbols": []
        },
        {
            "name": "select_expr_list_aliased$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "select_expr_list_item"
            ],
            "postprocess": last
        },
        {
            "name": "select_expr_list_aliased$ebnf$1",
            "symbols": [
                "select_expr_list_aliased$ebnf$1",
                "select_expr_list_aliased$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "select_expr_list_aliased",
            "symbols": [
                "select_expr_list_item",
                "select_expr_list_aliased$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "select_expr_list_item$ebnf$1",
            "symbols": [
                "ident_aliased"
            ],
            "postprocess": id
        },
        {
            "name": "select_expr_list_item$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_expr_list_item",
            "symbols": [
                "expr",
                "select_expr_list_item$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    expr: x[0],
                    ...x[1] ? {
                        alias: asName(x[1])
                    } : {}
                })
        },
        {
            "name": "select_distinct",
            "symbols": [
                lexerAny.has("kw_all") ? {
                    type: "kw_all"
                } : kw_all
            ],
            "postprocess": (x)=>box(x, 'all')
        },
        {
            "name": "select_distinct$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on,
                "lparen",
                "expr_list_raw",
                "rparen"
            ],
            "postprocess": get(2)
        },
        {
            "name": "select_distinct$ebnf$1",
            "symbols": [
                "select_distinct$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "select_distinct$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_distinct",
            "symbols": [
                lexerAny.has("kw_distinct") ? {
                    type: "kw_distinct"
                } : kw_distinct,
                "select_distinct$ebnf$1"
            ],
            "postprocess": (x)=>box(x, x[1] || 'distinct')
        },
        {
            "name": "select_where",
            "symbols": [
                lexerAny.has("kw_where") ? {
                    type: "kw_where"
                } : kw_where,
                "expr"
            ],
            "postprocess": last
        },
        {
            "name": "select_groupby",
            "symbols": [
                lexerAny.has("kw_group") ? {
                    type: "kw_group"
                } : kw_group,
                "kw_by",
                "expr_list_raw"
            ],
            "postprocess": last
        },
        {
            "name": "select_limit_offset$ebnf$1$subexpression$1",
            "symbols": [
                "select_offset"
            ]
        },
        {
            "name": "select_limit_offset$ebnf$1$subexpression$1",
            "symbols": [
                "select_limit"
            ]
        },
        {
            "name": "select_limit_offset$ebnf$1",
            "symbols": [
                "select_limit_offset$ebnf$1$subexpression$1"
            ]
        },
        {
            "name": "select_limit_offset$ebnf$1$subexpression$2",
            "symbols": [
                "select_offset"
            ]
        },
        {
            "name": "select_limit_offset$ebnf$1$subexpression$2",
            "symbols": [
                "select_limit"
            ]
        },
        {
            "name": "select_limit_offset$ebnf$1",
            "symbols": [
                "select_limit_offset$ebnf$1",
                "select_limit_offset$ebnf$1$subexpression$2"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "select_limit_offset",
            "symbols": [
                "select_limit_offset$ebnf$1"
            ],
            "postprocess": (x, rej)=>{
                const value3 = unwrap(x);
                if (!Array.isArray(value3)) {
                    return track(x, value3);
                }
                if (value3.length != 2) {
                    return rej;
                }
                const a = unwrap(value3[0]);
                const b3 = unwrap(value3[1]);
                if (a.offset && b3.offset || a.limit && b3.limit) {
                    return rej;
                }
                return track(x, {
                    ...a,
                    ...b3
                });
            }
        },
        {
            "name": "select_offset$ebnf$1$subexpression$1",
            "symbols": [
                "kw_row"
            ]
        },
        {
            "name": "select_offset$ebnf$1$subexpression$1",
            "symbols": [
                "kw_rows"
            ]
        },
        {
            "name": "select_offset$ebnf$1",
            "symbols": [
                "select_offset$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "select_offset$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_offset",
            "symbols": [
                lexerAny.has("kw_offset") ? {
                    type: "kw_offset"
                } : kw_offset,
                "expr_nostar",
                "select_offset$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    offset: unwrap(x[1])
                })
        },
        {
            "name": "select_limit$subexpression$1",
            "symbols": [
                "select_limit_1"
            ]
        },
        {
            "name": "select_limit$subexpression$1",
            "symbols": [
                "select_limit_2"
            ]
        },
        {
            "name": "select_limit",
            "symbols": [
                "select_limit$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    limit: unwrap(x)
                })
        },
        {
            "name": "select_limit_1",
            "symbols": [
                lexerAny.has("kw_limit") ? {
                    type: "kw_limit"
                } : kw_limit,
                "expr_nostar"
            ],
            "postprocess": last
        },
        {
            "name": "select_limit_2$ebnf$1$subexpression$1",
            "symbols": [
                "kw_first"
            ]
        },
        {
            "name": "select_limit_2$ebnf$1$subexpression$1",
            "symbols": [
                "kw_next"
            ]
        },
        {
            "name": "select_limit_2$ebnf$1",
            "symbols": [
                "select_limit_2$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "select_limit_2$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_limit_2$subexpression$1",
            "symbols": [
                "kw_row"
            ]
        },
        {
            "name": "select_limit_2$subexpression$1",
            "symbols": [
                "kw_rows"
            ]
        },
        {
            "name": "select_limit_2",
            "symbols": [
                lexerAny.has("kw_fetch") ? {
                    type: "kw_fetch"
                } : kw_fetch,
                "select_limit_2$ebnf$1",
                "expr_nostar",
                "select_limit_2$subexpression$1",
                lexerAny.has("kw_only") ? {
                    type: "kw_only"
                } : kw_only
            ],
            "postprocess": get(2)
        },
        {
            "name": "select_for$subexpression$1",
            "symbols": [
                "kw_update"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'update'
                })
        },
        {
            "name": "select_for$subexpression$1",
            "symbols": [
                "kw_no",
                "kw_key",
                "kw_update"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'no key update'
                })
        },
        {
            "name": "select_for$subexpression$1",
            "symbols": [
                "kw_share"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'share'
                })
        },
        {
            "name": "select_for$subexpression$1",
            "symbols": [
                "kw_key",
                "kw_share"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'key share'
                })
        },
        {
            "name": "select_for",
            "symbols": [
                lexerAny.has("kw_for") ? {
                    type: "kw_for"
                } : kw_for,
                "select_for$subexpression$1"
            ]
        },
        {
            "name": "select_order_by$subexpression$1",
            "symbols": [
                lexerAny.has("kw_order") ? {
                    type: "kw_order"
                } : kw_order,
                "kw_by"
            ]
        },
        {
            "name": "select_order_by$ebnf$1",
            "symbols": []
        },
        {
            "name": "select_order_by$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "select_order_by_expr"
            ],
            "postprocess": last
        },
        {
            "name": "select_order_by$ebnf$1",
            "symbols": [
                "select_order_by$ebnf$1",
                "select_order_by$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "select_order_by",
            "symbols": [
                "select_order_by$subexpression$1",
                "select_order_by_expr",
                "select_order_by$ebnf$1"
            ],
            "postprocess": ([_, head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "select_order_by_expr$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_asc") ? {
                    type: "kw_asc"
                } : kw_asc
            ]
        },
        {
            "name": "select_order_by_expr$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_desc") ? {
                    type: "kw_desc"
                } : kw_desc
            ]
        },
        {
            "name": "select_order_by_expr$ebnf$1",
            "symbols": [
                "select_order_by_expr$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "select_order_by_expr$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1",
            "symbols": [
                "kw_first"
            ]
        },
        {
            "name": "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1",
            "symbols": [
                "kw_last"
            ]
        },
        {
            "name": "select_order_by_expr$ebnf$2$subexpression$1",
            "symbols": [
                "kw_nulls",
                "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1"
            ],
            "postprocess": last
        },
        {
            "name": "select_order_by_expr$ebnf$2",
            "symbols": [
                "select_order_by_expr$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "select_order_by_expr$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "select_order_by_expr",
            "symbols": [
                "expr",
                "select_order_by_expr$ebnf$1",
                "select_order_by_expr$ebnf$2"
            ],
            "postprocess": (x)=>track(x, {
                    by: x[0],
                    ...x[1] && {
                        order: toStr(x[1]).toUpperCase()
                    },
                    ...x[2] && {
                        nulls: toStr(x[2]).toUpperCase()
                    }
                })
        },
        {
            "name": "expr",
            "symbols": [
                "expr_nostar"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr",
            "symbols": [
                "expr_star"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_nostar",
            "symbols": [
                "expr_paren"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_nostar",
            "symbols": [
                "expr_or"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_paren$subexpression$1",
            "symbols": [
                "expr_or_select"
            ]
        },
        {
            "name": "expr_paren$subexpression$1",
            "symbols": [
                "expr_list_many"
            ]
        },
        {
            "name": "expr_paren",
            "symbols": [
                "lparen",
                "expr_paren$subexpression$1",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "expr_or$macrocall$2$macrocall$2",
            "symbols": [
                lexerAny.has("kw_or") ? {
                    type: "kw_or"
                } : kw_or
            ]
        },
        {
            "name": "expr_or$macrocall$2$macrocall$1",
            "symbols": [
                "expr_or$macrocall$2$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_or$macrocall$2",
            "symbols": [
                "expr_or$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_or$macrocall$3",
            "symbols": [
                "expr_or"
            ]
        },
        {
            "name": "expr_or$macrocall$4",
            "symbols": [
                "expr_and"
            ]
        },
        {
            "name": "expr_or$macrocall$1$subexpression$1",
            "symbols": [
                "expr_or$macrocall$3"
            ]
        },
        {
            "name": "expr_or$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_or$macrocall$1$subexpression$2",
            "symbols": [
                "expr_or$macrocall$4"
            ]
        },
        {
            "name": "expr_or$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_or$macrocall$1",
            "symbols": [
                "expr_or$macrocall$1$subexpression$1",
                "expr_or$macrocall$2",
                "expr_or$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_or$macrocall$1",
            "symbols": [
                "expr_or$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_or",
            "symbols": [
                "expr_or$macrocall$1"
            ]
        },
        {
            "name": "expr_and$macrocall$2$macrocall$2",
            "symbols": [
                lexerAny.has("kw_and") ? {
                    type: "kw_and"
                } : kw_and
            ]
        },
        {
            "name": "expr_and$macrocall$2$macrocall$1",
            "symbols": [
                "expr_and$macrocall$2$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_and$macrocall$2",
            "symbols": [
                "expr_and$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_and$macrocall$3",
            "symbols": [
                "expr_and"
            ]
        },
        {
            "name": "expr_and$macrocall$4",
            "symbols": [
                "expr_not"
            ]
        },
        {
            "name": "expr_and$macrocall$1$subexpression$1",
            "symbols": [
                "expr_and$macrocall$3"
            ]
        },
        {
            "name": "expr_and$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_and$macrocall$1$subexpression$2",
            "symbols": [
                "expr_and$macrocall$4"
            ]
        },
        {
            "name": "expr_and$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_and$macrocall$1",
            "symbols": [
                "expr_and$macrocall$1$subexpression$1",
                "expr_and$macrocall$2",
                "expr_and$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_and$macrocall$1",
            "symbols": [
                "expr_and$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_and",
            "symbols": [
                "expr_and$macrocall$1"
            ]
        },
        {
            "name": "expr_not$macrocall$2$macrocall$2",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not
            ]
        },
        {
            "name": "expr_not$macrocall$2$macrocall$1",
            "symbols": [
                "expr_not$macrocall$2$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_not$macrocall$2",
            "symbols": [
                "expr_not$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_not$macrocall$3",
            "symbols": [
                "expr_not"
            ]
        },
        {
            "name": "expr_not$macrocall$4",
            "symbols": [
                "expr_eq"
            ]
        },
        {
            "name": "expr_not$macrocall$1$subexpression$1",
            "symbols": [
                "expr_not$macrocall$3"
            ]
        },
        {
            "name": "expr_not$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_not$macrocall$1",
            "symbols": [
                "expr_not$macrocall$2",
                "expr_not$macrocall$1$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'unary',
                    ...unwrap(x[0]),
                    operand: unwrap(x[1])
                })
        },
        {
            "name": "expr_not$macrocall$1",
            "symbols": [
                "expr_not$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_not",
            "symbols": [
                "expr_not$macrocall$1"
            ]
        },
        {
            "name": "expr_eq$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_eq") ? {
                    type: "op_eq"
                } : op_eq
            ]
        },
        {
            "name": "expr_eq$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_neq") ? {
                    type: "op_neq"
                } : op_neq
            ]
        },
        {
            "name": "expr_eq$macrocall$2$macrocall$2",
            "symbols": [
                "expr_eq$macrocall$2$macrocall$2$subexpression$1"
            ]
        },
        {
            "name": "expr_eq$macrocall$2$macrocall$1$macrocall$2",
            "symbols": [
                "expr_eq$macrocall$2$macrocall$2"
            ]
        },
        {
            "name": "expr_eq$macrocall$2$macrocall$1$macrocall$1",
            "symbols": [
                "expr_eq$macrocall$2$macrocall$1$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_eq$macrocall$2$macrocall$1",
            "symbols": [
                "expr_eq$macrocall$2$macrocall$1$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_eq$macrocall$2$macrocall$1",
            "symbols": [
                "kw_operator",
                "lparen",
                "ident",
                "dot",
                "expr_eq$macrocall$2$macrocall$2",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x[4], ' ') || '<error>').toUpperCase(),
                    opSchema: toStr(x[2])
                })
        },
        {
            "name": "expr_eq$macrocall$2",
            "symbols": [
                "expr_eq$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_eq$macrocall$3",
            "symbols": [
                "expr_eq"
            ]
        },
        {
            "name": "expr_eq$macrocall$4",
            "symbols": [
                "expr_is"
            ]
        },
        {
            "name": "expr_eq$macrocall$1$subexpression$1",
            "symbols": [
                "expr_eq$macrocall$3"
            ]
        },
        {
            "name": "expr_eq$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_eq$macrocall$1$subexpression$2",
            "symbols": [
                "expr_eq$macrocall$4"
            ]
        },
        {
            "name": "expr_eq$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_eq$macrocall$1",
            "symbols": [
                "expr_eq$macrocall$1$subexpression$1",
                "expr_eq$macrocall$2",
                "expr_eq$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_eq$macrocall$1",
            "symbols": [
                "expr_eq$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_eq",
            "symbols": [
                "expr_eq$macrocall$1"
            ]
        },
        {
            "name": "expr_star",
            "symbols": [
                "star"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'ref',
                    name: '*'
                })
        },
        {
            "name": "expr_is$subexpression$1",
            "symbols": [
                "expr_is"
            ]
        },
        {
            "name": "expr_is$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_is$subexpression$2",
            "symbols": [
                lexerAny.has("kw_isnull") ? {
                    type: "kw_isnull"
                } : kw_isnull
            ]
        },
        {
            "name": "expr_is$subexpression$2",
            "symbols": [
                lexerAny.has("kw_is") ? {
                    type: "kw_is"
                } : kw_is,
                lexerAny.has("kw_null") ? {
                    type: "kw_null"
                } : kw_null
            ]
        },
        {
            "name": "expr_is",
            "symbols": [
                "expr_is$subexpression$1",
                "expr_is$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'unary',
                    op: 'IS NULL',
                    operand: unwrap(x[0])
                })
        },
        {
            "name": "expr_is$subexpression$3",
            "symbols": [
                "expr_is"
            ]
        },
        {
            "name": "expr_is$subexpression$3",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_is$subexpression$4",
            "symbols": [
                lexerAny.has("kw_notnull") ? {
                    type: "kw_notnull"
                } : kw_notnull
            ]
        },
        {
            "name": "expr_is$subexpression$4",
            "symbols": [
                lexerAny.has("kw_is") ? {
                    type: "kw_is"
                } : kw_is,
                "kw_not_null"
            ]
        },
        {
            "name": "expr_is",
            "symbols": [
                "expr_is$subexpression$3",
                "expr_is$subexpression$4"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'unary',
                    op: 'IS NOT NULL',
                    operand: unwrap(x[0])
                })
        },
        {
            "name": "expr_is$subexpression$5",
            "symbols": [
                "expr_is"
            ]
        },
        {
            "name": "expr_is$subexpression$5",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_is$ebnf$1",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not
            ],
            "postprocess": id
        },
        {
            "name": "expr_is$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_is$subexpression$6",
            "symbols": [
                lexerAny.has("kw_true") ? {
                    type: "kw_true"
                } : kw_true
            ]
        },
        {
            "name": "expr_is$subexpression$6",
            "symbols": [
                lexerAny.has("kw_false") ? {
                    type: "kw_false"
                } : kw_false
            ]
        },
        {
            "name": "expr_is",
            "symbols": [
                "expr_is$subexpression$5",
                lexerAny.has("kw_is") ? {
                    type: "kw_is"
                } : kw_is,
                "expr_is$ebnf$1",
                "expr_is$subexpression$6"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'unary',
                    op: 'IS ' + flattenStr([
                        x[2],
                        x[3]
                    ]).join(' ').toUpperCase(),
                    operand: unwrap(x[0])
                })
        },
        {
            "name": "expr_is",
            "symbols": [
                "expr_compare"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_compare$macrocall$2$macrocall$2",
            "symbols": [
                lexerAny.has("op_compare") ? {
                    type: "op_compare"
                } : op_compare
            ]
        },
        {
            "name": "expr_compare$macrocall$2$macrocall$1$macrocall$2",
            "symbols": [
                "expr_compare$macrocall$2$macrocall$2"
            ]
        },
        {
            "name": "expr_compare$macrocall$2$macrocall$1$macrocall$1",
            "symbols": [
                "expr_compare$macrocall$2$macrocall$1$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_compare$macrocall$2$macrocall$1",
            "symbols": [
                "expr_compare$macrocall$2$macrocall$1$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_compare$macrocall$2$macrocall$1",
            "symbols": [
                "kw_operator",
                "lparen",
                "ident",
                "dot",
                "expr_compare$macrocall$2$macrocall$2",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x[4], ' ') || '<error>').toUpperCase(),
                    opSchema: toStr(x[2])
                })
        },
        {
            "name": "expr_compare$macrocall$2",
            "symbols": [
                "expr_compare$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_compare$macrocall$3",
            "symbols": [
                "expr_compare"
            ]
        },
        {
            "name": "expr_compare$macrocall$4",
            "symbols": [
                "expr_range"
            ]
        },
        {
            "name": "expr_compare$macrocall$1$subexpression$1",
            "symbols": [
                "expr_compare$macrocall$3"
            ]
        },
        {
            "name": "expr_compare$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_compare$macrocall$1$subexpression$2",
            "symbols": [
                "expr_compare$macrocall$4"
            ]
        },
        {
            "name": "expr_compare$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_compare$macrocall$1",
            "symbols": [
                "expr_compare$macrocall$1$subexpression$1",
                "expr_compare$macrocall$2",
                "expr_compare$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_compare$macrocall$1",
            "symbols": [
                "expr_compare$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_compare",
            "symbols": [
                "expr_compare$macrocall$1"
            ]
        },
        {
            "name": "expr_range$macrocall$2",
            "symbols": [
                "ops_between"
            ]
        },
        {
            "name": "expr_range$macrocall$3",
            "symbols": [
                lexerAny.has("kw_and") ? {
                    type: "kw_and"
                } : kw_and
            ]
        },
        {
            "name": "expr_range$macrocall$4",
            "symbols": [
                "expr_range"
            ]
        },
        {
            "name": "expr_range$macrocall$5",
            "symbols": [
                "expr_others"
            ]
        },
        {
            "name": "expr_range$macrocall$1$subexpression$1",
            "symbols": [
                "expr_range$macrocall$4"
            ]
        },
        {
            "name": "expr_range$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_range$macrocall$1$subexpression$2",
            "symbols": [
                "expr_range$macrocall$4"
            ]
        },
        {
            "name": "expr_range$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_range$macrocall$1$subexpression$3",
            "symbols": [
                "expr_range$macrocall$5"
            ]
        },
        {
            "name": "expr_range$macrocall$1$subexpression$3",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_range$macrocall$1",
            "symbols": [
                "expr_range$macrocall$1$subexpression$1",
                "expr_range$macrocall$2",
                "expr_range$macrocall$1$subexpression$2",
                "expr_range$macrocall$3",
                "expr_range$macrocall$1$subexpression$3"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'ternary',
                    value: unwrap(x[0]),
                    lo: unwrap(x[2]),
                    hi: unwrap(x[4]),
                    op: (flattenStr(x[1]).join(' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_range$macrocall$1",
            "symbols": [
                "expr_range$macrocall$5"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_range",
            "symbols": [
                "expr_range$macrocall$1"
            ]
        },
        {
            "name": "expr_others$macrocall$2$macrocall$2",
            "symbols": [
                lexerAny.has("ops_others") ? {
                    type: "ops_others"
                } : ops_others
            ]
        },
        {
            "name": "expr_others$macrocall$2$macrocall$1$macrocall$2",
            "symbols": [
                "expr_others$macrocall$2$macrocall$2"
            ]
        },
        {
            "name": "expr_others$macrocall$2$macrocall$1$macrocall$1",
            "symbols": [
                "expr_others$macrocall$2$macrocall$1$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_others$macrocall$2$macrocall$1",
            "symbols": [
                "expr_others$macrocall$2$macrocall$1$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_others$macrocall$2$macrocall$1",
            "symbols": [
                "kw_operator",
                "lparen",
                "ident",
                "dot",
                "expr_others$macrocall$2$macrocall$2",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x[4], ' ') || '<error>').toUpperCase(),
                    opSchema: toStr(x[2])
                })
        },
        {
            "name": "expr_others$macrocall$2",
            "symbols": [
                "expr_others$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_others$macrocall$3",
            "symbols": [
                "expr_others"
            ]
        },
        {
            "name": "expr_others$macrocall$4",
            "symbols": [
                "expr_like"
            ]
        },
        {
            "name": "expr_others$macrocall$1$subexpression$1",
            "symbols": [
                "expr_others$macrocall$3"
            ]
        },
        {
            "name": "expr_others$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_others$macrocall$1$subexpression$2",
            "symbols": [
                "expr_others$macrocall$4"
            ]
        },
        {
            "name": "expr_others$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_others$macrocall$1",
            "symbols": [
                "expr_others$macrocall$1$subexpression$1",
                "expr_others$macrocall$2",
                "expr_others$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_others$macrocall$1",
            "symbols": [
                "expr_others$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_others",
            "symbols": [
                "expr_others$macrocall$1"
            ]
        },
        {
            "name": "expr_like$macrocall$2$macrocall$2",
            "symbols": [
                "ops_like"
            ]
        },
        {
            "name": "expr_like$macrocall$2$macrocall$1",
            "symbols": [
                "expr_like$macrocall$2$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_like$macrocall$2",
            "symbols": [
                "expr_like$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_like$macrocall$3",
            "symbols": [
                "expr_like"
            ]
        },
        {
            "name": "expr_like$macrocall$4",
            "symbols": [
                "expr_in"
            ]
        },
        {
            "name": "expr_like$macrocall$1$subexpression$1",
            "symbols": [
                "expr_like$macrocall$3"
            ]
        },
        {
            "name": "expr_like$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_like$macrocall$1$subexpression$2",
            "symbols": [
                "expr_like$macrocall$4"
            ]
        },
        {
            "name": "expr_like$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_like$macrocall$1",
            "symbols": [
                "expr_like$macrocall$1$subexpression$1",
                "expr_like$macrocall$2",
                "expr_like$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_like$macrocall$1",
            "symbols": [
                "expr_like$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_like",
            "symbols": [
                "expr_like$macrocall$1"
            ]
        },
        {
            "name": "expr_in$macrocall$2$macrocall$2",
            "symbols": [
                "ops_in"
            ]
        },
        {
            "name": "expr_in$macrocall$2$macrocall$1",
            "symbols": [
                "expr_in$macrocall$2$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_in$macrocall$2",
            "symbols": [
                "expr_in$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_in$macrocall$3",
            "symbols": [
                "expr_in"
            ]
        },
        {
            "name": "expr_in$macrocall$4",
            "symbols": [
                "expr_add"
            ]
        },
        {
            "name": "expr_in$macrocall$1$subexpression$1",
            "symbols": [
                "expr_in$macrocall$3"
            ]
        },
        {
            "name": "expr_in$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_in$macrocall$1$subexpression$2",
            "symbols": [
                "expr_in$macrocall$4"
            ]
        },
        {
            "name": "expr_in$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_in$macrocall$1",
            "symbols": [
                "expr_in$macrocall$1$subexpression$1",
                "expr_in$macrocall$2",
                "expr_in$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_in$macrocall$1",
            "symbols": [
                "expr_in$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_in",
            "symbols": [
                "expr_in$macrocall$1"
            ]
        },
        {
            "name": "expr_add$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_plus") ? {
                    type: "op_plus"
                } : op_plus
            ]
        },
        {
            "name": "expr_add$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_minus") ? {
                    type: "op_minus"
                } : op_minus
            ]
        },
        {
            "name": "expr_add$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_additive") ? {
                    type: "op_additive"
                } : op_additive
            ]
        },
        {
            "name": "expr_add$macrocall$2$macrocall$2",
            "symbols": [
                "expr_add$macrocall$2$macrocall$2$subexpression$1"
            ]
        },
        {
            "name": "expr_add$macrocall$2$macrocall$1$macrocall$2",
            "symbols": [
                "expr_add$macrocall$2$macrocall$2"
            ]
        },
        {
            "name": "expr_add$macrocall$2$macrocall$1$macrocall$1",
            "symbols": [
                "expr_add$macrocall$2$macrocall$1$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_add$macrocall$2$macrocall$1",
            "symbols": [
                "expr_add$macrocall$2$macrocall$1$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_add$macrocall$2$macrocall$1",
            "symbols": [
                "kw_operator",
                "lparen",
                "ident",
                "dot",
                "expr_add$macrocall$2$macrocall$2",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x[4], ' ') || '<error>').toUpperCase(),
                    opSchema: toStr(x[2])
                })
        },
        {
            "name": "expr_add$macrocall$2",
            "symbols": [
                "expr_add$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_add$macrocall$3",
            "symbols": [
                "expr_add"
            ]
        },
        {
            "name": "expr_add$macrocall$4",
            "symbols": [
                "expr_mult"
            ]
        },
        {
            "name": "expr_add$macrocall$1$subexpression$1",
            "symbols": [
                "expr_add$macrocall$3"
            ]
        },
        {
            "name": "expr_add$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_add$macrocall$1$subexpression$2",
            "symbols": [
                "expr_add$macrocall$4"
            ]
        },
        {
            "name": "expr_add$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_add$macrocall$1",
            "symbols": [
                "expr_add$macrocall$1$subexpression$1",
                "expr_add$macrocall$2",
                "expr_add$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_add$macrocall$1",
            "symbols": [
                "expr_add$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_add",
            "symbols": [
                "expr_add$macrocall$1"
            ]
        },
        {
            "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("star") ? {
                    type: "star"
                } : star
            ]
        },
        {
            "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_div") ? {
                    type: "op_div"
                } : op_div
            ]
        },
        {
            "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_mod") ? {
                    type: "op_mod"
                } : op_mod
            ]
        },
        {
            "name": "expr_mult$macrocall$2$macrocall$2",
            "symbols": [
                "expr_mult$macrocall$2$macrocall$2$subexpression$1"
            ]
        },
        {
            "name": "expr_mult$macrocall$2$macrocall$1$macrocall$2",
            "symbols": [
                "expr_mult$macrocall$2$macrocall$2"
            ]
        },
        {
            "name": "expr_mult$macrocall$2$macrocall$1$macrocall$1",
            "symbols": [
                "expr_mult$macrocall$2$macrocall$1$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_mult$macrocall$2$macrocall$1",
            "symbols": [
                "expr_mult$macrocall$2$macrocall$1$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_mult$macrocall$2$macrocall$1",
            "symbols": [
                "kw_operator",
                "lparen",
                "ident",
                "dot",
                "expr_mult$macrocall$2$macrocall$2",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x[4], ' ') || '<error>').toUpperCase(),
                    opSchema: toStr(x[2])
                })
        },
        {
            "name": "expr_mult$macrocall$2",
            "symbols": [
                "expr_mult$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_mult$macrocall$3",
            "symbols": [
                "expr_mult"
            ]
        },
        {
            "name": "expr_mult$macrocall$4",
            "symbols": [
                "expr_exp"
            ]
        },
        {
            "name": "expr_mult$macrocall$1$subexpression$1",
            "symbols": [
                "expr_mult$macrocall$3"
            ]
        },
        {
            "name": "expr_mult$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_mult$macrocall$1$subexpression$2",
            "symbols": [
                "expr_mult$macrocall$4"
            ]
        },
        {
            "name": "expr_mult$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_mult$macrocall$1",
            "symbols": [
                "expr_mult$macrocall$1$subexpression$1",
                "expr_mult$macrocall$2",
                "expr_mult$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_mult$macrocall$1",
            "symbols": [
                "expr_mult$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_mult",
            "symbols": [
                "expr_mult$macrocall$1"
            ]
        },
        {
            "name": "expr_exp$macrocall$2$macrocall$2",
            "symbols": [
                lexerAny.has("op_exp") ? {
                    type: "op_exp"
                } : op_exp
            ]
        },
        {
            "name": "expr_exp$macrocall$2$macrocall$1$macrocall$2",
            "symbols": [
                "expr_exp$macrocall$2$macrocall$2"
            ]
        },
        {
            "name": "expr_exp$macrocall$2$macrocall$1$macrocall$1",
            "symbols": [
                "expr_exp$macrocall$2$macrocall$1$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_exp$macrocall$2$macrocall$1",
            "symbols": [
                "expr_exp$macrocall$2$macrocall$1$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_exp$macrocall$2$macrocall$1",
            "symbols": [
                "kw_operator",
                "lparen",
                "ident",
                "dot",
                "expr_exp$macrocall$2$macrocall$2",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x[4], ' ') || '<error>').toUpperCase(),
                    opSchema: toStr(x[2])
                })
        },
        {
            "name": "expr_exp$macrocall$2",
            "symbols": [
                "expr_exp$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_exp$macrocall$3",
            "symbols": [
                "expr_exp"
            ]
        },
        {
            "name": "expr_exp$macrocall$4",
            "symbols": [
                "expr_unary_add"
            ]
        },
        {
            "name": "expr_exp$macrocall$1$subexpression$1",
            "symbols": [
                "expr_exp$macrocall$3"
            ]
        },
        {
            "name": "expr_exp$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_exp$macrocall$1$subexpression$2",
            "symbols": [
                "expr_exp$macrocall$4"
            ]
        },
        {
            "name": "expr_exp$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_exp$macrocall$1",
            "symbols": [
                "expr_exp$macrocall$1$subexpression$1",
                "expr_exp$macrocall$2",
                "expr_exp$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_exp$macrocall$1",
            "symbols": [
                "expr_exp$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_exp",
            "symbols": [
                "expr_exp$macrocall$1"
            ]
        },
        {
            "name": "expr_unary_add$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_plus") ? {
                    type: "op_plus"
                } : op_plus
            ]
        },
        {
            "name": "expr_unary_add$macrocall$2$macrocall$2$subexpression$1",
            "symbols": [
                lexerAny.has("op_minus") ? {
                    type: "op_minus"
                } : op_minus
            ]
        },
        {
            "name": "expr_unary_add$macrocall$2$macrocall$2",
            "symbols": [
                "expr_unary_add$macrocall$2$macrocall$2$subexpression$1"
            ]
        },
        {
            "name": "expr_unary_add$macrocall$2$macrocall$1$macrocall$2",
            "symbols": [
                "expr_unary_add$macrocall$2$macrocall$2"
            ]
        },
        {
            "name": "expr_unary_add$macrocall$2$macrocall$1$macrocall$1",
            "symbols": [
                "expr_unary_add$macrocall$2$macrocall$1$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_unary_add$macrocall$2$macrocall$1",
            "symbols": [
                "expr_unary_add$macrocall$2$macrocall$1$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_unary_add$macrocall$2$macrocall$1",
            "symbols": [
                "kw_operator",
                "lparen",
                "ident",
                "dot",
                "expr_unary_add$macrocall$2$macrocall$2",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x[4], ' ') || '<error>').toUpperCase(),
                    opSchema: toStr(x[2])
                })
        },
        {
            "name": "expr_unary_add$macrocall$2",
            "symbols": [
                "expr_unary_add$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_unary_add$macrocall$3",
            "symbols": [
                "expr_unary_add"
            ]
        },
        {
            "name": "expr_unary_add$macrocall$4",
            "symbols": [
                "expr_various_constructs"
            ]
        },
        {
            "name": "expr_unary_add$macrocall$1$subexpression$1",
            "symbols": [
                "expr_unary_add$macrocall$3"
            ]
        },
        {
            "name": "expr_unary_add$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_unary_add$macrocall$1",
            "symbols": [
                "expr_unary_add$macrocall$2",
                "expr_unary_add$macrocall$1$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'unary',
                    ...unwrap(x[0]),
                    operand: unwrap(x[1])
                })
        },
        {
            "name": "expr_unary_add$macrocall$1",
            "symbols": [
                "expr_unary_add$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_unary_add",
            "symbols": [
                "expr_unary_add$macrocall$1"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$2$macrocall$2",
            "symbols": [
                "various_binaries"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$2$macrocall$1",
            "symbols": [
                "expr_various_constructs$macrocall$2$macrocall$2"
            ],
            "postprocess": (x)=>track(x, {
                    op: (toStr(x, ' ') || '<error>').toUpperCase()
                })
        },
        {
            "name": "expr_various_constructs$macrocall$2",
            "symbols": [
                "expr_various_constructs$macrocall$2$macrocall$1"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$3",
            "symbols": [
                "expr_various_constructs"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$4",
            "symbols": [
                "expr_array_index"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$1$subexpression$1",
            "symbols": [
                "expr_various_constructs$macrocall$3"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$1$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$1$subexpression$2",
            "symbols": [
                "expr_various_constructs$macrocall$4"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$1$subexpression$2",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_various_constructs$macrocall$1",
            "symbols": [
                "expr_various_constructs$macrocall$1$subexpression$1",
                "expr_various_constructs$macrocall$2",
                "expr_various_constructs$macrocall$1$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'binary',
                    left: unwrap(x[0]),
                    right: unwrap(x[2]),
                    ...unwrap(x[1])
                })
        },
        {
            "name": "expr_various_constructs$macrocall$1",
            "symbols": [
                "expr_various_constructs$macrocall$4"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_various_constructs",
            "symbols": [
                "expr_various_constructs$macrocall$1"
            ]
        },
        {
            "name": "expr_array_index$subexpression$1",
            "symbols": [
                "expr_array_index"
            ]
        },
        {
            "name": "expr_array_index$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_array_index",
            "symbols": [
                "expr_array_index$subexpression$1",
                lexerAny.has("lbracket") ? {
                    type: "lbracket"
                } : lbracket,
                "expr_nostar",
                lexerAny.has("rbracket") ? {
                    type: "rbracket"
                } : rbracket
            ],
            "postprocess": (x)=>track(x, {
                    type: 'arrayIndex',
                    array: unwrap(x[0]),
                    index: unwrap(x[2])
                })
        },
        {
            "name": "expr_array_index",
            "symbols": [
                "expr_member"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_member$subexpression$1",
            "symbols": [
                "expr_member"
            ]
        },
        {
            "name": "expr_member$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_member$subexpression$2",
            "symbols": [
                "string"
            ]
        },
        {
            "name": "expr_member$subexpression$2",
            "symbols": [
                "int"
            ]
        },
        {
            "name": "expr_member",
            "symbols": [
                "expr_member$subexpression$1",
                "ops_member",
                "expr_member$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'member',
                    operand: unwrap(x[0]),
                    op: x[1],
                    member: unwrap(x[2])
                })
        },
        {
            "name": "expr_member$subexpression$3",
            "symbols": [
                "expr_member"
            ]
        },
        {
            "name": "expr_member$subexpression$3",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "expr_member",
            "symbols": [
                "expr_member$subexpression$3",
                lexerAny.has("op_cast") ? {
                    type: "op_cast"
                } : op_cast,
                "data_type"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'cast',
                    operand: unwrap(x[0]),
                    to: x[2]
                })
        },
        {
            "name": "expr_member",
            "symbols": [
                lexerAny.has("kw_cast") ? {
                    type: "kw_cast"
                } : kw_cast,
                "lparen",
                "expr_nostar",
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "data_type",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'cast',
                    operand: unwrap(x[2]),
                    to: x[4]
                })
        },
        {
            "name": "expr_member",
            "symbols": [
                "data_type",
                "string"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'cast',
                    operand: track(x[1], {
                        type: 'string',
                        value: unbox(x[1])
                    }),
                    to: unbox(x[0])
                })
        },
        {
            "name": "expr_member",
            "symbols": [
                "expr_dot"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_dot$subexpression$1",
            "symbols": [
                "word"
            ]
        },
        {
            "name": "expr_dot$subexpression$1",
            "symbols": [
                "star"
            ]
        },
        {
            "name": "expr_dot",
            "symbols": [
                "qname",
                lexerAny.has("dot") ? {
                    type: "dot"
                } : dot,
                "expr_dot$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'ref',
                    table: unwrap(x[0]),
                    name: toStr(x[2])
                })
        },
        {
            "name": "expr_dot",
            "symbols": [
                "expr_final"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_final",
            "symbols": [
                "expr_basic"
            ]
        },
        {
            "name": "expr_final",
            "symbols": [
                "expr_primary"
            ]
        },
        {
            "name": "expr_basic",
            "symbols": [
                "expr_special_calls"
            ]
        },
        {
            "name": "expr_basic",
            "symbols": [
                "expr_call"
            ]
        },
        {
            "name": "expr_basic",
            "symbols": [
                "expr_array"
            ]
        },
        {
            "name": "expr_basic",
            "symbols": [
                "expr_case"
            ]
        },
        {
            "name": "expr_basic",
            "symbols": [
                "expr_extract"
            ]
        },
        {
            "name": "expr_basic",
            "symbols": [
                "word"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'ref',
                    name: unwrap(x[0])
                })
        },
        {
            "name": "expr_array$ebnf$1",
            "symbols": [
                "expr_subarray_items"
            ],
            "postprocess": id
        },
        {
            "name": "expr_array$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_array",
            "symbols": [
                lexerAny.has("kw_array") ? {
                    type: "kw_array"
                } : kw_array,
                lexerAny.has("lbracket") ? {
                    type: "lbracket"
                } : lbracket,
                "expr_array$ebnf$1",
                lexerAny.has("rbracket") ? {
                    type: "rbracket"
                } : rbracket
            ],
            "postprocess": (x)=>track(x, {
                    type: 'array',
                    expressions: x[2] || []
                })
        },
        {
            "name": "expr_array",
            "symbols": [
                lexerAny.has("kw_array") ? {
                    type: "kw_array"
                } : kw_array,
                "lparen",
                "selection",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'array select',
                    select: unwrap(x[2])
                })
        },
        {
            "name": "expr_subarray$ebnf$1",
            "symbols": [
                "expr_subarray_items"
            ],
            "postprocess": id
        },
        {
            "name": "expr_subarray$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_subarray",
            "symbols": [
                lexerAny.has("lbracket") ? {
                    type: "lbracket"
                } : lbracket,
                "expr_subarray$ebnf$1",
                lexerAny.has("rbracket") ? {
                    type: "rbracket"
                } : rbracket
            ],
            "postprocess": get(1)
        },
        {
            "name": "expr_subarray_items$macrocall$2",
            "symbols": [
                "expr_list_item"
            ]
        },
        {
            "name": "expr_subarray_items$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "expr_subarray_items$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "expr_subarray_items$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "expr_subarray_items$macrocall$1$ebnf$1",
            "symbols": [
                "expr_subarray_items$macrocall$1$ebnf$1",
                "expr_subarray_items$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "expr_subarray_items$macrocall$1",
            "symbols": [
                "expr_subarray_items$macrocall$2",
                "expr_subarray_items$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "expr_subarray_items",
            "symbols": [
                "expr_subarray_items$macrocall$1"
            ],
            "postprocess": (x)=>x[0].map(unwrap)
        },
        {
            "name": "expr_subarray_items$macrocall$4",
            "symbols": [
                "expr_subarray"
            ]
        },
        {
            "name": "expr_subarray_items$macrocall$3$ebnf$1",
            "symbols": []
        },
        {
            "name": "expr_subarray_items$macrocall$3$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "expr_subarray_items$macrocall$4"
            ],
            "postprocess": last
        },
        {
            "name": "expr_subarray_items$macrocall$3$ebnf$1",
            "symbols": [
                "expr_subarray_items$macrocall$3$ebnf$1",
                "expr_subarray_items$macrocall$3$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "expr_subarray_items$macrocall$3",
            "symbols": [
                "expr_subarray_items$macrocall$4",
                "expr_subarray_items$macrocall$3$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "expr_subarray_items",
            "symbols": [
                "expr_subarray_items$macrocall$3"
            ],
            "postprocess": (x)=>{
                return x[0].map((v)=>{
                    return track(v, {
                        type: 'array',
                        expressions: v[0].map(unwrap)
                    });
                });
            }
        },
        {
            "name": "expr_call$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_all") ? {
                    type: "kw_all"
                } : kw_all
            ]
        },
        {
            "name": "expr_call$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_distinct") ? {
                    type: "kw_distinct"
                } : kw_distinct
            ]
        },
        {
            "name": "expr_call$ebnf$1",
            "symbols": [
                "expr_call$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "expr_call$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_call$ebnf$2",
            "symbols": [
                "expr_list_raw"
            ],
            "postprocess": id
        },
        {
            "name": "expr_call$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_call$ebnf$3",
            "symbols": [
                "select_order_by"
            ],
            "postprocess": id
        },
        {
            "name": "expr_call$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_call$ebnf$4$subexpression$1",
            "symbols": [
                "kw_filter",
                "lparen",
                lexerAny.has("kw_where") ? {
                    type: "kw_where"
                } : kw_where,
                "expr",
                "rparen"
            ],
            "postprocess": get(3)
        },
        {
            "name": "expr_call$ebnf$4",
            "symbols": [
                "expr_call$ebnf$4$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "expr_call$ebnf$4",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_call$ebnf$5",
            "symbols": [
                "expr_call_over"
            ],
            "postprocess": id
        },
        {
            "name": "expr_call$ebnf$5",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_call",
            "symbols": [
                "expr_fn_name",
                "lparen",
                "expr_call$ebnf$1",
                "expr_call$ebnf$2",
                "expr_call$ebnf$3",
                "rparen",
                "expr_call$ebnf$4",
                "expr_call$ebnf$5"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'call',
                    function: unwrap(x[0]),
                    ...x[2] && {
                        distinct: toStr(x[2])
                    },
                    args: x[3] || [],
                    ...x[4] && {
                        orderBy: x[4]
                    },
                    ...x[6] && {
                        filter: unwrap(x[6])
                    },
                    ...x[7] && {
                        over: unwrap(x[7])
                    }
                })
        },
        {
            "name": "expr_call_over$ebnf$1$subexpression$1",
            "symbols": [
                "kw_partition",
                "kw_by",
                "expr_list_raw"
            ],
            "postprocess": last
        },
        {
            "name": "expr_call_over$ebnf$1",
            "symbols": [
                "expr_call_over$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "expr_call_over$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_call_over$ebnf$2",
            "symbols": [
                "select_order_by"
            ],
            "postprocess": id
        },
        {
            "name": "expr_call_over$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_call_over",
            "symbols": [
                "kw_over",
                "lparen",
                "expr_call_over$ebnf$1",
                "expr_call_over$ebnf$2",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    ...x[2] && {
                        partitionBy: x[2]
                    },
                    ...x[3] && {
                        orderBy: x[3]
                    }
                })
        },
        {
            "name": "expr_extract$subexpression$1",
            "symbols": [
                "word"
            ],
            "postprocess": kw('extract')
        },
        {
            "name": "expr_extract",
            "symbols": [
                "expr_extract$subexpression$1",
                "lparen",
                "word",
                lexerAny.has("kw_from") ? {
                    type: "kw_from"
                } : kw_from,
                "expr",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'extract',
                    field: asName(x[2]),
                    from: x[4]
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                "float"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'numeric',
                    value: unbox(x[0])
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                "int"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'integer',
                    value: unbox(x[0])
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                "string"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'string',
                    value: unbox(x[0])
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                lexerAny.has("kw_true") ? {
                    type: "kw_true"
                } : kw_true
            ],
            "postprocess": (x)=>track(x, {
                    type: 'boolean',
                    value: true
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                lexerAny.has("kw_false") ? {
                    type: "kw_false"
                } : kw_false
            ],
            "postprocess": (x)=>track(x, {
                    type: 'boolean',
                    value: false
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                lexerAny.has("kw_null") ? {
                    type: "kw_null"
                } : kw_null
            ],
            "postprocess": (x)=>track(x, {
                    type: 'null'
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                "value_keyword"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'keyword',
                    keyword: toStr(x)
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                lexerAny.has("qparam") ? {
                    type: "qparam"
                } : qparam
            ],
            "postprocess": (x)=>track(x, {
                    type: 'parameter',
                    name: toStr(x[0])
                })
        },
        {
            "name": "expr_primary",
            "symbols": [
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default
            ],
            "postprocess": (x)=>track(x, {
                    type: 'default'
                })
        },
        {
            "name": "ops_like",
            "symbols": [
                "ops_like_keywors"
            ]
        },
        {
            "name": "ops_like",
            "symbols": [
                "ops_like_operators"
            ]
        },
        {
            "name": "ops_like_keywors$ebnf$1",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not
            ],
            "postprocess": id
        },
        {
            "name": "ops_like_keywors$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "ops_like_keywors$subexpression$1",
            "symbols": [
                lexerAny.has("kw_like") ? {
                    type: "kw_like"
                } : kw_like
            ]
        },
        {
            "name": "ops_like_keywors$subexpression$1",
            "symbols": [
                lexerAny.has("kw_ilike") ? {
                    type: "kw_ilike"
                } : kw_ilike
            ]
        },
        {
            "name": "ops_like_keywors",
            "symbols": [
                "ops_like_keywors$ebnf$1",
                "ops_like_keywors$subexpression$1"
            ]
        },
        {
            "name": "ops_like_operators$subexpression$1",
            "symbols": [
                lexerAny.has("op_like") ? {
                    type: "op_like"
                } : op_like
            ],
            "postprocess": ()=>'LIKE'
        },
        {
            "name": "ops_like_operators",
            "symbols": [
                "ops_like_operators$subexpression$1"
            ]
        },
        {
            "name": "ops_like_operators$subexpression$2",
            "symbols": [
                lexerAny.has("op_ilike") ? {
                    type: "op_ilike"
                } : op_ilike
            ],
            "postprocess": ()=>'ILIKE'
        },
        {
            "name": "ops_like_operators",
            "symbols": [
                "ops_like_operators$subexpression$2"
            ]
        },
        {
            "name": "ops_like_operators$subexpression$3",
            "symbols": [
                lexerAny.has("op_not_like") ? {
                    type: "op_not_like"
                } : op_not_like
            ],
            "postprocess": ()=>'NOT LIKE'
        },
        {
            "name": "ops_like_operators",
            "symbols": [
                "ops_like_operators$subexpression$3"
            ]
        },
        {
            "name": "ops_like_operators$subexpression$4",
            "symbols": [
                lexerAny.has("op_not_ilike") ? {
                    type: "op_not_ilike"
                } : op_not_ilike
            ],
            "postprocess": ()=>'NOT ILIKE'
        },
        {
            "name": "ops_like_operators",
            "symbols": [
                "ops_like_operators$subexpression$4"
            ]
        },
        {
            "name": "ops_in$ebnf$1",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not
            ],
            "postprocess": id
        },
        {
            "name": "ops_in$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "ops_in",
            "symbols": [
                "ops_in$ebnf$1",
                lexerAny.has("kw_in") ? {
                    type: "kw_in"
                } : kw_in
            ]
        },
        {
            "name": "ops_between$ebnf$1",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not
            ],
            "postprocess": id
        },
        {
            "name": "ops_between$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "ops_between",
            "symbols": [
                "ops_between$ebnf$1",
                "kw_between"
            ]
        },
        {
            "name": "ops_member$subexpression$1",
            "symbols": [
                lexerAny.has("op_member") ? {
                    type: "op_member"
                } : op_member
            ]
        },
        {
            "name": "ops_member$subexpression$1",
            "symbols": [
                lexerAny.has("op_membertext") ? {
                    type: "op_membertext"
                } : op_membertext
            ]
        },
        {
            "name": "ops_member",
            "symbols": [
                "ops_member$subexpression$1"
            ],
            "postprocess": (x)=>unwrap(x)?.value
        },
        {
            "name": "expr_list_item",
            "symbols": [
                "expr_or_select"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_list_item",
            "symbols": [
                "expr_star"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_list_raw$macrocall$2",
            "symbols": [
                "expr_list_item"
            ]
        },
        {
            "name": "expr_list_raw$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "expr_list_raw$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "expr_list_raw$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "expr_list_raw$macrocall$1$ebnf$1",
            "symbols": [
                "expr_list_raw$macrocall$1$ebnf$1",
                "expr_list_raw$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "expr_list_raw$macrocall$1",
            "symbols": [
                "expr_list_raw$macrocall$2",
                "expr_list_raw$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "expr_list_raw",
            "symbols": [
                "expr_list_raw$macrocall$1"
            ],
            "postprocess": ([x])=>x.map(unwrap)
        },
        {
            "name": "expr_list_raw_many$macrocall$2",
            "symbols": [
                "expr_list_item"
            ]
        },
        {
            "name": "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "expr_list_raw_many$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "expr_list_raw_many$macrocall$1$ebnf$1",
            "symbols": [
                "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$1"
            ]
        },
        {
            "name": "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$2",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "expr_list_raw_many$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "expr_list_raw_many$macrocall$1$ebnf$1",
            "symbols": [
                "expr_list_raw_many$macrocall$1$ebnf$1",
                "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$2"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "expr_list_raw_many$macrocall$1",
            "symbols": [
                "expr_list_raw_many$macrocall$2",
                "expr_list_raw_many$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "expr_list_raw_many",
            "symbols": [
                "expr_list_raw_many$macrocall$1"
            ],
            "postprocess": ([x])=>x.map(unwrap)
        },
        {
            "name": "expr_or_select",
            "symbols": [
                "expr_nostar"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_or_select",
            "symbols": [
                "selection"
            ],
            "postprocess": unwrap
        },
        {
            "name": "expr_list_many",
            "symbols": [
                "expr_list_raw_many"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'list',
                    expressions: x[0]
                })
        },
        {
            "name": "expr_case$ebnf$1",
            "symbols": [
                "expr_nostar"
            ],
            "postprocess": id
        },
        {
            "name": "expr_case$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_case$ebnf$2",
            "symbols": []
        },
        {
            "name": "expr_case$ebnf$2",
            "symbols": [
                "expr_case$ebnf$2",
                "expr_case_whens"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "expr_case$ebnf$3",
            "symbols": [
                "expr_case_else"
            ],
            "postprocess": id
        },
        {
            "name": "expr_case$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_case",
            "symbols": [
                lexerAny.has("kw_case") ? {
                    type: "kw_case"
                } : kw_case,
                "expr_case$ebnf$1",
                "expr_case$ebnf$2",
                "expr_case$ebnf$3",
                lexerAny.has("kw_end") ? {
                    type: "kw_end"
                } : kw_end
            ],
            "postprocess": (x)=>track(x, {
                    type: 'case',
                    value: x[1],
                    whens: x[2],
                    else: x[3]
                })
        },
        {
            "name": "expr_case_whens",
            "symbols": [
                lexerAny.has("kw_when") ? {
                    type: "kw_when"
                } : kw_when,
                "expr_nostar",
                lexerAny.has("kw_then") ? {
                    type: "kw_then"
                } : kw_then,
                "expr_nostar"
            ],
            "postprocess": (x)=>track(x, {
                    when: x[1],
                    value: x[3]
                })
        },
        {
            "name": "expr_case_else",
            "symbols": [
                lexerAny.has("kw_else") ? {
                    type: "kw_else"
                } : kw_else,
                "expr_nostar"
            ],
            "postprocess": last
        },
        {
            "name": "expr_fn_name$subexpression$1$ebnf$1$subexpression$1",
            "symbols": [
                "word",
                lexerAny.has("dot") ? {
                    type: "dot"
                } : dot
            ]
        },
        {
            "name": "expr_fn_name$subexpression$1$ebnf$1",
            "symbols": [
                "expr_fn_name$subexpression$1$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "expr_fn_name$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "expr_fn_name$subexpression$1",
            "symbols": [
                "expr_fn_name$subexpression$1$ebnf$1",
                "word_or_keyword"
            ],
            "postprocess": (x)=>track(x, {
                    name: unbox(unwrap(x[1])),
                    ...x[0] && {
                        schema: toStr(x[0][0])
                    }
                })
        },
        {
            "name": "expr_fn_name",
            "symbols": [
                "expr_fn_name$subexpression$1"
            ]
        },
        {
            "name": "expr_fn_name$subexpression$2$subexpression$1",
            "symbols": [
                lexerAny.has("kw_any") ? {
                    type: "kw_any"
                } : kw_any
            ]
        },
        {
            "name": "expr_fn_name$subexpression$2$subexpression$1",
            "symbols": [
                lexerAny.has("kw_some") ? {
                    type: "kw_some"
                } : kw_some
            ]
        },
        {
            "name": "expr_fn_name$subexpression$2$subexpression$1",
            "symbols": [
                lexerAny.has("kw_all") ? {
                    type: "kw_all"
                } : kw_all
            ]
        },
        {
            "name": "expr_fn_name$subexpression$2",
            "symbols": [
                "expr_fn_name$subexpression$2$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    name: toStr(unwrap(x))
                })
        },
        {
            "name": "expr_fn_name",
            "symbols": [
                "expr_fn_name$subexpression$2"
            ]
        },
        {
            "name": "word_or_keyword",
            "symbols": [
                "word"
            ]
        },
        {
            "name": "word_or_keyword",
            "symbols": [
                "value_keyword"
            ],
            "postprocess": (x)=>box(x, toStr(x))
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_current_catalog") ? {
                    type: "kw_current_catalog"
                } : kw_current_catalog
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_current_date") ? {
                    type: "kw_current_date"
                } : kw_current_date
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_current_role") ? {
                    type: "kw_current_role"
                } : kw_current_role
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_current_schema") ? {
                    type: "kw_current_schema"
                } : kw_current_schema
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_current_timestamp") ? {
                    type: "kw_current_timestamp"
                } : kw_current_timestamp
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_current_time") ? {
                    type: "kw_current_time"
                } : kw_current_time
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_localtimestamp") ? {
                    type: "kw_localtimestamp"
                } : kw_localtimestamp
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_localtime") ? {
                    type: "kw_localtime"
                } : kw_localtime
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_session_user") ? {
                    type: "kw_session_user"
                } : kw_session_user
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_user") ? {
                    type: "kw_user"
                } : kw_user
            ]
        },
        {
            "name": "value_keyword",
            "symbols": [
                lexerAny.has("kw_current_user") ? {
                    type: "kw_current_user"
                } : kw_current_user
            ]
        },
        {
            "name": "expr_special_calls",
            "symbols": [
                "spe_overlay"
            ]
        },
        {
            "name": "expr_special_calls",
            "symbols": [
                "spe_substring"
            ]
        },
        {
            "name": "spe_overlay$subexpression$1",
            "symbols": [
                "word"
            ],
            "postprocess": kw('overlay')
        },
        {
            "name": "spe_overlay$subexpression$2",
            "symbols": [
                lexerAny.has("lparen") ? {
                    type: "lparen"
                } : lparen,
                "expr_nostar"
            ]
        },
        {
            "name": "spe_overlay$subexpression$3",
            "symbols": [
                lexerAny.has("kw_placing") ? {
                    type: "kw_placing"
                } : kw_placing,
                "expr_nostar"
            ]
        },
        {
            "name": "spe_overlay$subexpression$4",
            "symbols": [
                lexerAny.has("kw_from") ? {
                    type: "kw_from"
                } : kw_from,
                "expr_nostar"
            ]
        },
        {
            "name": "spe_overlay$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_for") ? {
                    type: "kw_for"
                } : kw_for,
                "expr_nostar"
            ]
        },
        {
            "name": "spe_overlay$ebnf$1",
            "symbols": [
                "spe_overlay$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "spe_overlay$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "spe_overlay",
            "symbols": [
                "spe_overlay$subexpression$1",
                "spe_overlay$subexpression$2",
                "spe_overlay$subexpression$3",
                "spe_overlay$subexpression$4",
                "spe_overlay$ebnf$1",
                lexerAny.has("rparen") ? {
                    type: "rparen"
                } : rparen
            ],
            "postprocess": (x)=>track(x, {
                    type: 'overlay',
                    value: x[1][1],
                    placing: x[2][1],
                    from: x[3][1],
                    ...x[4] && {
                        for: x[4][1]
                    }
                })
        },
        {
            "name": "spe_substring$subexpression$1",
            "symbols": [
                "word"
            ],
            "postprocess": kw('substring')
        },
        {
            "name": "spe_substring$subexpression$2",
            "symbols": [
                lexerAny.has("lparen") ? {
                    type: "lparen"
                } : lparen,
                "expr_nostar"
            ]
        },
        {
            "name": "spe_substring$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_from") ? {
                    type: "kw_from"
                } : kw_from,
                "expr_nostar"
            ]
        },
        {
            "name": "spe_substring$ebnf$1",
            "symbols": [
                "spe_substring$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "spe_substring$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "spe_substring$ebnf$2$subexpression$1",
            "symbols": [
                lexerAny.has("kw_for") ? {
                    type: "kw_for"
                } : kw_for,
                "expr_nostar"
            ]
        },
        {
            "name": "spe_substring$ebnf$2",
            "symbols": [
                "spe_substring$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "spe_substring$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "spe_substring",
            "symbols": [
                "spe_substring$subexpression$1",
                "spe_substring$subexpression$2",
                "spe_substring$ebnf$1",
                "spe_substring$ebnf$2",
                lexerAny.has("rparen") ? {
                    type: "rparen"
                } : rparen
            ],
            "postprocess": (x)=>track(x, {
                    type: 'substring',
                    value: x[1][1],
                    ...x[2] && {
                        from: x[2][1]
                    },
                    ...x[3] && {
                        for: x[3][1]
                    }
                })
        },
        {
            "name": "various_binaries",
            "symbols": [
                "kw_at",
                "kw_time",
                "kw_zone"
            ],
            "postprocess": ()=>'AT TIME ZONE'
        },
        {
            "name": "createtable_statement$ebnf$1",
            "symbols": [
                "createtable_modifiers"
            ],
            "postprocess": id
        },
        {
            "name": "createtable_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createtable_statement$ebnf$2",
            "symbols": [
                "kw_ifnotexists"
            ],
            "postprocess": id
        },
        {
            "name": "createtable_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createtable_statement$ebnf$3",
            "symbols": [
                "createtable_opts"
            ],
            "postprocess": id
        },
        {
            "name": "createtable_statement$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createtable_statement",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "createtable_statement$ebnf$1",
                lexerAny.has("kw_table") ? {
                    type: "kw_table"
                } : kw_table,
                "createtable_statement$ebnf$2",
                "qname",
                "lparen",
                "createtable_declarationlist",
                "rparen",
                "createtable_statement$ebnf$3"
            ],
            "postprocess": (x)=>{
                const cols = x[6].filter((v)=>'kind' in v);
                const constraints = x[6].filter((v)=>!('kind' in v));
                return track(x, {
                    type: 'create table',
                    ...!!x[3] ? {
                        ifNotExists: true
                    } : {},
                    name: x[4],
                    columns: cols,
                    ...unwrap(x[1]),
                    ...constraints.length ? {
                        constraints
                    } : {},
                    ...last(x)
                });
            }
        },
        {
            "name": "createtable_modifiers",
            "symbols": [
                "kw_unlogged"
            ],
            "postprocess": (x)=>x[0] ? {
                    unlogged: true
                } : {}
        },
        {
            "name": "createtable_modifiers",
            "symbols": [
                "m_locglob"
            ]
        },
        {
            "name": "createtable_modifiers",
            "symbols": [
                "m_tmp"
            ]
        },
        {
            "name": "createtable_modifiers",
            "symbols": [
                "m_locglob",
                "m_tmp"
            ],
            "postprocess": ([a, b4])=>({
                    ...a,
                    ...b4
                })
        },
        {
            "name": "m_locglob$subexpression$1",
            "symbols": [
                "kw_local"
            ]
        },
        {
            "name": "m_locglob$subexpression$1",
            "symbols": [
                "kw_global"
            ]
        },
        {
            "name": "m_locglob",
            "symbols": [
                "m_locglob$subexpression$1"
            ],
            "postprocess": (x)=>({
                    locality: toStr(x)
                })
        },
        {
            "name": "m_tmp$subexpression$1",
            "symbols": [
                "kw_temp"
            ]
        },
        {
            "name": "m_tmp$subexpression$1",
            "symbols": [
                "kw_temporary"
            ]
        },
        {
            "name": "m_tmp",
            "symbols": [
                "m_tmp$subexpression$1"
            ],
            "postprocess": (x)=>({
                    temporary: true
                })
        },
        {
            "name": "createtable_declarationlist$ebnf$1",
            "symbols": []
        },
        {
            "name": "createtable_declarationlist$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "createtable_declaration"
            ],
            "postprocess": last
        },
        {
            "name": "createtable_declarationlist$ebnf$1",
            "symbols": [
                "createtable_declarationlist$ebnf$1",
                "createtable_declarationlist$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createtable_declarationlist",
            "symbols": [
                "createtable_declaration",
                "createtable_declarationlist$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "createtable_declaration$subexpression$1",
            "symbols": [
                "createtable_constraint"
            ]
        },
        {
            "name": "createtable_declaration$subexpression$1",
            "symbols": [
                "createtable_column"
            ]
        },
        {
            "name": "createtable_declaration$subexpression$1",
            "symbols": [
                "createtable_like"
            ]
        },
        {
            "name": "createtable_declaration",
            "symbols": [
                "createtable_declaration$subexpression$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "createtable_constraint$macrocall$2",
            "symbols": [
                "createtable_constraint_def"
            ]
        },
        {
            "name": "createtable_constraint$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_constraint") ? {
                    type: "kw_constraint"
                } : kw_constraint,
                "word"
            ]
        },
        {
            "name": "createtable_constraint$macrocall$1$ebnf$1",
            "symbols": [
                "createtable_constraint$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createtable_constraint$macrocall$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createtable_constraint$macrocall$1",
            "symbols": [
                "createtable_constraint$macrocall$1$ebnf$1",
                "createtable_constraint$macrocall$2"
            ],
            "postprocess": (x)=>{
                const name6 = x[0] && asName(x[0][1]);
                if (!name6) {
                    return track(x, unwrap(x[1]));
                }
                return track(x, {
                    constraintName: name6,
                    ...unwrap(x[1])
                });
            }
        },
        {
            "name": "createtable_constraint",
            "symbols": [
                "createtable_constraint$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "createtable_constraint_def",
            "symbols": [
                "createtable_constraint_def_unique"
            ]
        },
        {
            "name": "createtable_constraint_def",
            "symbols": [
                "createtable_constraint_def_check"
            ]
        },
        {
            "name": "createtable_constraint_def",
            "symbols": [
                "createtable_constraint_foreignkey"
            ]
        },
        {
            "name": "createtable_constraint_def_unique$subexpression$1",
            "symbols": [
                lexerAny.has("kw_unique") ? {
                    type: "kw_unique"
                } : kw_unique
            ]
        },
        {
            "name": "createtable_constraint_def_unique$subexpression$1",
            "symbols": [
                "kw_primary_key"
            ]
        },
        {
            "name": "createtable_constraint_def_unique",
            "symbols": [
                "createtable_constraint_def_unique$subexpression$1",
                "lparen",
                "createtable_collist",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    type: toStr(x[0], ' '),
                    columns: x[2].map(asName)
                })
        },
        {
            "name": "createtable_constraint_def_check",
            "symbols": [
                lexerAny.has("kw_check") ? {
                    type: "kw_check"
                } : kw_check,
                "expr_paren"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'check',
                    expr: unwrap(x[1])
                })
        },
        {
            "name": "createtable_constraint_foreignkey$ebnf$1",
            "symbols": []
        },
        {
            "name": "createtable_constraint_foreignkey$ebnf$1",
            "symbols": [
                "createtable_constraint_foreignkey$ebnf$1",
                "createtable_constraint_foreignkey_onsometing"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createtable_constraint_foreignkey",
            "symbols": [
                lexerAny.has("kw_foreign") ? {
                    type: "kw_foreign"
                } : kw_foreign,
                "kw_key",
                "collist_paren",
                lexerAny.has("kw_references") ? {
                    type: "kw_references"
                } : kw_references,
                "qualified_name",
                "collist_paren",
                "createtable_constraint_foreignkey$ebnf$1"
            ],
            "postprocess": (x)=>{
                return track(x, {
                    type: 'foreign key',
                    localColumns: x[2].map(asName),
                    foreignTable: unwrap(x[4]),
                    foreignColumns: x[5].map(asName),
                    ...x[6].reduce((a, b5)=>({
                            ...a,
                            ...b5
                        }), {})
                });
            }
        },
        {
            "name": "createtable_constraint_foreignkey_onsometing",
            "symbols": [
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on,
                "kw_delete",
                "createtable_constraint_on_action"
            ],
            "postprocess": (x)=>track(x, {
                    onDelete: last(x)
                })
        },
        {
            "name": "createtable_constraint_foreignkey_onsometing",
            "symbols": [
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on,
                "kw_update",
                "createtable_constraint_on_action"
            ],
            "postprocess": (x)=>track(x, {
                    onUpdate: last(x)
                })
        },
        {
            "name": "createtable_constraint_foreignkey_onsometing$subexpression$1",
            "symbols": [
                lexerAny.has("kw_full") ? {
                    type: "kw_full"
                } : kw_full
            ]
        },
        {
            "name": "createtable_constraint_foreignkey_onsometing$subexpression$1",
            "symbols": [
                "kw_partial"
            ]
        },
        {
            "name": "createtable_constraint_foreignkey_onsometing$subexpression$1",
            "symbols": [
                "kw_simple"
            ]
        },
        {
            "name": "createtable_constraint_foreignkey_onsometing",
            "symbols": [
                "kw_match",
                "createtable_constraint_foreignkey_onsometing$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    match: toStr(last(x))
                })
        },
        {
            "name": "createtable_constraint_on_action$subexpression$1",
            "symbols": [
                "kw_cascade"
            ]
        },
        {
            "name": "createtable_constraint_on_action$subexpression$1$subexpression$1",
            "symbols": [
                "kw_no",
                "kw_action"
            ]
        },
        {
            "name": "createtable_constraint_on_action$subexpression$1",
            "symbols": [
                "createtable_constraint_on_action$subexpression$1$subexpression$1"
            ]
        },
        {
            "name": "createtable_constraint_on_action$subexpression$1",
            "symbols": [
                "kw_restrict"
            ]
        },
        {
            "name": "createtable_constraint_on_action$subexpression$1$subexpression$2",
            "symbols": [
                lexerAny.has("kw_null") ? {
                    type: "kw_null"
                } : kw_null
            ]
        },
        {
            "name": "createtable_constraint_on_action$subexpression$1$subexpression$2",
            "symbols": [
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default
            ]
        },
        {
            "name": "createtable_constraint_on_action$subexpression$1",
            "symbols": [
                "kw_set",
                "createtable_constraint_on_action$subexpression$1$subexpression$2"
            ]
        },
        {
            "name": "createtable_constraint_on_action",
            "symbols": [
                "createtable_constraint_on_action$subexpression$1"
            ],
            "postprocess": (x)=>toStr(x, ' ')
        },
        {
            "name": "createtable_collist$ebnf$1",
            "symbols": []
        },
        {
            "name": "createtable_collist$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "ident"
            ],
            "postprocess": last
        },
        {
            "name": "createtable_collist$ebnf$1",
            "symbols": [
                "createtable_collist$ebnf$1",
                "createtable_collist$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createtable_collist",
            "symbols": [
                "ident",
                "createtable_collist$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "createtable_column$ebnf$1",
            "symbols": [
                "createtable_collate"
            ],
            "postprocess": id
        },
        {
            "name": "createtable_column$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createtable_column$ebnf$2",
            "symbols": []
        },
        {
            "name": "createtable_column$ebnf$2",
            "symbols": [
                "createtable_column$ebnf$2",
                "createtable_column_constraint"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createtable_column",
            "symbols": [
                "word",
                "data_type",
                "createtable_column$ebnf$1",
                "createtable_column$ebnf$2"
            ],
            "postprocess": (x)=>{
                return track(x, {
                    kind: 'column',
                    name: asName(x[0]),
                    dataType: x[1],
                    ...x[2] ? {
                        collate: x[2][1]
                    } : {},
                    ...x[3] && x[3].length ? {
                        constraints: x[3]
                    } : {}
                });
            }
        },
        {
            "name": "createtable_like$ebnf$1",
            "symbols": []
        },
        {
            "name": "createtable_like$ebnf$1",
            "symbols": [
                "createtable_like$ebnf$1",
                "createtable_like_opt"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createtable_like",
            "symbols": [
                lexerAny.has("kw_like") ? {
                    type: "kw_like"
                } : kw_like,
                "qname",
                "createtable_like$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    kind: 'like table',
                    like: x[1],
                    options: x[2]
                })
        },
        {
            "name": "createtable_like_opt$subexpression$1",
            "symbols": [
                "kw_including"
            ]
        },
        {
            "name": "createtable_like_opt$subexpression$1",
            "symbols": [
                "kw_excluding"
            ]
        },
        {
            "name": "createtable_like_opt",
            "symbols": [
                "createtable_like_opt$subexpression$1",
                "createtable_like_opt_val"
            ],
            "postprocess": (x)=>track(x, {
                    verb: toStr(x[0]),
                    option: toStr(x[1])
                })
        },
        {
            "name": "createtable_like_opt_val",
            "symbols": [
                "word"
            ],
            "postprocess": anyKw('defaults', 'constraints', 'indexes', 'storage', 'comments')
        },
        {
            "name": "createtable_like_opt_val",
            "symbols": [
                lexerAny.has("kw_all") ? {
                    type: "kw_all"
                } : kw_all
            ]
        },
        {
            "name": "createtable_column_constraint$macrocall$2",
            "symbols": [
                "createtable_column_constraint_def"
            ]
        },
        {
            "name": "createtable_column_constraint$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_constraint") ? {
                    type: "kw_constraint"
                } : kw_constraint,
                "word"
            ]
        },
        {
            "name": "createtable_column_constraint$macrocall$1$ebnf$1",
            "symbols": [
                "createtable_column_constraint$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createtable_column_constraint$macrocall$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createtable_column_constraint$macrocall$1",
            "symbols": [
                "createtable_column_constraint$macrocall$1$ebnf$1",
                "createtable_column_constraint$macrocall$2"
            ],
            "postprocess": (x)=>{
                const name7 = x[0] && asName(x[0][1]);
                if (!name7) {
                    return track(x, unwrap(x[1]));
                }
                return track(x, {
                    constraintName: name7,
                    ...unwrap(x[1])
                });
            }
        },
        {
            "name": "createtable_column_constraint",
            "symbols": [
                "createtable_column_constraint$macrocall$1"
            ],
            "postprocess": unwrap
        },
        {
            "name": "createtable_column_constraint_def",
            "symbols": [
                lexerAny.has("kw_unique") ? {
                    type: "kw_unique"
                } : kw_unique
            ],
            "postprocess": (x)=>track(x, {
                    type: 'unique'
                })
        },
        {
            "name": "createtable_column_constraint_def",
            "symbols": [
                "kw_primary_key"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'primary key'
                })
        },
        {
            "name": "createtable_column_constraint_def",
            "symbols": [
                "kw_not_null"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'not null'
                })
        },
        {
            "name": "createtable_column_constraint_def",
            "symbols": [
                lexerAny.has("kw_null") ? {
                    type: "kw_null"
                } : kw_null
            ],
            "postprocess": (x)=>track(x, {
                    type: 'null'
                })
        },
        {
            "name": "createtable_column_constraint_def",
            "symbols": [
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default,
                "expr"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'default',
                    default: unwrap(x[1])
                })
        },
        {
            "name": "createtable_column_constraint_def",
            "symbols": [
                lexerAny.has("kw_check") ? {
                    type: "kw_check"
                } : kw_check,
                "expr_paren"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'check',
                    expr: unwrap(x[1])
                })
        },
        {
            "name": "createtable_column_constraint_def",
            "symbols": [
                "altercol_generated"
            ]
        },
        {
            "name": "createtable_collate",
            "symbols": [
                lexerAny.has("kw_collate") ? {
                    type: "kw_collate"
                } : kw_collate,
                "qualified_name"
            ]
        },
        {
            "name": "createtable_opts$subexpression$1",
            "symbols": [
                "word"
            ],
            "postprocess": kw('inherits')
        },
        {
            "name": "createtable_opts$macrocall$2",
            "symbols": [
                "qname"
            ]
        },
        {
            "name": "createtable_opts$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "createtable_opts$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "createtable_opts$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "createtable_opts$macrocall$1$ebnf$1",
            "symbols": [
                "createtable_opts$macrocall$1$ebnf$1",
                "createtable_opts$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createtable_opts$macrocall$1",
            "symbols": [
                "createtable_opts$macrocall$2",
                "createtable_opts$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "createtable_opts",
            "symbols": [
                "createtable_opts$subexpression$1",
                "lparen",
                "createtable_opts$macrocall$1",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    inherits: x[2]
                })
        },
        {
            "name": "createindex_statement$ebnf$1",
            "symbols": [
                lexerAny.has("kw_unique") ? {
                    type: "kw_unique"
                } : kw_unique
            ],
            "postprocess": id
        },
        {
            "name": "createindex_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_statement$ebnf$2",
            "symbols": [
                "kw_ifnotexists"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_statement$ebnf$3",
            "symbols": [
                "word"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_statement$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_statement$ebnf$4$subexpression$1",
            "symbols": [
                lexerAny.has("kw_using") ? {
                    type: "kw_using"
                } : kw_using,
                "ident"
            ],
            "postprocess": last
        },
        {
            "name": "createindex_statement$ebnf$4",
            "symbols": [
                "createindex_statement$ebnf$4$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_statement$ebnf$4",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_statement$ebnf$5",
            "symbols": [
                "createindex_with"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_statement$ebnf$5",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_statement$ebnf$6",
            "symbols": [
                "createindex_tblspace"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_statement$ebnf$6",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_statement$ebnf$7",
            "symbols": [
                "createindex_predicate"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_statement$ebnf$7",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_statement",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "createindex_statement$ebnf$1",
                "kw_index",
                "createindex_statement$ebnf$2",
                "createindex_statement$ebnf$3",
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on,
                "table_ref",
                "createindex_statement$ebnf$4",
                "lparen",
                "createindex_expressions",
                "rparen",
                "createindex_statement$ebnf$5",
                "createindex_statement$ebnf$6",
                "createindex_statement$ebnf$7"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'create index',
                    ...x[1] && {
                        unique: true
                    },
                    ...x[3] && {
                        ifNotExists: true
                    },
                    ...x[4] && {
                        indexName: asName(x[4])
                    },
                    table: x[6],
                    ...x[7] && {
                        using: asName(x[7])
                    },
                    expressions: x[9],
                    ...x[11] && {
                        with: x[11]
                    },
                    ...x[12] && {
                        tablespace: unwrap(x[12])
                    },
                    ...x[13] && {
                        where: unwrap(x[13])
                    }
                })
        },
        {
            "name": "createindex_expressions$ebnf$1",
            "symbols": []
        },
        {
            "name": "createindex_expressions$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "createindex_expression"
            ],
            "postprocess": last
        },
        {
            "name": "createindex_expressions$ebnf$1",
            "symbols": [
                "createindex_expressions$ebnf$1",
                "createindex_expressions$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createindex_expressions",
            "symbols": [
                "createindex_expression",
                "createindex_expressions$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "createindex_expression$subexpression$1",
            "symbols": [
                "expr_basic"
            ]
        },
        {
            "name": "createindex_expression$subexpression$1",
            "symbols": [
                "expr_paren"
            ]
        },
        {
            "name": "createindex_expression$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_collate") ? {
                    type: "kw_collate"
                } : kw_collate,
                "qualified_name"
            ],
            "postprocess": last
        },
        {
            "name": "createindex_expression$ebnf$1",
            "symbols": [
                "createindex_expression$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_expression$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_expression$ebnf$2",
            "symbols": [
                "qualified_name"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_expression$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_expression$ebnf$3$subexpression$1",
            "symbols": [
                lexerAny.has("kw_asc") ? {
                    type: "kw_asc"
                } : kw_asc
            ]
        },
        {
            "name": "createindex_expression$ebnf$3$subexpression$1",
            "symbols": [
                lexerAny.has("kw_desc") ? {
                    type: "kw_desc"
                } : kw_desc
            ]
        },
        {
            "name": "createindex_expression$ebnf$3",
            "symbols": [
                "createindex_expression$ebnf$3$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_expression$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_expression$ebnf$4$subexpression$1$subexpression$1",
            "symbols": [
                "kw_first"
            ]
        },
        {
            "name": "createindex_expression$ebnf$4$subexpression$1$subexpression$1",
            "symbols": [
                "kw_last"
            ]
        },
        {
            "name": "createindex_expression$ebnf$4$subexpression$1",
            "symbols": [
                "kw_nulls",
                "createindex_expression$ebnf$4$subexpression$1$subexpression$1"
            ],
            "postprocess": last
        },
        {
            "name": "createindex_expression$ebnf$4",
            "symbols": [
                "createindex_expression$ebnf$4$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createindex_expression$ebnf$4",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createindex_expression",
            "symbols": [
                "createindex_expression$subexpression$1",
                "createindex_expression$ebnf$1",
                "createindex_expression$ebnf$2",
                "createindex_expression$ebnf$3",
                "createindex_expression$ebnf$4"
            ],
            "postprocess": (x)=>track(x, {
                    expression: unwrap(x[0]),
                    ...x[1] && {
                        collate: unwrap(x[1])
                    },
                    ...x[2] && {
                        opclass: unwrap(x[2])
                    },
                    ...x[3] && {
                        order: unwrap(x[3]).value
                    },
                    ...x[4] && {
                        nulls: unwrap(x[4])
                    }
                })
        },
        {
            "name": "createindex_predicate",
            "symbols": [
                lexerAny.has("kw_where") ? {
                    type: "kw_where"
                } : kw_where,
                "expr"
            ],
            "postprocess": last
        },
        {
            "name": "createindex_with$macrocall$2",
            "symbols": [
                "createindex_with_item"
            ]
        },
        {
            "name": "createindex_with$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "createindex_with$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "createindex_with$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "createindex_with$macrocall$1$ebnf$1",
            "symbols": [
                "createindex_with$macrocall$1$ebnf$1",
                "createindex_with$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createindex_with$macrocall$1",
            "symbols": [
                "createindex_with$macrocall$2",
                "createindex_with$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "createindex_with",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with,
                "lparen",
                "createindex_with$macrocall$1",
                "rparen"
            ],
            "postprocess": get(2)
        },
        {
            "name": "createindex_with_item$subexpression$1",
            "symbols": [
                "string"
            ]
        },
        {
            "name": "createindex_with_item$subexpression$1",
            "symbols": [
                "int"
            ]
        },
        {
            "name": "createindex_with_item",
            "symbols": [
                "ident",
                lexerAny.has("op_eq") ? {
                    type: "op_eq"
                } : op_eq,
                "createindex_with_item$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    parameter: toStr(x[0]),
                    value: unwrap(x[2]).toString()
                })
        },
        {
            "name": "createindex_tblspace",
            "symbols": [
                "kw_tablespace",
                "ident"
            ],
            "postprocess": last
        },
        {
            "name": "createextension_statement$ebnf$1",
            "symbols": [
                "kw_ifnotexists"
            ],
            "postprocess": id
        },
        {
            "name": "createextension_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createextension_statement$ebnf$2",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with
            ],
            "postprocess": id
        },
        {
            "name": "createextension_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createextension_statement$ebnf$3$subexpression$1",
            "symbols": [
                "kw_schema",
                "word"
            ],
            "postprocess": last
        },
        {
            "name": "createextension_statement$ebnf$3",
            "symbols": [
                "createextension_statement$ebnf$3$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createextension_statement$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createextension_statement$ebnf$4$subexpression$1",
            "symbols": [
                "kw_version",
                "string"
            ],
            "postprocess": last
        },
        {
            "name": "createextension_statement$ebnf$4",
            "symbols": [
                "createextension_statement$ebnf$4$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createextension_statement$ebnf$4",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createextension_statement$ebnf$5$subexpression$1",
            "symbols": [
                lexerAny.has("kw_from") ? {
                    type: "kw_from"
                } : kw_from,
                "string"
            ],
            "postprocess": last
        },
        {
            "name": "createextension_statement$ebnf$5",
            "symbols": [
                "createextension_statement$ebnf$5$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "createextension_statement$ebnf$5",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createextension_statement",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "kw_extension",
                "createextension_statement$ebnf$1",
                "word",
                "createextension_statement$ebnf$2",
                "createextension_statement$ebnf$3",
                "createextension_statement$ebnf$4",
                "createextension_statement$ebnf$5"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'create extension',
                    ...!!x[2] ? {
                        ifNotExists: true
                    } : {},
                    extension: asName(x[3]),
                    ...!!x[5] ? {
                        schema: asName(x[5])
                    } : {},
                    ...!!x[6] ? {
                        version: asLit(x[6])
                    } : {},
                    ...!!x[7] ? {
                        from: asLit(x[7])
                    } : {}
                })
        },
        {
            "name": "simplestatements_all",
            "symbols": [
                "simplestatements_start_transaction"
            ]
        },
        {
            "name": "simplestatements_all",
            "symbols": [
                "simplestatements_commit"
            ]
        },
        {
            "name": "simplestatements_all",
            "symbols": [
                "simplestatements_rollback"
            ]
        },
        {
            "name": "simplestatements_all",
            "symbols": [
                "simplestatements_tablespace"
            ]
        },
        {
            "name": "simplestatements_all",
            "symbols": [
                "simplestatements_set"
            ]
        },
        {
            "name": "simplestatements_all",
            "symbols": [
                "simplestatements_show"
            ]
        },
        {
            "name": "simplestatements_all",
            "symbols": [
                "simplestatements_begin"
            ]
        },
        {
            "name": "simplestatements_start_transaction$subexpression$1",
            "symbols": [
                "kw_start",
                "kw_transaction"
            ]
        },
        {
            "name": "simplestatements_start_transaction",
            "symbols": [
                "simplestatements_start_transaction$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'start transaction'
                })
        },
        {
            "name": "simplestatements_commit",
            "symbols": [
                "kw_commit"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'commit'
                })
        },
        {
            "name": "simplestatements_rollback",
            "symbols": [
                "kw_rollback"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'rollback'
                })
        },
        {
            "name": "simplestatements_tablespace",
            "symbols": [
                "kw_tablespace",
                "word"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'tablespace',
                    tablespace: asName(x[1])
                })
        },
        {
            "name": "simplestatements_set$subexpression$1",
            "symbols": [
                "simplestatements_set_simple"
            ]
        },
        {
            "name": "simplestatements_set$subexpression$1",
            "symbols": [
                "simplestatements_set_timezone"
            ]
        },
        {
            "name": "simplestatements_set",
            "symbols": [
                "kw_set",
                "simplestatements_set$subexpression$1"
            ],
            "postprocess": last
        },
        {
            "name": "simplestatements_set_timezone",
            "symbols": [
                "kw_time",
                "kw_zone",
                "simplestatements_set_timezone_val"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'set timezone',
                    to: x[2]
                })
        },
        {
            "name": "simplestatements_set_timezone_val$subexpression$1",
            "symbols": [
                "string"
            ]
        },
        {
            "name": "simplestatements_set_timezone_val$subexpression$1",
            "symbols": [
                "int"
            ]
        },
        {
            "name": "simplestatements_set_timezone_val",
            "symbols": [
                "simplestatements_set_timezone_val$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'value',
                    value: unwrap(x[0])
                })
        },
        {
            "name": "simplestatements_set_timezone_val",
            "symbols": [
                "kw_local"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'local'
                })
        },
        {
            "name": "simplestatements_set_timezone_val",
            "symbols": [
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default
            ],
            "postprocess": (x)=>track(x, {
                    type: 'default'
                })
        },
        {
            "name": "simplestatements_set_timezone_val",
            "symbols": [
                "kw_interval",
                "string",
                "kw_hour",
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to,
                "kw_minute"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'interval',
                    value: unbox(x[1])
                })
        },
        {
            "name": "simplestatements_set_simple$subexpression$1",
            "symbols": [
                lexerAny.has("op_eq") ? {
                    type: "op_eq"
                } : op_eq
            ]
        },
        {
            "name": "simplestatements_set_simple$subexpression$1",
            "symbols": [
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to
            ]
        },
        {
            "name": "simplestatements_set_simple",
            "symbols": [
                "ident",
                "simplestatements_set_simple$subexpression$1",
                "simplestatements_set_val"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'set',
                    variable: asName(x[0]),
                    set: unbox(x[2])
                })
        },
        {
            "name": "simplestatements_set_val",
            "symbols": [
                "simplestatements_set_val_raw"
            ],
            "postprocess": unwrap
        },
        {
            "name": "simplestatements_set_val",
            "symbols": [
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default
            ],
            "postprocess": (x)=>track(x, {
                    type: 'default'
                })
        },
        {
            "name": "simplestatements_set_val$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "simplestatements_set_val_raw"
            ]
        },
        {
            "name": "simplestatements_set_val$ebnf$1",
            "symbols": [
                "simplestatements_set_val$ebnf$1$subexpression$1"
            ]
        },
        {
            "name": "simplestatements_set_val$ebnf$1$subexpression$2",
            "symbols": [
                "comma",
                "simplestatements_set_val_raw"
            ]
        },
        {
            "name": "simplestatements_set_val$ebnf$1",
            "symbols": [
                "simplestatements_set_val$ebnf$1",
                "simplestatements_set_val$ebnf$1$subexpression$2"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "simplestatements_set_val",
            "symbols": [
                "simplestatements_set_val_raw",
                "simplestatements_set_val$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'list',
                    values: [
                        x[0],
                        ...x[1] || []
                    ]
                })
        },
        {
            "name": "simplestatements_set_val_raw$subexpression$1",
            "symbols": [
                "string"
            ]
        },
        {
            "name": "simplestatements_set_val_raw$subexpression$1",
            "symbols": [
                "int"
            ]
        },
        {
            "name": "simplestatements_set_val_raw",
            "symbols": [
                "simplestatements_set_val_raw$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'value',
                    value: unwrap(x)
                })
        },
        {
            "name": "simplestatements_set_val_raw$subexpression$2",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ]
        },
        {
            "name": "simplestatements_set_val_raw$subexpression$2",
            "symbols": [
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on
            ]
        },
        {
            "name": "simplestatements_set_val_raw$subexpression$2",
            "symbols": [
                lexerAny.has("kw_true") ? {
                    type: "kw_true"
                } : kw_true
            ]
        },
        {
            "name": "simplestatements_set_val_raw$subexpression$2",
            "symbols": [
                lexerAny.has("kw_false") ? {
                    type: "kw_false"
                } : kw_false
            ]
        },
        {
            "name": "simplestatements_set_val_raw",
            "symbols": [
                "simplestatements_set_val_raw$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'identifier',
                    name: unwrap(x).value
                })
        },
        {
            "name": "simplestatements_show",
            "symbols": [
                "kw_show",
                "ident"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'show',
                    variable: asName(x[1])
                })
        },
        {
            "name": "create_schema$subexpression$1",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "kw_schema"
            ]
        },
        {
            "name": "create_schema$ebnf$1",
            "symbols": [
                "kw_ifnotexists"
            ],
            "postprocess": id
        },
        {
            "name": "create_schema$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_schema",
            "symbols": [
                "create_schema$subexpression$1",
                "create_schema$ebnf$1",
                "ident"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'create schema',
                    name: asName(x[2]),
                    ...!!x[1] ? {
                        ifNotExists: true
                    } : {}
                })
        },
        {
            "name": "raise_statement$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": anyKw('debug', 'log', 'info', 'notice', 'warning', 'exception')
        },
        {
            "name": "raise_statement$ebnf$1",
            "symbols": [
                "raise_statement$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "raise_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "raise_statement$ebnf$2$subexpression$1",
            "symbols": [
                "comma",
                "expr_list_raw"
            ],
            "postprocess": last
        },
        {
            "name": "raise_statement$ebnf$2",
            "symbols": [
                "raise_statement$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "raise_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "raise_statement$ebnf$3",
            "symbols": [
                "raise_using"
            ],
            "postprocess": id
        },
        {
            "name": "raise_statement$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "raise_statement",
            "symbols": [
                "kw_raise",
                "raise_statement$ebnf$1",
                "string",
                "raise_statement$ebnf$2",
                "raise_statement$ebnf$3"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'raise',
                    format: toStr(x[2]),
                    ...x[1] && {
                        level: toStr(x[1])
                    },
                    ...x[3] && x[3].length && {
                        formatExprs: x[3]
                    },
                    ...x[4] && x[4].length && {
                        using: x[4]
                    }
                })
        },
        {
            "name": "raise_using$macrocall$2",
            "symbols": [
                "raise_using_one"
            ]
        },
        {
            "name": "raise_using$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "raise_using$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "raise_using$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "raise_using$macrocall$1$ebnf$1",
            "symbols": [
                "raise_using$macrocall$1$ebnf$1",
                "raise_using$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "raise_using$macrocall$1",
            "symbols": [
                "raise_using$macrocall$2",
                "raise_using$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "raise_using",
            "symbols": [
                lexerAny.has("kw_using") ? {
                    type: "kw_using"
                } : kw_using,
                "raise_using$macrocall$1"
            ],
            "postprocess": last
        },
        {
            "name": "raise_using_one",
            "symbols": [
                "raise_using_what",
                lexerAny.has("op_eq") ? {
                    type: "op_eq"
                } : op_eq,
                "expr"
            ],
            "postprocess": (x)=>track(x, {
                    type: toStr(x[0]),
                    value: x[2]
                })
        },
        {
            "name": "raise_using_what",
            "symbols": [
                lexerAny.has("kw_table") ? {
                    type: "kw_table"
                } : kw_table
            ]
        },
        {
            "name": "raise_using_what",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": anyKw('message', 'detail', 'hint', 'errcode', 'column', 'constraint', 'datatype', 'schema')
        },
        {
            "name": "comment_statement",
            "symbols": [
                "kw_comment",
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on,
                "comment_what",
                lexerAny.has("kw_is") ? {
                    type: "kw_is"
                } : kw_is,
                "string"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'comment',
                    comment: unbox(last(x)),
                    on: unwrap(x[2])
                })
        },
        {
            "name": "comment_what",
            "symbols": [
                "comment_what_col"
            ]
        },
        {
            "name": "comment_what",
            "symbols": [
                "comment_what_nm"
            ]
        },
        {
            "name": "comment_what_nm$subexpression$1",
            "symbols": [
                lexerAny.has("kw_table") ? {
                    type: "kw_table"
                } : kw_table
            ]
        },
        {
            "name": "comment_what_nm$subexpression$1",
            "symbols": [
                "kw_materialized",
                "kw_view"
            ]
        },
        {
            "name": "comment_what_nm$subexpression$1",
            "symbols": [
                lexerAny.has("word") ? {
                    type: "word"
                } : word
            ],
            "postprocess": anyKw('database', 'index', 'trigger', 'type', 'view')
        },
        {
            "name": "comment_what_nm",
            "symbols": [
                "comment_what_nm$subexpression$1",
                "qualified_name"
            ],
            "postprocess": (x)=>track(x, {
                    type: toStr(x[0]),
                    name: x[1]
                })
        },
        {
            "name": "comment_what_col",
            "symbols": [
                "kw_column",
                "qcolumn"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'column',
                    column: last(x)
                })
        },
        {
            "name": "simplestatements_begin$ebnf$1$subexpression$1",
            "symbols": [
                "kw_transaction"
            ]
        },
        {
            "name": "simplestatements_begin$ebnf$1$subexpression$1",
            "symbols": [
                "kw_work"
            ]
        },
        {
            "name": "simplestatements_begin$ebnf$1",
            "symbols": [
                "simplestatements_begin$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "simplestatements_begin$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "simplestatements_begin$ebnf$2",
            "symbols": []
        },
        {
            "name": "simplestatements_begin$ebnf$2$subexpression$1",
            "symbols": [
                "simplestatements_begin_isol"
            ]
        },
        {
            "name": "simplestatements_begin$ebnf$2$subexpression$1",
            "symbols": [
                "simplestatements_begin_writ"
            ]
        },
        {
            "name": "simplestatements_begin$ebnf$2$subexpression$1",
            "symbols": [
                "simplestatements_begin_def"
            ]
        },
        {
            "name": "simplestatements_begin$ebnf$2",
            "symbols": [
                "simplestatements_begin$ebnf$2",
                "simplestatements_begin$ebnf$2$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "simplestatements_begin",
            "symbols": [
                "kw_begin",
                "simplestatements_begin$ebnf$1",
                "simplestatements_begin$ebnf$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'begin',
                    ...x[2].reduce((a, b6)=>({
                            ...unwrap(a),
                            ...unwrap(b6)
                        }), {})
                })
        },
        {
            "name": "simplestatements_begin_isol$subexpression$1",
            "symbols": [
                "kw_isolation",
                "kw_level"
            ]
        },
        {
            "name": "simplestatements_begin_isol$subexpression$2",
            "symbols": [
                "kw_serializable"
            ]
        },
        {
            "name": "simplestatements_begin_isol$subexpression$2$subexpression$1",
            "symbols": [
                "word"
            ],
            "postprocess": kw('repeatable')
        },
        {
            "name": "simplestatements_begin_isol$subexpression$2",
            "symbols": [
                "simplestatements_begin_isol$subexpression$2$subexpression$1",
                "kw_read"
            ]
        },
        {
            "name": "simplestatements_begin_isol$subexpression$2$subexpression$2",
            "symbols": [
                "word"
            ],
            "postprocess": kw('committed')
        },
        {
            "name": "simplestatements_begin_isol$subexpression$2",
            "symbols": [
                "kw_read",
                "simplestatements_begin_isol$subexpression$2$subexpression$2"
            ]
        },
        {
            "name": "simplestatements_begin_isol$subexpression$2$subexpression$3",
            "symbols": [
                "word"
            ],
            "postprocess": kw('uncommitted')
        },
        {
            "name": "simplestatements_begin_isol$subexpression$2",
            "symbols": [
                "kw_read",
                "simplestatements_begin_isol$subexpression$2$subexpression$3"
            ]
        },
        {
            "name": "simplestatements_begin_isol",
            "symbols": [
                "simplestatements_begin_isol$subexpression$1",
                "simplestatements_begin_isol$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    isolationLevel: toStr(x[1], ' ')
                })
        },
        {
            "name": "simplestatements_begin_writ$subexpression$1",
            "symbols": [
                "kw_read",
                "kw_write"
            ]
        },
        {
            "name": "simplestatements_begin_writ$subexpression$1",
            "symbols": [
                "kw_read",
                lexerAny.has("kw_only") ? {
                    type: "kw_only"
                } : kw_only
            ]
        },
        {
            "name": "simplestatements_begin_writ",
            "symbols": [
                "simplestatements_begin_writ$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    writeable: toStr(x, ' ')
                })
        },
        {
            "name": "simplestatements_begin_def$ebnf$1",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not
            ],
            "postprocess": id
        },
        {
            "name": "simplestatements_begin_def$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "simplestatements_begin_def",
            "symbols": [
                "simplestatements_begin_def$ebnf$1",
                lexerAny.has("kw_deferrable") ? {
                    type: "kw_deferrable"
                } : kw_deferrable
            ],
            "postprocess": (x)=>track(x, {
                    deferrable: !x[0]
                })
        },
        {
            "name": "insert_statement$subexpression$1",
            "symbols": [
                "kw_insert",
                lexerAny.has("kw_into") ? {
                    type: "kw_into"
                } : kw_into
            ]
        },
        {
            "name": "insert_statement$ebnf$1",
            "symbols": [
                "collist_paren"
            ],
            "postprocess": id
        },
        {
            "name": "insert_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "insert_statement$ebnf$2$subexpression$1$subexpression$1",
            "symbols": [
                "kw_system"
            ]
        },
        {
            "name": "insert_statement$ebnf$2$subexpression$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_user") ? {
                    type: "kw_user"
                } : kw_user
            ]
        },
        {
            "name": "insert_statement$ebnf$2$subexpression$1",
            "symbols": [
                "kw_overriding",
                "insert_statement$ebnf$2$subexpression$1$subexpression$1",
                "kw_value"
            ],
            "postprocess": get(1)
        },
        {
            "name": "insert_statement$ebnf$2",
            "symbols": [
                "insert_statement$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "insert_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "insert_statement$ebnf$3$subexpression$1",
            "symbols": [
                "selection"
            ]
        },
        {
            "name": "insert_statement$ebnf$3$subexpression$1",
            "symbols": [
                "selection_paren"
            ]
        },
        {
            "name": "insert_statement$ebnf$3",
            "symbols": [
                "insert_statement$ebnf$3$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "insert_statement$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "insert_statement$ebnf$4$subexpression$1",
            "symbols": [
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on,
                "kw_conflict",
                "insert_on_conflict"
            ],
            "postprocess": last
        },
        {
            "name": "insert_statement$ebnf$4",
            "symbols": [
                "insert_statement$ebnf$4$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "insert_statement$ebnf$4",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "insert_statement$ebnf$5$subexpression$1",
            "symbols": [
                lexerAny.has("kw_returning") ? {
                    type: "kw_returning"
                } : kw_returning,
                "select_expr_list_aliased"
            ],
            "postprocess": last
        },
        {
            "name": "insert_statement$ebnf$5",
            "symbols": [
                "insert_statement$ebnf$5$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "insert_statement$ebnf$5",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "insert_statement",
            "symbols": [
                "insert_statement$subexpression$1",
                "table_ref_aliased",
                "insert_statement$ebnf$1",
                "insert_statement$ebnf$2",
                "insert_statement$ebnf$3",
                "insert_statement$ebnf$4",
                "insert_statement$ebnf$5"
            ],
            "postprocess": (x)=>{
                const columns = x[2] && x[2].map(asName);
                const overriding = toStr(x[3]);
                const insert1 = unwrap(x[4]);
                const onConflict = x[5];
                const returning = x[6];
                return track(x, {
                    type: 'insert',
                    into: unwrap(x[1]),
                    insert: insert1,
                    ...overriding && {
                        overriding
                    },
                    ...columns && {
                        columns
                    },
                    ...returning && {
                        returning
                    },
                    ...onConflict && {
                        onConflict
                    }
                });
            }
        },
        {
            "name": "insert_values$ebnf$1",
            "symbols": []
        },
        {
            "name": "insert_values$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "insert_value"
            ],
            "postprocess": last
        },
        {
            "name": "insert_values$ebnf$1",
            "symbols": [
                "insert_values$ebnf$1",
                "insert_values$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "insert_values",
            "symbols": [
                "insert_value",
                "insert_values$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "insert_value",
            "symbols": [
                "lparen",
                "insert_expr_list_raw",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "insert_expr_list_raw$ebnf$1",
            "symbols": []
        },
        {
            "name": "insert_expr_list_raw$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "expr_or_select"
            ],
            "postprocess": last
        },
        {
            "name": "insert_expr_list_raw$ebnf$1",
            "symbols": [
                "insert_expr_list_raw$ebnf$1",
                "insert_expr_list_raw$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "insert_expr_list_raw",
            "symbols": [
                "expr_or_select",
                "insert_expr_list_raw$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "insert_on_conflict$ebnf$1",
            "symbols": [
                "insert_on_conflict_what"
            ],
            "postprocess": id
        },
        {
            "name": "insert_on_conflict$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "insert_on_conflict",
            "symbols": [
                "insert_on_conflict$ebnf$1",
                "insert_on_conflict_do"
            ],
            "postprocess": (x)=>track(x, {
                    ...x[0] ? {
                        on: x[0][0]
                    } : {},
                    ...x[1]
                })
        },
        {
            "name": "insert_on_conflict_what$subexpression$1",
            "symbols": [
                "lparen",
                "expr_list_raw",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "insert_on_conflict_what",
            "symbols": [
                "insert_on_conflict_what$subexpression$1"
            ]
        },
        {
            "name": "insert_on_conflict_do",
            "symbols": [
                lexerAny.has("kw_do") ? {
                    type: "kw_do"
                } : kw_do,
                "kw_nothing"
            ],
            "postprocess": (x)=>({
                    do: 'do nothing'
                })
        },
        {
            "name": "insert_on_conflict_do$subexpression$1",
            "symbols": [
                lexerAny.has("kw_do") ? {
                    type: "kw_do"
                } : kw_do,
                "kw_update",
                "kw_set"
            ]
        },
        {
            "name": "insert_on_conflict_do$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_where") ? {
                    type: "kw_where"
                } : kw_where,
                "expr"
            ],
            "postprocess": last
        },
        {
            "name": "insert_on_conflict_do$ebnf$1",
            "symbols": [
                "insert_on_conflict_do$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "insert_on_conflict_do$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "insert_on_conflict_do",
            "symbols": [
                "insert_on_conflict_do$subexpression$1",
                "update_set_list",
                "insert_on_conflict_do$ebnf$1"
            ],
            "postprocess": (x)=>({
                    do: {
                        sets: x[1]
                    },
                    ...x[2] && {
                        where: x[2]
                    }
                })
        },
        {
            "name": "update_statement$ebnf$1",
            "symbols": [
                "select_where"
            ],
            "postprocess": id
        },
        {
            "name": "update_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "update_statement$ebnf$2$subexpression$1",
            "symbols": [
                lexerAny.has("kw_returning") ? {
                    type: "kw_returning"
                } : kw_returning,
                "select_expr_list_aliased"
            ],
            "postprocess": last
        },
        {
            "name": "update_statement$ebnf$2",
            "symbols": [
                "update_statement$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "update_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "update_statement",
            "symbols": [
                "kw_update",
                "table_ref_aliased",
                "kw_set",
                "update_set_list",
                "update_statement$ebnf$1",
                "update_statement$ebnf$2"
            ],
            "postprocess": (x)=>{
                const where = unwrap(x[4]);
                const returning = x[5];
                return track(x, {
                    type: 'update',
                    table: unwrap(x[1]),
                    sets: x[3],
                    ...where ? {
                        where
                    } : {},
                    ...returning ? {
                        returning
                    } : {}
                });
            }
        },
        {
            "name": "update_set_list$ebnf$1",
            "symbols": []
        },
        {
            "name": "update_set_list$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "update_set"
            ],
            "postprocess": last
        },
        {
            "name": "update_set_list$ebnf$1",
            "symbols": [
                "update_set_list$ebnf$1",
                "update_set_list$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "update_set_list",
            "symbols": [
                "update_set",
                "update_set_list$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                const ret6 = [];
                for (const _t of [
                    head,
                    ...tail || []
                ]){
                    const t = unwrap(_t);
                    if (Array.isArray(t)) {
                        ret6.push(...t);
                    } else {
                        ret6.push(t);
                    }
                }
                return ret6;
            }
        },
        {
            "name": "update_set",
            "symbols": [
                "update_set_one"
            ]
        },
        {
            "name": "update_set",
            "symbols": [
                "update_set_multiple"
            ]
        },
        {
            "name": "update_set_one",
            "symbols": [
                "ident",
                lexerAny.has("op_eq") ? {
                    type: "op_eq"
                } : op_eq,
                "expr"
            ],
            "postprocess": (x)=>box(x, {
                    column: asName(x[0]),
                    value: unwrap(x[2])
                })
        },
        {
            "name": "update_set_multiple$subexpression$1",
            "symbols": [
                "lparen",
                "expr_list_raw",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "update_set_multiple",
            "symbols": [
                "collist_paren",
                lexerAny.has("op_eq") ? {
                    type: "op_eq"
                } : op_eq,
                "update_set_multiple$subexpression$1"
            ],
            "postprocess": (x1)=>{
                const cols = x1[0];
                const exprs = x1[2];
                if (cols.length !== exprs.length) {
                    throw new Error('number of columns does not match number of values');
                }
                return box(x1, cols.map((x, i13)=>({
                        column: asName(x),
                        value: unwrap(exprs[i13])
                    })));
            }
        },
        {
            "name": "altertable_statement$ebnf$1",
            "symbols": [
                "kw_ifexists"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_statement$ebnf$2",
            "symbols": [
                lexerAny.has("kw_only") ? {
                    type: "kw_only"
                } : kw_only
            ],
            "postprocess": id
        },
        {
            "name": "altertable_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_statement",
            "symbols": [
                "kw_alter",
                lexerAny.has("kw_table") ? {
                    type: "kw_table"
                } : kw_table,
                "altertable_statement$ebnf$1",
                "altertable_statement$ebnf$2",
                "table_ref",
                "altertable_actions"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'alter table',
                    ...x[2] ? {
                        ifExists: true
                    } : {},
                    ...x[3] ? {
                        only: true
                    } : {},
                    table: unwrap(x[4]),
                    changes: unbox(x[5]).map(unwrap)
                })
        },
        {
            "name": "altertable_actions$ebnf$1",
            "symbols": []
        },
        {
            "name": "altertable_actions$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "altertable_action"
            ],
            "postprocess": last
        },
        {
            "name": "altertable_actions$ebnf$1",
            "symbols": [
                "altertable_actions$ebnf$1",
                "altertable_actions$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "altertable_actions",
            "symbols": [
                "altertable_action",
                "altertable_actions$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_rename_table"
            ]
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_rename_column"
            ]
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_rename_constraint"
            ]
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_add_column"
            ]
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_drop_column"
            ]
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_alter_column"
            ]
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_add_constraint"
            ]
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_drop_constraint"
            ]
        },
        {
            "name": "altertable_action",
            "symbols": [
                "altertable_owner"
            ]
        },
        {
            "name": "altertable_rename_table",
            "symbols": [
                "kw_rename",
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to,
                "word"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'rename',
                    to: asName(last(x))
                })
        },
        {
            "name": "altertable_rename_column$ebnf$1",
            "symbols": [
                "kw_column"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_rename_column$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_rename_column",
            "symbols": [
                "kw_rename",
                "altertable_rename_column$ebnf$1",
                "ident",
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to,
                "ident"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'rename column',
                    column: asName(x[2]),
                    to: asName(last(x))
                })
        },
        {
            "name": "altertable_rename_constraint",
            "symbols": [
                "kw_rename",
                lexerAny.has("kw_constraint") ? {
                    type: "kw_constraint"
                } : kw_constraint,
                "ident",
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to,
                "ident"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'rename constraint',
                    constraint: asName(x[2]),
                    to: asName(last(x))
                })
        },
        {
            "name": "altertable_add_column$ebnf$1",
            "symbols": [
                "kw_column"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_add_column$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_add_column$ebnf$2",
            "symbols": [
                "kw_ifnotexists"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_add_column$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_add_column",
            "symbols": [
                "kw_add",
                "altertable_add_column$ebnf$1",
                "altertable_add_column$ebnf$2",
                "createtable_column"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'add column',
                    ...x[2] ? {
                        ifNotExists: true
                    } : {},
                    column: unwrap(x[3])
                })
        },
        {
            "name": "altertable_drop_column$ebnf$1",
            "symbols": [
                "kw_column"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_drop_column$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_drop_column$ebnf$2",
            "symbols": [
                "kw_ifexists"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_drop_column$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_drop_column",
            "symbols": [
                "kw_drop",
                "altertable_drop_column$ebnf$1",
                "altertable_drop_column$ebnf$2",
                "ident"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'drop column',
                    ...x[2] ? {
                        ifExists: true
                    } : {},
                    column: asName(x[3])
                })
        },
        {
            "name": "altertable_alter_column$ebnf$1",
            "symbols": [
                "kw_column"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_alter_column$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_alter_column",
            "symbols": [
                "kw_alter",
                "altertable_alter_column$ebnf$1",
                "ident",
                "altercol"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'alter column',
                    column: asName(x[2]),
                    alter: unwrap(x[3])
                })
        },
        {
            "name": "altercol$ebnf$1$subexpression$1",
            "symbols": [
                "kw_set",
                "kw_data"
            ]
        },
        {
            "name": "altercol$ebnf$1",
            "symbols": [
                "altercol$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "altercol$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altercol",
            "symbols": [
                "altercol$ebnf$1",
                "kw_type",
                "data_type"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'set type',
                    dataType: unwrap(last(x))
                })
        },
        {
            "name": "altercol",
            "symbols": [
                "kw_set",
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default,
                "expr"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'set default',
                    default: unwrap(last(x))
                })
        },
        {
            "name": "altercol",
            "symbols": [
                "kw_drop",
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default
            ],
            "postprocess": (x)=>track(x, {
                    type: 'drop default'
                })
        },
        {
            "name": "altercol$subexpression$1",
            "symbols": [
                "kw_set"
            ]
        },
        {
            "name": "altercol$subexpression$1",
            "symbols": [
                "kw_drop"
            ]
        },
        {
            "name": "altercol",
            "symbols": [
                "altercol$subexpression$1",
                "kw_not_null"
            ],
            "postprocess": (x)=>track(x, {
                    type: toStr(x, ' ')
                })
        },
        {
            "name": "altercol",
            "symbols": [
                "altercol_generated_add"
            ],
            "postprocess": unwrap
        },
        {
            "name": "altertable_add_constraint",
            "symbols": [
                "kw_add",
                "createtable_constraint"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'add constraint',
                    constraint: unwrap(last(x))
                })
        },
        {
            "name": "altertable_drop_constraint$ebnf$1",
            "symbols": [
                "kw_ifexists"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_drop_constraint$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_drop_constraint$ebnf$2$subexpression$1",
            "symbols": [
                "kw_restrict"
            ]
        },
        {
            "name": "altertable_drop_constraint$ebnf$2$subexpression$1",
            "symbols": [
                "kw_cascade"
            ]
        },
        {
            "name": "altertable_drop_constraint$ebnf$2",
            "symbols": [
                "altertable_drop_constraint$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "altertable_drop_constraint$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altertable_drop_constraint",
            "symbols": [
                "kw_drop",
                lexerAny.has("kw_constraint") ? {
                    type: "kw_constraint"
                } : kw_constraint,
                "altertable_drop_constraint$ebnf$1",
                "ident",
                "altertable_drop_constraint$ebnf$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'drop constraint',
                    ...x[2] ? {
                        ifExists: true
                    } : {},
                    constraint: asName(x[3]),
                    ...x[4] ? {
                        behaviour: toStr(x[4], ' ')
                    } : {}
                })
        },
        {
            "name": "altertable_owner",
            "symbols": [
                "kw_owner",
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to,
                "ident"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'owner',
                    to: asName(last(x))
                })
        },
        {
            "name": "altercol_generated_add",
            "symbols": [
                "kw_add",
                "altercol_generated"
            ],
            "postprocess": last
        },
        {
            "name": "altercol_generated$ebnf$1$subexpression$1",
            "symbols": [
                "kw_always"
            ]
        },
        {
            "name": "altercol_generated$ebnf$1$subexpression$1",
            "symbols": [
                "kw_by",
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default
            ]
        },
        {
            "name": "altercol_generated$ebnf$1",
            "symbols": [
                "altercol_generated$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "altercol_generated$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altercol_generated$subexpression$1",
            "symbols": [
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "kw_identity"
            ]
        },
        {
            "name": "altercol_generated$ebnf$2$subexpression$1",
            "symbols": [
                "lparen",
                "altercol_generated_seq",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "altercol_generated$ebnf$2",
            "symbols": [
                "altercol_generated$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "altercol_generated$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altercol_generated",
            "symbols": [
                "kw_generated",
                "altercol_generated$ebnf$1",
                "altercol_generated$subexpression$1",
                "altercol_generated$ebnf$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'add generated',
                    ...x[1] && {
                        always: toStr(x[1], ' ')
                    },
                    ...x[3] && {
                        sequence: unwrap(x[3])
                    }
                })
        },
        {
            "name": "altercol_generated_seq$ebnf$1$subexpression$1",
            "symbols": [
                "kw_sequence",
                "kw_name",
                "qualified_name"
            ]
        },
        {
            "name": "altercol_generated_seq$ebnf$1",
            "symbols": [
                "altercol_generated_seq$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "altercol_generated_seq$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "altercol_generated_seq$ebnf$2",
            "symbols": []
        },
        {
            "name": "altercol_generated_seq$ebnf$2",
            "symbols": [
                "altercol_generated_seq$ebnf$2",
                "create_sequence_option"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "altercol_generated_seq",
            "symbols": [
                "altercol_generated_seq$ebnf$1",
                "altercol_generated_seq$ebnf$2"
            ],
            "postprocess": (x)=>{
                const ret7 = {
                    ...x[0] && {
                        name: unwrap(last(x[0]))
                    }
                };
                setSeqOpts(ret7, x[1]);
                return track(x, ret7);
            }
        },
        {
            "name": "delete_statement",
            "symbols": [
                "delete_delete"
            ]
        },
        {
            "name": "delete_statement",
            "symbols": [
                "delete_truncate"
            ]
        },
        {
            "name": "delete_delete$subexpression$1",
            "symbols": [
                "kw_delete",
                lexerAny.has("kw_from") ? {
                    type: "kw_from"
                } : kw_from
            ]
        },
        {
            "name": "delete_delete$ebnf$1",
            "symbols": [
                "select_where"
            ],
            "postprocess": id
        },
        {
            "name": "delete_delete$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "delete_delete$ebnf$2$subexpression$1",
            "symbols": [
                lexerAny.has("kw_returning") ? {
                    type: "kw_returning"
                } : kw_returning,
                "select_expr_list_aliased"
            ],
            "postprocess": last
        },
        {
            "name": "delete_delete$ebnf$2",
            "symbols": [
                "delete_delete$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "delete_delete$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "delete_delete",
            "symbols": [
                "delete_delete$subexpression$1",
                "table_ref_aliased",
                "delete_delete$ebnf$1",
                "delete_delete$ebnf$2"
            ],
            "postprocess": (x)=>{
                const where = x[2];
                const returning = x[3];
                return track(x, {
                    type: 'delete',
                    from: unwrap(x[1]),
                    ...where ? {
                        where
                    } : {},
                    ...returning ? {
                        returning
                    } : {}
                });
            }
        },
        {
            "name": "delete_truncate$subexpression$1$ebnf$1",
            "symbols": [
                lexerAny.has("kw_table") ? {
                    type: "kw_table"
                } : kw_table
            ],
            "postprocess": id
        },
        {
            "name": "delete_truncate$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "delete_truncate$subexpression$1",
            "symbols": [
                "kw_truncate",
                "delete_truncate$subexpression$1$ebnf$1"
            ]
        },
        {
            "name": "delete_truncate$macrocall$2",
            "symbols": [
                "table_ref"
            ]
        },
        {
            "name": "delete_truncate$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "delete_truncate$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "delete_truncate$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "delete_truncate$macrocall$1$ebnf$1",
            "symbols": [
                "delete_truncate$macrocall$1$ebnf$1",
                "delete_truncate$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "delete_truncate$macrocall$1",
            "symbols": [
                "delete_truncate$macrocall$2",
                "delete_truncate$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "delete_truncate$ebnf$1$subexpression$1$subexpression$1",
            "symbols": [
                "kw_restart"
            ]
        },
        {
            "name": "delete_truncate$ebnf$1$subexpression$1$subexpression$1",
            "symbols": [
                "kw_continue"
            ]
        },
        {
            "name": "delete_truncate$ebnf$1$subexpression$1",
            "symbols": [
                "delete_truncate$ebnf$1$subexpression$1$subexpression$1",
                "kw_identity"
            ]
        },
        {
            "name": "delete_truncate$ebnf$1",
            "symbols": [
                "delete_truncate$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "delete_truncate$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "delete_truncate",
            "symbols": [
                "delete_truncate$subexpression$1",
                "delete_truncate$macrocall$1",
                "delete_truncate$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'truncate table',
                    tables: x[1],
                    ...x[2] && {
                        identity: toStr(x[2][0])
                    }
                })
        },
        {
            "name": "create_sequence_statement$ebnf$1$subexpression$1",
            "symbols": [
                "kw_temp"
            ]
        },
        {
            "name": "create_sequence_statement$ebnf$1$subexpression$1",
            "symbols": [
                "kw_temporary"
            ]
        },
        {
            "name": "create_sequence_statement$ebnf$1",
            "symbols": [
                "create_sequence_statement$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_sequence_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_sequence_statement$ebnf$2",
            "symbols": [
                "kw_ifnotexists"
            ],
            "postprocess": id
        },
        {
            "name": "create_sequence_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_sequence_statement$ebnf$3",
            "symbols": []
        },
        {
            "name": "create_sequence_statement$ebnf$3",
            "symbols": [
                "create_sequence_statement$ebnf$3",
                "create_sequence_option"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "create_sequence_statement",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "create_sequence_statement$ebnf$1",
                "kw_sequence",
                "create_sequence_statement$ebnf$2",
                "qualified_name",
                "create_sequence_statement$ebnf$3"
            ],
            "postprocess": (x)=>{
                const ret8 = {
                    type: 'create sequence',
                    ...x[1] && {
                        temp: true
                    },
                    ...x[3] && {
                        ifNotExists: true
                    },
                    name: unwrap(x[4]),
                    options: {}
                };
                setSeqOpts(ret8.options, x[5]);
                return track(x, ret8);
            }
        },
        {
            "name": "create_sequence_option",
            "symbols": [
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "data_type"
            ],
            "postprocess": (x)=>box(x, [
                    'as',
                    x[1]
                ])
        },
        {
            "name": "create_sequence_option$ebnf$1",
            "symbols": [
                "kw_by"
            ],
            "postprocess": id
        },
        {
            "name": "create_sequence_option$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_sequence_option",
            "symbols": [
                "kw_increment",
                "create_sequence_option$ebnf$1",
                "int"
            ],
            "postprocess": (x)=>box(x, [
                    'incrementBy',
                    x[2]
                ])
        },
        {
            "name": "create_sequence_option",
            "symbols": [
                "create_sequence_minvalue"
            ],
            "postprocess": (x)=>box(x, [
                    'minValue',
                    x[0]
                ])
        },
        {
            "name": "create_sequence_option",
            "symbols": [
                "create_sequence_maxvalue"
            ],
            "postprocess": (x)=>box(x, [
                    'maxValue',
                    x[0]
                ])
        },
        {
            "name": "create_sequence_option$ebnf$2",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with
            ],
            "postprocess": id
        },
        {
            "name": "create_sequence_option$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_sequence_option",
            "symbols": [
                "kw_start",
                "create_sequence_option$ebnf$2",
                "int"
            ],
            "postprocess": (x)=>box(x, [
                    'startWith',
                    x[2]
                ])
        },
        {
            "name": "create_sequence_option",
            "symbols": [
                "kw_cache",
                "int"
            ],
            "postprocess": (x)=>box(x, [
                    'cache',
                    x[1]
                ])
        },
        {
            "name": "create_sequence_option$ebnf$3",
            "symbols": [
                "kw_no"
            ],
            "postprocess": id
        },
        {
            "name": "create_sequence_option$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_sequence_option",
            "symbols": [
                "create_sequence_option$ebnf$3",
                "kw_cycle"
            ],
            "postprocess": (x)=>box(x, [
                    'cycle',
                    toStr(x, ' ')
                ])
        },
        {
            "name": "create_sequence_option",
            "symbols": [
                "create_sequence_owned_by"
            ],
            "postprocess": (x)=>box(x, [
                    'ownedBy',
                    unwrap(x)
                ])
        },
        {
            "name": "create_sequence_minvalue",
            "symbols": [
                "kw_minvalue",
                "int"
            ],
            "postprocess": last
        },
        {
            "name": "create_sequence_minvalue",
            "symbols": [
                "kw_no",
                "kw_minvalue"
            ],
            "postprocess": (x)=>box(x, 'no minvalue')
        },
        {
            "name": "create_sequence_maxvalue",
            "symbols": [
                "kw_maxvalue",
                "int"
            ],
            "postprocess": last
        },
        {
            "name": "create_sequence_maxvalue",
            "symbols": [
                "kw_no",
                "kw_maxvalue"
            ],
            "postprocess": (x)=>box(x, 'no maxvalue')
        },
        {
            "name": "create_sequence_owned_by$subexpression$1",
            "symbols": [
                "kw_none"
            ]
        },
        {
            "name": "create_sequence_owned_by$subexpression$1",
            "symbols": [
                "qcolumn"
            ]
        },
        {
            "name": "create_sequence_owned_by",
            "symbols": [
                "kw_owned",
                "kw_by",
                "create_sequence_owned_by$subexpression$1"
            ],
            "postprocess": (x)=>box(x, unwrap(last(x)))
        },
        {
            "name": "alter_sequence_statement$ebnf$1",
            "symbols": [
                "kw_ifexists"
            ],
            "postprocess": id
        },
        {
            "name": "alter_sequence_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "alter_sequence_statement",
            "symbols": [
                "kw_alter",
                "kw_sequence",
                "alter_sequence_statement$ebnf$1",
                "qualified_name",
                "alter_sequence_statement_body"
            ],
            "postprocess": (x)=>{
                const ret9 = {
                    type: 'alter sequence',
                    ...x[2] && {
                        ifExists: true
                    },
                    name: unwrap(x[3]),
                    change: x[4]
                };
                return track(x, ret9);
            }
        },
        {
            "name": "alter_sequence_statement_body$ebnf$1",
            "symbols": [
                "alter_sequence_option"
            ]
        },
        {
            "name": "alter_sequence_statement_body$ebnf$1",
            "symbols": [
                "alter_sequence_statement_body$ebnf$1",
                "alter_sequence_option"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "alter_sequence_statement_body",
            "symbols": [
                "alter_sequence_statement_body$ebnf$1"
            ],
            "postprocess": (x)=>{
                const ret10 = {
                    type: 'set options'
                };
                setSeqOpts(ret10, x[0]);
                return track(x, ret10);
            }
        },
        {
            "name": "alter_sequence_statement_body$subexpression$1",
            "symbols": [
                "ident"
            ]
        },
        {
            "name": "alter_sequence_statement_body$subexpression$1",
            "symbols": [
                lexerAny.has("kw_session_user") ? {
                    type: "kw_session_user"
                } : kw_session_user
            ]
        },
        {
            "name": "alter_sequence_statement_body$subexpression$1",
            "symbols": [
                lexerAny.has("kw_current_user") ? {
                    type: "kw_current_user"
                } : kw_current_user
            ]
        },
        {
            "name": "alter_sequence_statement_body",
            "symbols": [
                "kw_owner",
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to,
                "alter_sequence_statement_body$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'owner to',
                    owner: asName(last(x))
                })
        },
        {
            "name": "alter_sequence_statement_body",
            "symbols": [
                "kw_rename",
                lexerAny.has("kw_to") ? {
                    type: "kw_to"
                } : kw_to,
                "ident"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'rename',
                    newName: asName(last(x))
                })
        },
        {
            "name": "alter_sequence_statement_body",
            "symbols": [
                "kw_set",
                "kw_schema",
                "ident"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'set schema',
                    newSchema: asName(last(x))
                })
        },
        {
            "name": "alter_sequence_option",
            "symbols": [
                "create_sequence_option"
            ],
            "postprocess": unwrap
        },
        {
            "name": "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with
            ],
            "postprocess": id
        },
        {
            "name": "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "alter_sequence_option$ebnf$1$subexpression$1",
            "symbols": [
                "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1",
                "int"
            ],
            "postprocess": last
        },
        {
            "name": "alter_sequence_option$ebnf$1",
            "symbols": [
                "alter_sequence_option$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "alter_sequence_option$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "alter_sequence_option",
            "symbols": [
                "kw_restart",
                "alter_sequence_option$ebnf$1"
            ],
            "postprocess": (x)=>box(x, [
                    'restart',
                    typeof unbox(x[1]) === 'number' ? unbox(x[1]) : true
                ])
        },
        {
            "name": "drop_statement$ebnf$1",
            "symbols": [
                "kw_ifexists"
            ],
            "postprocess": id
        },
        {
            "name": "drop_statement$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "drop_statement$macrocall$2",
            "symbols": [
                "qualified_name"
            ]
        },
        {
            "name": "drop_statement$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "drop_statement$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "drop_statement$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "drop_statement$macrocall$1$ebnf$1",
            "symbols": [
                "drop_statement$macrocall$1$ebnf$1",
                "drop_statement$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "drop_statement$macrocall$1",
            "symbols": [
                "drop_statement$macrocall$2",
                "drop_statement$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "drop_statement$ebnf$2$subexpression$1",
            "symbols": [
                "kw_cascade"
            ]
        },
        {
            "name": "drop_statement$ebnf$2$subexpression$1",
            "symbols": [
                "kw_restrict"
            ]
        },
        {
            "name": "drop_statement$ebnf$2",
            "symbols": [
                "drop_statement$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "drop_statement$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "drop_statement",
            "symbols": [
                "kw_drop",
                "drop_what",
                "drop_statement$ebnf$1",
                "drop_statement$macrocall$1",
                "drop_statement$ebnf$2"
            ],
            "postprocess": (x, rej)=>{
                const v = unwrap(x[1]);
                return track(x, {
                    ...v,
                    ...x[2] && {
                        ifExists: true
                    },
                    names: x[3],
                    ...x[4] && {
                        cascade: toStr(x[4])
                    }
                });
            }
        },
        {
            "name": "drop_what",
            "symbols": [
                lexerAny.has("kw_table") ? {
                    type: "kw_table"
                } : kw_table
            ],
            "postprocess": (x)=>track(x, {
                    type: 'drop table'
                })
        },
        {
            "name": "drop_what",
            "symbols": [
                "kw_sequence"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'drop sequence'
                })
        },
        {
            "name": "drop_what",
            "symbols": [
                "kw_type"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'drop type'
                })
        },
        {
            "name": "drop_what$ebnf$1",
            "symbols": [
                lexerAny.has("kw_concurrently") ? {
                    type: "kw_concurrently"
                } : kw_concurrently
            ],
            "postprocess": id
        },
        {
            "name": "drop_what$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "drop_what",
            "symbols": [
                "kw_index",
                "drop_what$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'drop index',
                    ...x[1] && {
                        concurrently: true
                    }
                })
        },
        {
            "name": "with_statement",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with,
                "with_statement_bindings",
                "with_statement_statement"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'with',
                    bind: x[1],
                    in: unwrap(x[2])
                })
        },
        {
            "name": "with_recursive_statement$subexpression$1",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with,
                "kw_recursive"
            ]
        },
        {
            "name": "with_recursive_statement",
            "symbols": [
                "with_recursive_statement$subexpression$1",
                "ident",
                "collist_paren",
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "lparen",
                "union_statement",
                "rparen",
                "with_statement_statement"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'with recursive',
                    alias: asName(x[1]),
                    columnNames: x[2].map(asName),
                    bind: x[5],
                    in: unwrap(x[7])
                })
        },
        {
            "name": "with_statement_bindings$ebnf$1",
            "symbols": []
        },
        {
            "name": "with_statement_bindings$ebnf$1$subexpression$1",
            "symbols": [
                "comma",
                "with_statement_binding"
            ],
            "postprocess": last
        },
        {
            "name": "with_statement_bindings$ebnf$1",
            "symbols": [
                "with_statement_bindings$ebnf$1",
                "with_statement_bindings$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "with_statement_bindings",
            "symbols": [
                "with_statement_binding",
                "with_statement_bindings$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "with_statement_binding",
            "symbols": [
                "word",
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "lparen",
                "with_statement_statement",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    alias: asName(x[0]),
                    statement: unwrap(x[3])
                })
        },
        {
            "name": "with_statement_statement",
            "symbols": [
                "selection"
            ]
        },
        {
            "name": "with_statement_statement",
            "symbols": [
                "insert_statement"
            ]
        },
        {
            "name": "with_statement_statement",
            "symbols": [
                "update_statement"
            ]
        },
        {
            "name": "with_statement_statement",
            "symbols": [
                "delete_statement"
            ]
        },
        {
            "name": "createtype_statement$subexpression$1",
            "symbols": [
                "createtype_enum"
            ]
        },
        {
            "name": "createtype_statement$subexpression$1",
            "symbols": [
                "createtype_composite"
            ]
        },
        {
            "name": "createtype_statement",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "kw_type",
                "qualified_name",
                "createtype_statement$subexpression$1"
            ],
            "postprocess": (x)=>track(x, {
                    name: x[2],
                    ...unwrap(x[3])
                })
        },
        {
            "name": "createtype_enum$macrocall$2",
            "symbols": [
                "enum_value"
            ]
        },
        {
            "name": "createtype_enum$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "createtype_enum$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "createtype_enum$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "createtype_enum$macrocall$1$ebnf$1",
            "symbols": [
                "createtype_enum$macrocall$1$ebnf$1",
                "createtype_enum$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createtype_enum$macrocall$1",
            "symbols": [
                "createtype_enum$macrocall$2",
                "createtype_enum$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "createtype_enum",
            "symbols": [
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "kw_enum",
                "lparen",
                "createtype_enum$macrocall$1",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'create enum',
                    values: x[3]
                })
        },
        {
            "name": "enum_value",
            "symbols": [
                "string"
            ],
            "postprocess": (x)=>track(x, {
                    value: toStr(x)
                })
        },
        {
            "name": "createtype_composite$macrocall$2",
            "symbols": [
                "createtype_composite_attr"
            ]
        },
        {
            "name": "createtype_composite$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "createtype_composite$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "createtype_composite$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "createtype_composite$macrocall$1$ebnf$1",
            "symbols": [
                "createtype_composite$macrocall$1$ebnf$1",
                "createtype_composite$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "createtype_composite$macrocall$1",
            "symbols": [
                "createtype_composite$macrocall$2",
                "createtype_composite$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "createtype_composite",
            "symbols": [
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "lparen",
                "createtype_composite$macrocall$1",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'create composite type',
                    attributes: x[2]
                })
        },
        {
            "name": "createtype_composite_attr$ebnf$1",
            "symbols": [
                "createtable_collate"
            ],
            "postprocess": id
        },
        {
            "name": "createtype_composite_attr$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "createtype_composite_attr",
            "symbols": [
                "word",
                "data_type",
                "createtype_composite_attr$ebnf$1"
            ],
            "postprocess": (x)=>{
                return track(x, {
                    name: asName(x[0]),
                    dataType: x[1],
                    ...x[2] ? {
                        collate: x[2][1]
                    } : {}
                });
            }
        },
        {
            "name": "union_left",
            "symbols": [
                "select_statement"
            ]
        },
        {
            "name": "union_left",
            "symbols": [
                "select_values"
            ]
        },
        {
            "name": "union_left",
            "symbols": [
                "selection_paren"
            ]
        },
        {
            "name": "union_right",
            "symbols": [
                "selection"
            ]
        },
        {
            "name": "union_right",
            "symbols": [
                "selection_paren"
            ]
        },
        {
            "name": "union_statement$subexpression$1$ebnf$1",
            "symbols": [
                lexerAny.has("kw_all") ? {
                    type: "kw_all"
                } : kw_all
            ],
            "postprocess": id
        },
        {
            "name": "union_statement$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "union_statement$subexpression$1",
            "symbols": [
                lexerAny.has("kw_union") ? {
                    type: "kw_union"
                } : kw_union,
                "union_statement$subexpression$1$ebnf$1"
            ]
        },
        {
            "name": "union_statement",
            "symbols": [
                "union_left",
                "union_statement$subexpression$1",
                "union_right"
            ],
            "postprocess": (x)=>{
                return track(x, {
                    type: toStr(x[1], ' '),
                    left: unwrap(x[0]),
                    right: unwrap(x[2])
                });
            }
        },
        {
            "name": "prepare$ebnf$1$subexpression$1",
            "symbols": [
                "lparen",
                "data_type_list",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "prepare$ebnf$1",
            "symbols": [
                "prepare$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "prepare$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "prepare",
            "symbols": [
                "kw_prepare",
                "ident",
                "prepare$ebnf$1",
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "statement_noprep"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'prepare',
                    name: asName(x[1]),
                    ...x[2] && {
                        args: x[2]
                    },
                    statement: unwrap(last(x))
                })
        },
        {
            "name": "deallocate$ebnf$1",
            "symbols": [
                "kw_prepare"
            ],
            "postprocess": id
        },
        {
            "name": "deallocate$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "deallocate",
            "symbols": [
                "kw_deallocate",
                "deallocate$ebnf$1",
                "deallocate_target"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'deallocate',
                    target: x[2]
                })
        },
        {
            "name": "deallocate_target",
            "symbols": [
                "deallocate_all"
            ],
            "postprocess": unwrap
        },
        {
            "name": "deallocate_target",
            "symbols": [
                "deallocate_name"
            ],
            "postprocess": unwrap
        },
        {
            "name": "deallocate_name",
            "symbols": [
                "ident"
            ],
            "postprocess": (x)=>track(x, asName(x[0]))
        },
        {
            "name": "deallocate_all",
            "symbols": [
                lexerAny.has("kw_all") ? {
                    type: "kw_all"
                } : kw_all
            ],
            "postprocess": (x)=>track(x, {
                    option: 'all'
                })
        },
        {
            "name": "create_view_statements",
            "symbols": [
                "create_view"
            ]
        },
        {
            "name": "create_view_statements",
            "symbols": [
                "create_materialized_view"
            ]
        },
        {
            "name": "create_view$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_or") ? {
                    type: "kw_or"
                } : kw_or,
                "kw_replace"
            ]
        },
        {
            "name": "create_view$ebnf$1",
            "symbols": [
                "create_view$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_view$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_view$ebnf$2$subexpression$1",
            "symbols": [
                "kw_temp"
            ]
        },
        {
            "name": "create_view$ebnf$2$subexpression$1",
            "symbols": [
                "kw_temporary"
            ]
        },
        {
            "name": "create_view$ebnf$2",
            "symbols": [
                "create_view$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_view$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_view$ebnf$3",
            "symbols": [
                "kw_recursive"
            ],
            "postprocess": id
        },
        {
            "name": "create_view$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_view$ebnf$4$subexpression$1$macrocall$2",
            "symbols": [
                "ident"
            ]
        },
        {
            "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "create_view$ebnf$4$subexpression$1$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1",
            "symbols": [
                "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1",
                "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "create_view$ebnf$4$subexpression$1$macrocall$1",
            "symbols": [
                "create_view$ebnf$4$subexpression$1$macrocall$2",
                "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "create_view$ebnf$4$subexpression$1",
            "symbols": [
                "lparen",
                "create_view$ebnf$4$subexpression$1$macrocall$1",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "create_view$ebnf$4",
            "symbols": [
                "create_view$ebnf$4$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_view$ebnf$4",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_view$ebnf$5",
            "symbols": [
                "create_view_opts"
            ],
            "postprocess": id
        },
        {
            "name": "create_view$ebnf$5",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_view$ebnf$6$subexpression$1$subexpression$1",
            "symbols": [
                "kw_local"
            ]
        },
        {
            "name": "create_view$ebnf$6$subexpression$1$subexpression$1",
            "symbols": [
                "kw_cascaded"
            ]
        },
        {
            "name": "create_view$ebnf$6$subexpression$1",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with,
                "create_view$ebnf$6$subexpression$1$subexpression$1",
                lexerAny.has("kw_check") ? {
                    type: "kw_check"
                } : kw_check,
                "kw_option"
            ],
            "postprocess": get(1)
        },
        {
            "name": "create_view$ebnf$6",
            "symbols": [
                "create_view$ebnf$6$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_view$ebnf$6",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_view",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "create_view$ebnf$1",
                "create_view$ebnf$2",
                "create_view$ebnf$3",
                "kw_view",
                "qualified_name",
                "create_view$ebnf$4",
                "create_view$ebnf$5",
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "selection",
                "create_view$ebnf$6"
            ],
            "postprocess": (x)=>{
                return track(x, {
                    type: 'create view',
                    ...x[1] && {
                        orReplace: true
                    },
                    ...x[2] && {
                        temp: true
                    },
                    ...x[3] && {
                        recursive: true
                    },
                    name: x[5],
                    ...x[6] && {
                        columnNames: x[6].map(asName)
                    },
                    ...x[7] && {
                        parameters: fromEntries(x[7])
                    },
                    query: x[9],
                    ...x[10] && {
                        checkOption: toStr(x[10])
                    }
                });
            }
        },
        {
            "name": "create_view_opt",
            "symbols": [
                "ident",
                lexerAny.has("op_eq") ? {
                    type: "op_eq"
                } : op_eq,
                "ident"
            ],
            "postprocess": ([a, _, b7])=>[
                    toStr(a),
                    toStr(b7)
                ]
        },
        {
            "name": "create_view_opts$macrocall$2",
            "symbols": [
                "create_view_opt"
            ]
        },
        {
            "name": "create_view_opts$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "create_view_opts$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "create_view_opts$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "create_view_opts$macrocall$1$ebnf$1",
            "symbols": [
                "create_view_opts$macrocall$1$ebnf$1",
                "create_view_opts$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "create_view_opts$macrocall$1",
            "symbols": [
                "create_view_opts$macrocall$2",
                "create_view_opts$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "create_view_opts",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with,
                "create_view_opts$macrocall$1"
            ],
            "postprocess": last
        },
        {
            "name": "create_materialized_view$ebnf$1",
            "symbols": [
                "kw_ifnotexists"
            ],
            "postprocess": id
        },
        {
            "name": "create_materialized_view$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$2",
            "symbols": [
                "ident"
            ]
        },
        {
            "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "create_materialized_view$ebnf$2$subexpression$1$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1",
            "symbols": [
                "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1",
                "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1",
            "symbols": [
                "create_materialized_view$ebnf$2$subexpression$1$macrocall$2",
                "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "create_materialized_view$ebnf$2$subexpression$1",
            "symbols": [
                "lparen",
                "create_materialized_view$ebnf$2$subexpression$1$macrocall$1",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "create_materialized_view$ebnf$2",
            "symbols": [
                "create_materialized_view$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_materialized_view$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_materialized_view$ebnf$3",
            "symbols": [
                "create_view_opts"
            ],
            "postprocess": id
        },
        {
            "name": "create_materialized_view$ebnf$3",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_materialized_view$ebnf$4$subexpression$1",
            "symbols": [
                "kw_tablespace",
                "ident"
            ],
            "postprocess": last
        },
        {
            "name": "create_materialized_view$ebnf$4",
            "symbols": [
                "create_materialized_view$ebnf$4$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_materialized_view$ebnf$4",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_materialized_view$ebnf$5$subexpression$1$ebnf$1",
            "symbols": [
                "kw_no"
            ],
            "postprocess": id
        },
        {
            "name": "create_materialized_view$ebnf$5$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_materialized_view$ebnf$5$subexpression$1",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with,
                "create_materialized_view$ebnf$5$subexpression$1$ebnf$1",
                "kw_data"
            ]
        },
        {
            "name": "create_materialized_view$ebnf$5",
            "symbols": [
                "create_materialized_view$ebnf$5$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_materialized_view$ebnf$5",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_materialized_view",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "kw_materialized",
                "kw_view",
                "create_materialized_view$ebnf$1",
                "qualified_name",
                "create_materialized_view$ebnf$2",
                "create_materialized_view$ebnf$3",
                "create_materialized_view$ebnf$4",
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "selection",
                "create_materialized_view$ebnf$5"
            ],
            "postprocess": (x)=>{
                return track(x, {
                    type: 'create materialized view',
                    ...x[3] && {
                        ifNotExists: true
                    },
                    name: x[4],
                    ...x[5] && {
                        columnNames: x[6].map(asName)
                    },
                    ...x[6] && {
                        parameters: fromEntries(x[6])
                    },
                    ...x[7] && {
                        tablespace: asName(x[7])
                    },
                    query: x[9],
                    ...x[10] && {
                        withData: toStr(x[10][1]) !== 'no'
                    }
                });
            }
        },
        {
            "name": "refresh_view_statements$ebnf$1",
            "symbols": [
                lexerAny.has("kw_concurrently") ? {
                    type: "kw_concurrently"
                } : kw_concurrently
            ],
            "postprocess": id
        },
        {
            "name": "refresh_view_statements$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1",
            "symbols": [
                "kw_no"
            ],
            "postprocess": id
        },
        {
            "name": "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "refresh_view_statements$ebnf$2$subexpression$1",
            "symbols": [
                lexerAny.has("kw_with") ? {
                    type: "kw_with"
                } : kw_with,
                "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1",
                "kw_data"
            ]
        },
        {
            "name": "refresh_view_statements$ebnf$2",
            "symbols": [
                "refresh_view_statements$ebnf$2$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "refresh_view_statements$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "refresh_view_statements",
            "symbols": [
                "kw_refresh",
                "kw_materialized",
                "kw_view",
                "refresh_view_statements$ebnf$1",
                "qname",
                "refresh_view_statements$ebnf$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'refresh materialized view',
                    ...!!x[3] ? {
                        concurrently: true
                    } : {},
                    name: x[4],
                    ...!!x[5] ? {
                        withData: toStr(x[5][1]) !== 'no'
                    } : {}
                })
        },
        {
            "name": "functions_statements",
            "symbols": [
                "create_func"
            ]
        },
        {
            "name": "functions_statements",
            "symbols": [
                "do_stm"
            ]
        },
        {
            "name": "functions_statements",
            "symbols": [
                "drop_func"
            ]
        },
        {
            "name": "create_func$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("kw_or") ? {
                    type: "kw_or"
                } : kw_or,
                "kw_replace"
            ]
        },
        {
            "name": "create_func$ebnf$1",
            "symbols": [
                "create_func$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_func$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_func$subexpression$1$ebnf$1$macrocall$2",
            "symbols": [
                "func_argdef"
            ]
        },
        {
            "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "create_func$subexpression$1$ebnf$1$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1",
            "symbols": [
                "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1",
                "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "create_func$subexpression$1$ebnf$1$macrocall$1",
            "symbols": [
                "create_func$subexpression$1$ebnf$1$macrocall$2",
                "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "create_func$subexpression$1$ebnf$1",
            "symbols": [
                "create_func$subexpression$1$ebnf$1$macrocall$1"
            ],
            "postprocess": id
        },
        {
            "name": "create_func$subexpression$1$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "create_func$subexpression$1",
            "symbols": [
                "lparen",
                "create_func$subexpression$1$ebnf$1",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "create_func$ebnf$2",
            "symbols": [
                "func_spec"
            ]
        },
        {
            "name": "create_func$ebnf$2",
            "symbols": [
                "create_func$ebnf$2",
                "func_spec"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "create_func",
            "symbols": [
                lexerAny.has("kw_create") ? {
                    type: "kw_create"
                } : kw_create,
                "create_func$ebnf$1",
                "kw_function",
                "qname",
                "create_func$subexpression$1",
                "create_func$ebnf$2"
            ],
            "postprocess": (x, rej)=>{
                const specs = {};
                for (const s of x[5]){
                    for(const k6 in s){
                        if (k6[0] !== '_' && k6 in specs) {
                            throw new Error('conflicting or redundant options ' + k6);
                        }
                    }
                    Object.assign(specs, s);
                }
                return track(x, {
                    type: 'create function',
                    ...x[1] && {
                        orReplace: true
                    },
                    name: x[3],
                    arguments: x[4] ?? [],
                    ...specs
                });
            }
        },
        {
            "name": "func_argdef$ebnf$1",
            "symbols": [
                "func_argopts"
            ],
            "postprocess": id
        },
        {
            "name": "func_argdef$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "func_argdef$ebnf$2",
            "symbols": [
                "func_argdefault"
            ],
            "postprocess": id
        },
        {
            "name": "func_argdef$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "func_argdef",
            "symbols": [
                "func_argdef$ebnf$1",
                "data_type",
                "func_argdef$ebnf$2"
            ],
            "postprocess": (x)=>track(x, {
                    default: x[2],
                    type: x[1],
                    ...x[0]
                })
        },
        {
            "name": "func_argdefault",
            "symbols": [
                lexerAny.has("kw_default") ? {
                    type: "kw_default"
                } : kw_default,
                "expr"
            ],
            "postprocess": (x)=>x[1]
        },
        {
            "name": "func_argdefault",
            "symbols": [
                lexerAny.has("op_eq") ? {
                    type: "op_eq"
                } : op_eq,
                "expr"
            ],
            "postprocess": (x)=>x[1]
        },
        {
            "name": "func_argopts$ebnf$1",
            "symbols": [
                "word"
            ],
            "postprocess": id
        },
        {
            "name": "func_argopts$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "func_argopts",
            "symbols": [
                "func_argmod",
                "func_argopts$ebnf$1"
            ],
            "postprocess": (x)=>track(x, {
                    mode: toStr(x[0]),
                    ...x[1] && {
                        name: asName(x[1])
                    }
                })
        },
        {
            "name": "func_argopts",
            "symbols": [
                "word"
            ],
            "postprocess": (x, rej)=>{
                const name8 = asName(x);
                if (name8 === 'out' || name8 === 'inout' || name8 === 'variadic') {
                    return rej;
                }
                return track(x, {
                    name: name8
                });
            }
        },
        {
            "name": "func_argmod",
            "symbols": [
                lexerAny.has("kw_in") ? {
                    type: "kw_in"
                } : kw_in
            ]
        },
        {
            "name": "func_argmod",
            "symbols": [
                "kw_out"
            ]
        },
        {
            "name": "func_argmod",
            "symbols": [
                "kw_inout"
            ]
        },
        {
            "name": "func_argmod",
            "symbols": [
                "kw_variadic"
            ]
        },
        {
            "name": "func_spec",
            "symbols": [
                "kw_language",
                "word"
            ],
            "postprocess": (x)=>track(x, {
                    language: asName(last(x))
                })
        },
        {
            "name": "func_spec",
            "symbols": [
                "func_purity"
            ],
            "postprocess": (x)=>track(x, {
                    purity: toStr(x)
                })
        },
        {
            "name": "func_spec$subexpression$1",
            "symbols": [
                lexerAny.has("codeblock") ? {
                    type: "codeblock"
                } : codeblock
            ]
        },
        {
            "name": "func_spec$subexpression$1",
            "symbols": [
                "string"
            ]
        },
        {
            "name": "func_spec",
            "symbols": [
                lexerAny.has("kw_as") ? {
                    type: "kw_as"
                } : kw_as,
                "func_spec$subexpression$1"
            ],
            "postprocess": (x)=>({
                    code: toStr(last(x))
                })
        },
        {
            "name": "func_spec$ebnf$1",
            "symbols": [
                lexerAny.has("kw_not") ? {
                    type: "kw_not"
                } : kw_not
            ],
            "postprocess": id
        },
        {
            "name": "func_spec$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "func_spec$subexpression$2",
            "symbols": [
                "word"
            ],
            "postprocess": kw('leakproof')
        },
        {
            "name": "func_spec",
            "symbols": [
                "func_spec$ebnf$1",
                "func_spec$subexpression$2"
            ],
            "postprocess": (x)=>track(x, {
                    leakproof: !x[0]
                })
        },
        {
            "name": "func_spec",
            "symbols": [
                "func_returns"
            ],
            "postprocess": (x)=>track(x, {
                    returns: unwrap(x)
                })
        },
        {
            "name": "func_spec$subexpression$3",
            "symbols": [
                "word"
            ],
            "postprocess": kw('called')
        },
        {
            "name": "func_spec",
            "symbols": [
                "func_spec$subexpression$3",
                "oninp"
            ],
            "postprocess": ()=>({
                    onNullInput: 'call'
                })
        },
        {
            "name": "func_spec$subexpression$4",
            "symbols": [
                "word"
            ],
            "postprocess": kw('returns')
        },
        {
            "name": "func_spec",
            "symbols": [
                "func_spec$subexpression$4",
                lexerAny.has("kw_null") ? {
                    type: "kw_null"
                } : kw_null,
                "oninp"
            ],
            "postprocess": ()=>({
                    onNullInput: 'null'
                })
        },
        {
            "name": "func_spec$subexpression$5",
            "symbols": [
                "word"
            ],
            "postprocess": kw('strict')
        },
        {
            "name": "func_spec",
            "symbols": [
                "func_spec$subexpression$5"
            ],
            "postprocess": ()=>({
                    onNullInput: 'strict'
                })
        },
        {
            "name": "func_purity",
            "symbols": [
                "word"
            ],
            "postprocess": kw('immutable')
        },
        {
            "name": "func_purity",
            "symbols": [
                "word"
            ],
            "postprocess": kw('stable')
        },
        {
            "name": "func_purity",
            "symbols": [
                "word"
            ],
            "postprocess": kw('volatile')
        },
        {
            "name": "oninp$subexpression$1",
            "symbols": [
                "word"
            ],
            "postprocess": kw('input')
        },
        {
            "name": "oninp",
            "symbols": [
                lexerAny.has("kw_on") ? {
                    type: "kw_on"
                } : kw_on,
                lexerAny.has("kw_null") ? {
                    type: "kw_null"
                } : kw_null,
                "oninp$subexpression$1"
            ]
        },
        {
            "name": "func_returns",
            "symbols": [
                "kw_returns",
                "data_type"
            ],
            "postprocess": last
        },
        {
            "name": "func_returns$macrocall$2",
            "symbols": [
                "func_ret_table_col"
            ]
        },
        {
            "name": "func_returns$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "func_returns$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "func_returns$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "func_returns$macrocall$1$ebnf$1",
            "symbols": [
                "func_returns$macrocall$1$ebnf$1",
                "func_returns$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "func_returns$macrocall$1",
            "symbols": [
                "func_returns$macrocall$2",
                "func_returns$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "func_returns",
            "symbols": [
                "kw_returns",
                lexerAny.has("kw_table") ? {
                    type: "kw_table"
                } : kw_table,
                "lparen",
                "func_returns$macrocall$1",
                "rparen"
            ],
            "postprocess": (x)=>track(x, {
                    kind: 'table',
                    columns: x[3]
                })
        },
        {
            "name": "func_ret_table_col",
            "symbols": [
                "word",
                "data_type"
            ],
            "postprocess": (x)=>track(x, {
                    name: asName(x[0]),
                    type: x[1]
                })
        },
        {
            "name": "do_stm$ebnf$1$subexpression$1",
            "symbols": [
                "kw_language",
                "word"
            ],
            "postprocess": last
        },
        {
            "name": "do_stm$ebnf$1",
            "symbols": [
                "do_stm$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "do_stm$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "do_stm",
            "symbols": [
                lexerAny.has("kw_do") ? {
                    type: "kw_do"
                } : kw_do,
                "do_stm$ebnf$1",
                lexerAny.has("codeblock") ? {
                    type: "codeblock"
                } : codeblock
            ],
            "postprocess": (x)=>track(x, {
                    type: 'do',
                    ...x[1] && {
                        language: asName(x[1])
                    },
                    code: x[2].value
                })
        },
        {
            "name": "drop_func$ebnf$1$subexpression$1",
            "symbols": [
                "kw_if",
                "kw_exists"
            ]
        },
        {
            "name": "drop_func$ebnf$1",
            "symbols": [
                "drop_func$ebnf$1$subexpression$1"
            ],
            "postprocess": id
        },
        {
            "name": "drop_func$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "drop_func$ebnf$2",
            "symbols": [
                "drop_func_overload"
            ],
            "postprocess": id
        },
        {
            "name": "drop_func$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "drop_func",
            "symbols": [
                "kw_drop",
                "kw_function",
                "drop_func$ebnf$1",
                "qname",
                "drop_func$ebnf$2"
            ],
            "postprocess": (x)=>track(x, {
                    type: 'drop function',
                    ...x[2] && {
                        ifExists: true
                    },
                    name: x[3],
                    ...x[4] && {
                        arguments: x[4]
                    }
                })
        },
        {
            "name": "drop_func_overload$macrocall$2",
            "symbols": [
                "drop_func_overload_col"
            ]
        },
        {
            "name": "drop_func_overload$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "drop_func_overload$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny.has("comma") ? {
                    type: "comma"
                } : comma,
                "drop_func_overload$macrocall$2"
            ],
            "postprocess": last
        },
        {
            "name": "drop_func_overload$macrocall$1$ebnf$1",
            "symbols": [
                "drop_func_overload$macrocall$1$ebnf$1",
                "drop_func_overload$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "drop_func_overload$macrocall$1",
            "symbols": [
                "drop_func_overload$macrocall$2",
                "drop_func_overload$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap(head),
                    ...tail.map(unwrap) || []
                ];
            }
        },
        {
            "name": "drop_func_overload",
            "symbols": [
                "lparen",
                "drop_func_overload$macrocall$1",
                "rparen"
            ],
            "postprocess": get(1)
        },
        {
            "name": "drop_func_overload_col$ebnf$1",
            "symbols": [
                "word"
            ],
            "postprocess": id
        },
        {
            "name": "drop_func_overload_col$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "drop_func_overload_col",
            "symbols": [
                "drop_func_overload_col$ebnf$1",
                "qname"
            ],
            "postprocess": (x)=>track(x, {
                    type: x[1],
                    ...x[0] && {
                        name: asName(x[0])
                    }
                })
        },
        {
            "name": "main$ebnf$1",
            "symbols": []
        },
        {
            "name": "main$ebnf$1",
            "symbols": [
                "main$ebnf$1",
                "statement_separator"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "main$ebnf$2",
            "symbols": []
        },
        {
            "name": "main$ebnf$2$subexpression$1$ebnf$1",
            "symbols": [
                "statement_separator"
            ]
        },
        {
            "name": "main$ebnf$2$subexpression$1$ebnf$1",
            "symbols": [
                "main$ebnf$2$subexpression$1$ebnf$1",
                "statement_separator"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "main$ebnf$2$subexpression$1",
            "symbols": [
                "main$ebnf$2$subexpression$1$ebnf$1",
                "statement"
            ]
        },
        {
            "name": "main$ebnf$2",
            "symbols": [
                "main$ebnf$2",
                "main$ebnf$2$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "main$ebnf$3",
            "symbols": []
        },
        {
            "name": "main$ebnf$3",
            "symbols": [
                "main$ebnf$3",
                "statement_separator"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "main",
            "symbols": [
                "main$ebnf$1",
                "statement",
                "main$ebnf$2",
                "main$ebnf$3"
            ],
            "postprocess": ([_, head, _tail])=>{
                const tail = _tail;
                const ret11 = [
                    unwrap(head),
                    ...tail.map((x)=>unwrap(x[1]))
                ];
                return ret11.length === 1 ? ret11[0] : ret11;
            }
        },
        {
            "name": "statement_separator",
            "symbols": [
                lexerAny.has("semicolon") ? {
                    type: "semicolon"
                } : semicolon
            ]
        },
        {
            "name": "statement",
            "symbols": [
                "statement_noprep"
            ]
        },
        {
            "name": "statement",
            "symbols": [
                "prepare"
            ]
        },
        {
            "name": "statement",
            "symbols": [
                "deallocate"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "selection"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "createtable_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "createextension_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "createindex_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "simplestatements_all"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "insert_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "update_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "altertable_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "delete_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "create_sequence_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "alter_sequence_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "drop_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "createtype_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "create_view_statements"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "refresh_view_statements"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "create_schema"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "raise_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "comment_statement"
            ]
        },
        {
            "name": "statement_noprep",
            "symbols": [
                "functions_statements"
            ]
        },
        {
            "name": "selection",
            "symbols": [
                "select_statement"
            ],
            "postprocess": unwrap
        },
        {
            "name": "selection",
            "symbols": [
                "select_values"
            ],
            "postprocess": unwrap
        },
        {
            "name": "selection",
            "symbols": [
                "with_statement"
            ],
            "postprocess": unwrap
        },
        {
            "name": "selection",
            "symbols": [
                "with_recursive_statement"
            ],
            "postprocess": unwrap
        },
        {
            "name": "selection",
            "symbols": [
                "union_statement"
            ],
            "postprocess": unwrap
        },
        {
            "name": "selection_paren",
            "symbols": [
                "lparen",
                "selection",
                "rparen"
            ],
            "postprocess": get(1)
        }
    ],
    ParserStart: "main"
});
const lexer1 = compile({
    valueString: {
        match: /"(?:\\["\\]|[^\n"\\])*"/,
        value: (x)=>JSON.parse(x),
        type: (x)=>'value'
    },
    valueRaw: {
        match: /[^\s,\{\}"](?:[^,\{\}"]*[^\s,\{\}"])?/,
        type: ()=>'value'
    },
    comma: ',',
    space: {
        match: /[\s\t\n\v\f\r]+/,
        lineBreaks: true
    },
    start_list: '{',
    end_list: '}'
});
lexer1.next = ((next)=>()=>{
        let tok;
        while((tok = next.call(lexer1)) && tok.type === 'space'){}
        return tok;
    })(lexer1.next);
const lexerAny1 = lexer1;
function id1(d) {
    return d[0];
}
const last1 = (x)=>x && x[x.length - 1];
({
    Lexer: lexerAny1,
    ParserRules: [
        {
            "name": "main$ebnf$1",
            "symbols": [
                "elements"
            ],
            "postprocess": id1
        },
        {
            "name": "main$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "main",
            "symbols": [
                lexerAny1.has("start_list") ? {
                    type: "start_list"
                } : start_list,
                "main$ebnf$1",
                lexerAny1.has("end_list") ? {
                    type: "end_list"
                } : end_list
            ],
            "postprocess": (x)=>x[1] || []
        },
        {
            "name": "elements$ebnf$1",
            "symbols": []
        },
        {
            "name": "elements$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny1.has("comma") ? {
                    type: "comma"
                } : comma,
                "elt"
            ],
            "postprocess": last1
        },
        {
            "name": "elements$ebnf$1",
            "symbols": [
                "elements$ebnf$1",
                "elements$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "elements",
            "symbols": [
                "elt",
                "elements$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    head,
                    ...tail || []
                ];
            }
        },
        {
            "name": "elt",
            "symbols": [
                lexerAny1.has("value") ? {
                    type: "value"
                } : value
            ],
            "postprocess": (x)=>x[0].value
        },
        {
            "name": "elt",
            "symbols": [
                "main"
            ],
            "postprocess": (x)=>x[0]
        }
    ],
    ParserStart: "main"
});
const lexer2 = compile({
    comma: ',',
    space: {
        match: /[\s\t\n\v\f\r]+/,
        lineBreaks: true
    },
    int: /\-?\d+(?![\.\d])/,
    float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
    lcurl: '{',
    rcurl: '}',
    lparen: '(',
    rparen: ')',
    lbracket: '[',
    rbracket: ']',
    lcomp: '<',
    rcomp: '>'
});
lexer2.next = ((next)=>()=>{
        let tok;
        while((tok = next.call(lexer2)) && tok.type === 'space'){}
        return tok;
    })(lexer2.next);
const lexerAny2 = lexer2;
function id2(d) {
    return d[0];
}
const get1 = (i14)=>(x)=>x[i14];
const last2 = (x)=>x && x[x.length - 1];
function unwrap1(e) {
    if (Array.isArray(e) && e.length === 1) {
        e = unwrap1(e[0]);
    }
    if (Array.isArray(e) && !e.length) {
        return null;
    }
    return e;
}
({
    Lexer: lexerAny2,
    ParserRules: [
        {
            "name": "number$subexpression$1",
            "symbols": [
                "float"
            ]
        },
        {
            "name": "number$subexpression$1",
            "symbols": [
                "int"
            ]
        },
        {
            "name": "number",
            "symbols": [
                "number$subexpression$1"
            ],
            "postprocess": unwrap1
        },
        {
            "name": "float",
            "symbols": [
                lexerAny2.has("float") ? {
                    type: "float"
                } : __float
            ],
            "postprocess": (args)=>parseFloat(unwrap1(args))
        },
        {
            "name": "int",
            "symbols": [
                lexerAny2.has("int") ? {
                    type: "int"
                } : __int
            ],
            "postprocess": (arg)=>parseInt(unwrap1(arg), 10)
        },
        {
            "name": "comma",
            "symbols": [
                lexerAny2.has("comma") ? {
                    type: "comma"
                } : comma
            ],
            "postprocess": id2
        },
        {
            "name": "point$macrocall$2",
            "symbols": [
                "point_content"
            ]
        },
        {
            "name": "point$macrocall$1$subexpression$1",
            "symbols": [
                "point$macrocall$2"
            ]
        },
        {
            "name": "point$macrocall$1$subexpression$1",
            "symbols": [
                lexerAny2.has("lparen") ? {
                    type: "lparen"
                } : lparen,
                "point$macrocall$2",
                lexerAny2.has("rparen") ? {
                    type: "rparen"
                } : rparen
            ],
            "postprocess": get1(1)
        },
        {
            "name": "point$macrocall$1",
            "symbols": [
                "point$macrocall$1$subexpression$1"
            ],
            "postprocess": unwrap1
        },
        {
            "name": "point",
            "symbols": [
                "point$macrocall$1"
            ],
            "postprocess": unwrap1
        },
        {
            "name": "point_content",
            "symbols": [
                "number",
                "comma",
                "number"
            ],
            "postprocess": (x)=>({
                    x: x[0],
                    y: x[2]
                })
        },
        {
            "name": "line",
            "symbols": [
                lexerAny2.has("lcurl") ? {
                    type: "lcurl"
                } : lcurl,
                "number",
                "comma",
                "number",
                "comma",
                "number",
                lexerAny2.has("rcurl") ? {
                    type: "rcurl"
                } : rcurl
            ],
            "postprocess": (x)=>({
                    a: x[1],
                    b: x[3],
                    c: x[5]
                })
        },
        {
            "name": "box",
            "symbols": [
                "closed_path"
            ],
            "postprocess": ([x], rej)=>{
                if (x.length !== 2) {
                    return rej;
                }
                return x;
            }
        },
        {
            "name": "lseg",
            "symbols": [
                "path"
            ],
            "postprocess": ([x], rej)=>{
                if (x.path.length !== 2) {
                    return rej;
                }
                return x.path;
            }
        },
        {
            "name": "path",
            "symbols": [
                "open_path"
            ],
            "postprocess": ([path4])=>({
                    closed: false,
                    path: path4
                })
        },
        {
            "name": "path",
            "symbols": [
                "closed_path"
            ],
            "postprocess": ([path5])=>({
                    closed: true,
                    path: path5
                })
        },
        {
            "name": "open_path$macrocall$2",
            "symbols": [
                lexerAny2.has("lbracket") ? {
                    type: "lbracket"
                } : lbracket
            ]
        },
        {
            "name": "open_path$macrocall$3",
            "symbols": [
                lexerAny2.has("rbracket") ? {
                    type: "rbracket"
                } : rbracket
            ]
        },
        {
            "name": "open_path$macrocall$1$macrocall$2",
            "symbols": [
                "point"
            ]
        },
        {
            "name": "open_path$macrocall$1$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "open_path$macrocall$1$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny2.has("comma") ? {
                    type: "comma"
                } : comma,
                "open_path$macrocall$1$macrocall$2"
            ],
            "postprocess": last2
        },
        {
            "name": "open_path$macrocall$1$macrocall$1$ebnf$1",
            "symbols": [
                "open_path$macrocall$1$macrocall$1$ebnf$1",
                "open_path$macrocall$1$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "open_path$macrocall$1$macrocall$1",
            "symbols": [
                "open_path$macrocall$1$macrocall$2",
                "open_path$macrocall$1$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap1(head),
                    ...tail.map(unwrap1) || []
                ];
            }
        },
        {
            "name": "open_path$macrocall$1",
            "symbols": [
                "open_path$macrocall$2",
                "open_path$macrocall$1$macrocall$1",
                "open_path$macrocall$3"
            ],
            "postprocess": get1(1)
        },
        {
            "name": "open_path",
            "symbols": [
                "open_path$macrocall$1"
            ],
            "postprocess": last2
        },
        {
            "name": "closed_path$subexpression$1$macrocall$2",
            "symbols": [
                lexerAny2.has("lparen") ? {
                    type: "lparen"
                } : lparen
            ]
        },
        {
            "name": "closed_path$subexpression$1$macrocall$3",
            "symbols": [
                lexerAny2.has("rparen") ? {
                    type: "rparen"
                } : rparen
            ]
        },
        {
            "name": "closed_path$subexpression$1$macrocall$1$macrocall$2",
            "symbols": [
                "point"
            ]
        },
        {
            "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1",
            "symbols": []
        },
        {
            "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny2.has("comma") ? {
                    type: "comma"
                } : comma,
                "closed_path$subexpression$1$macrocall$1$macrocall$2"
            ],
            "postprocess": last2
        },
        {
            "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1",
            "symbols": [
                "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1",
                "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "closed_path$subexpression$1$macrocall$1$macrocall$1",
            "symbols": [
                "closed_path$subexpression$1$macrocall$1$macrocall$2",
                "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap1(head),
                    ...tail.map(unwrap1) || []
                ];
            }
        },
        {
            "name": "closed_path$subexpression$1$macrocall$1",
            "symbols": [
                "closed_path$subexpression$1$macrocall$2",
                "closed_path$subexpression$1$macrocall$1$macrocall$1",
                "closed_path$subexpression$1$macrocall$3"
            ],
            "postprocess": get1(1)
        },
        {
            "name": "closed_path$subexpression$1",
            "symbols": [
                "closed_path$subexpression$1$macrocall$1"
            ],
            "postprocess": last2
        },
        {
            "name": "closed_path$subexpression$1$macrocall$5",
            "symbols": [
                "point"
            ]
        },
        {
            "name": "closed_path$subexpression$1$macrocall$4$ebnf$1",
            "symbols": []
        },
        {
            "name": "closed_path$subexpression$1$macrocall$4$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny2.has("comma") ? {
                    type: "comma"
                } : comma,
                "closed_path$subexpression$1$macrocall$5"
            ],
            "postprocess": last2
        },
        {
            "name": "closed_path$subexpression$1$macrocall$4$ebnf$1",
            "symbols": [
                "closed_path$subexpression$1$macrocall$4$ebnf$1",
                "closed_path$subexpression$1$macrocall$4$ebnf$1$subexpression$1"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "closed_path$subexpression$1$macrocall$4",
            "symbols": [
                "closed_path$subexpression$1$macrocall$5",
                "closed_path$subexpression$1$macrocall$4$ebnf$1"
            ],
            "postprocess": ([head, tail])=>{
                return [
                    unwrap1(head),
                    ...tail.map(unwrap1) || []
                ];
            }
        },
        {
            "name": "closed_path$subexpression$1",
            "symbols": [
                "closed_path$subexpression$1$macrocall$4"
            ],
            "postprocess": last2
        },
        {
            "name": "closed_path",
            "symbols": [
                "closed_path$subexpression$1"
            ],
            "postprocess": get1(0)
        },
        {
            "name": "polygon",
            "symbols": [
                "closed_path"
            ],
            "postprocess": get1(0)
        },
        {
            "name": "circle_body",
            "symbols": [
                "point",
                "comma",
                "number"
            ],
            "postprocess": (x)=>({
                    c: x[0],
                    r: x[2]
                })
        },
        {
            "name": "circle$subexpression$1$macrocall$2",
            "symbols": [
                lexerAny2.has("lcomp") ? {
                    type: "lcomp"
                } : lcomp
            ]
        },
        {
            "name": "circle$subexpression$1$macrocall$3",
            "symbols": [
                lexerAny2.has("rcomp") ? {
                    type: "rcomp"
                } : rcomp
            ]
        },
        {
            "name": "circle$subexpression$1$macrocall$1",
            "symbols": [
                "circle$subexpression$1$macrocall$2",
                "circle_body",
                "circle$subexpression$1$macrocall$3"
            ],
            "postprocess": get1(1)
        },
        {
            "name": "circle$subexpression$1",
            "symbols": [
                "circle$subexpression$1$macrocall$1"
            ]
        },
        {
            "name": "circle$subexpression$1$macrocall$5",
            "symbols": [
                lexerAny2.has("lparen") ? {
                    type: "lparen"
                } : lparen
            ]
        },
        {
            "name": "circle$subexpression$1$macrocall$6",
            "symbols": [
                lexerAny2.has("rparen") ? {
                    type: "rparen"
                } : rparen
            ]
        },
        {
            "name": "circle$subexpression$1$macrocall$4",
            "symbols": [
                "circle$subexpression$1$macrocall$5",
                "circle_body",
                "circle$subexpression$1$macrocall$6"
            ],
            "postprocess": get1(1)
        },
        {
            "name": "circle$subexpression$1",
            "symbols": [
                "circle$subexpression$1$macrocall$4"
            ]
        },
        {
            "name": "circle$subexpression$1",
            "symbols": [
                "circle_body"
            ]
        },
        {
            "name": "circle",
            "symbols": [
                "circle$subexpression$1"
            ],
            "postprocess": unwrap1
        }
    ],
    ParserStart: "number"
});
const lexer3 = compile({
    int: /\d+/,
    neg: '-',
    dot: '.',
    years: /(?:y|yrs?|years?)\b/,
    months: /(?:mon(?:th)?s?)\b/,
    days: /(?:d|days?)\b/,
    hours: /(?:h|hrs?|hours?)\b/,
    minutes: /(?:m|mins?|minutes?)\b/,
    seconds: /(?:s|secs?|seconds?)\b/,
    milliseconds: /(?:ms|milliseconds?)\b/,
    space: {
        match: /[\s\t\n\v\f\r]+/,
        lineBreaks: true
    },
    colon: ':'
});
lexer3.next = ((next)=>()=>{
        let tok;
        while((tok = next.call(lexer3)) && tok.type === 'space'){}
        return tok;
    })(lexer3.next);
const lexerAny3 = lexer3;
function id3(d) {
    return d[0];
}
({
    Lexer: lexerAny3,
    ParserRules: [
        {
            "name": "main$ebnf$1",
            "symbols": [
                "elt"
            ]
        },
        {
            "name": "main$ebnf$1",
            "symbols": [
                "main$ebnf$1",
                "elt"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "main",
            "symbols": [
                "main$ebnf$1"
            ],
            "postprocess": ([elts])=>{
                const s = new Set();
                for (const e of elts){
                    const k7 = typeof e[1] === 'number' ? e[0] : 'time';
                    if (s.has(k7)) {
                        return 'invalid';
                    }
                    s.add(k7);
                }
                return elts;
            }
        },
        {
            "name": "elt",
            "symbols": [
                "time"
            ]
        },
        {
            "name": "elt",
            "symbols": [
                "num",
                "unit"
            ],
            "postprocess": ([[n], u])=>{
                u = u[0].type;
                return [
                    u,
                    n
                ];
            }
        },
        {
            "name": "unit",
            "symbols": [
                lexerAny3.has("years") ? {
                    type: "years"
                } : years
            ]
        },
        {
            "name": "unit",
            "symbols": [
                lexerAny3.has("months") ? {
                    type: "months"
                } : months
            ]
        },
        {
            "name": "unit",
            "symbols": [
                lexerAny3.has("days") ? {
                    type: "days"
                } : days
            ]
        },
        {
            "name": "unit",
            "symbols": [
                lexerAny3.has("hours") ? {
                    type: "hours"
                } : hours
            ]
        },
        {
            "name": "unit",
            "symbols": [
                lexerAny3.has("minutes") ? {
                    type: "minutes"
                } : minutes
            ]
        },
        {
            "name": "unit",
            "symbols": [
                lexerAny3.has("seconds") ? {
                    type: "seconds"
                } : seconds
            ]
        },
        {
            "name": "unit",
            "symbols": [
                lexerAny3.has("milliseconds") ? {
                    type: "milliseconds"
                } : milliseconds
            ]
        },
        {
            "name": "num",
            "symbols": [
                "int"
            ]
        },
        {
            "name": "num",
            "symbols": [
                "float"
            ]
        },
        {
            "name": "uint",
            "symbols": [
                lexerAny3.has("int") ? {
                    type: "int"
                } : __int
            ],
            "postprocess": ([x])=>parseInt(x, 10)
        },
        {
            "name": "int$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny3.has("neg") ? {
                    type: "neg"
                } : neg
            ]
        },
        {
            "name": "int$ebnf$1",
            "symbols": [
                "int$ebnf$1$subexpression$1"
            ],
            "postprocess": id3
        },
        {
            "name": "int$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "int",
            "symbols": [
                "int$ebnf$1",
                lexerAny3.has("int") ? {
                    type: "int"
                } : __int
            ],
            "postprocess": ([neg, x])=>parseInt(x, 10) * (neg ? -1 : 1)
        },
        {
            "name": "float$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny3.has("neg") ? {
                    type: "neg"
                } : neg
            ]
        },
        {
            "name": "float$ebnf$1",
            "symbols": [
                "float$ebnf$1$subexpression$1"
            ],
            "postprocess": id3
        },
        {
            "name": "float$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "float$ebnf$2",
            "symbols": [
                lexerAny3.has("int") ? {
                    type: "int"
                } : __int
            ],
            "postprocess": id3
        },
        {
            "name": "float$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "float",
            "symbols": [
                "float$ebnf$1",
                "float$ebnf$2",
                lexerAny3.has("dot") ? {
                    type: "dot"
                } : dot,
                lexerAny3.has("int") ? {
                    type: "int"
                } : __int
            ],
            "postprocess": ([neg, ...v1])=>parseFloat(v1.map((v)=>v ? v.text : '0').join('')) * (neg ? -1 : 1)
        },
        {
            "name": "time$ebnf$1$subexpression$1",
            "symbols": [
                lexerAny3.has("colon") ? {
                    type: "colon"
                } : colon,
                "uint"
            ]
        },
        {
            "name": "time$ebnf$1",
            "symbols": [
                "time$ebnf$1$subexpression$1"
            ],
            "postprocess": id3
        },
        {
            "name": "time$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "time$ebnf$2$subexpression$1",
            "symbols": [
                lexerAny3.has("dot") ? {
                    type: "dot"
                } : dot,
                lexerAny3.has("int") ? {
                    type: "int"
                } : __int
            ]
        },
        {
            "name": "time$ebnf$2",
            "symbols": [
                "time$ebnf$2$subexpression$1"
            ],
            "postprocess": id3
        },
        {
            "name": "time$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "time",
            "symbols": [
                "uint",
                lexerAny3.has("colon") ? {
                    type: "colon"
                } : colon,
                "uint",
                "time$ebnf$1",
                "time$ebnf$2"
            ],
            "postprocess": ([a, _, b8, c, d])=>{
                c = c && c[1];
                d = d && d[1];
                const ret12 = typeof c === 'number' ? [
                    [
                        'hours',
                        a
                    ],
                    [
                        'minutes',
                        b8
                    ],
                    [
                        'seconds',
                        c
                    ], 
                ] : [
                    [
                        'minutes',
                        a
                    ],
                    [
                        'seconds',
                        b8
                    ], 
                ];
                if (d) {
                    ret12.push([
                        'milliseconds',
                        parseFloat('0.' + d) * 1000
                    ]);
                }
                return ret12;
            }
        }
    ],
    ParserStart: "main"
});
const lexer4 = compile({
    int: /\-?\d+(?![\.\d])/,
    float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
    P: 'P',
    Y: 'Y',
    M: 'M',
    W: 'W',
    D: 'D',
    H: 'H',
    S: 'S',
    T: 'T'
});
const lexerAny4 = lexer4;
function id4(d) {
    return d[0];
}
({
    Lexer: lexerAny4,
    ParserRules: [
        {
            "name": "num",
            "symbols": [
                lexerAny4.has("int") ? {
                    type: "int"
                } : __int
            ]
        },
        {
            "name": "num",
            "symbols": [
                lexerAny4.has("float") ? {
                    type: "float"
                } : __float
            ]
        },
        {
            "name": "main$ebnf$1",
            "symbols": []
        },
        {
            "name": "main$ebnf$1",
            "symbols": [
                "main$ebnf$1",
                "long"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "main$ebnf$2$subexpression$1$ebnf$1",
            "symbols": [
                "short"
            ]
        },
        {
            "name": "main$ebnf$2$subexpression$1$ebnf$1",
            "symbols": [
                "main$ebnf$2$subexpression$1$ebnf$1",
                "short"
            ],
            "postprocess": (d)=>d[0].concat([
                    d[1]
                ])
        },
        {
            "name": "main$ebnf$2$subexpression$1",
            "symbols": [
                lexerAny4.has("T") ? {
                    type: "T"
                } : T,
                "main$ebnf$2$subexpression$1$ebnf$1"
            ]
        },
        {
            "name": "main$ebnf$2",
            "symbols": [
                "main$ebnf$2$subexpression$1"
            ],
            "postprocess": id4
        },
        {
            "name": "main$ebnf$2",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "main",
            "symbols": [
                lexerAny4.has("P") ? {
                    type: "P"
                } : P,
                "main$ebnf$1",
                "main$ebnf$2"
            ],
            "postprocess": ([_, a, b9], rej)=>{
                b9 = !b9 ? [] : b9[1];
                if (!a.length && !b9.length) {
                    return rej;
                }
                return !a.length ? b9 : !b9.length ? a : [
                    ...a,
                    ...b9
                ];
            }
        },
        {
            "name": "long$subexpression$1",
            "symbols": [
                lexerAny4.has("Y") ? {
                    type: "Y"
                } : Y
            ]
        },
        {
            "name": "long$subexpression$1",
            "symbols": [
                lexerAny4.has("M") ? {
                    type: "M"
                } : M
            ]
        },
        {
            "name": "long$subexpression$1",
            "symbols": [
                lexerAny4.has("W") ? {
                    type: "W"
                } : W
            ]
        },
        {
            "name": "long$subexpression$1",
            "symbols": [
                lexerAny4.has("D") ? {
                    type: "D"
                } : D
            ]
        },
        {
            "name": "long",
            "symbols": [
                "num",
                "long$subexpression$1"
            ],
            "postprocess": ([n, u])=>{
                n = parseFloat(n[0].value);
                u = u[0].type;
                switch(u){
                    case 'Y':
                        return [
                            'years',
                            n
                        ];
                    case 'M':
                        return [
                            'months',
                            n
                        ];
                    case 'W':
                        return [
                            'days',
                            n * 7
                        ];
                    case 'D':
                        return [
                            'days',
                            n
                        ];
                    default:
                        throw new Error('Unexpected unit ' + u);
                }
            }
        },
        {
            "name": "short$ebnf$1",
            "symbols": [
                lexerAny4.has("T") ? {
                    type: "T"
                } : T
            ],
            "postprocess": id4
        },
        {
            "name": "short$ebnf$1",
            "symbols": [],
            "postprocess": ()=>null
        },
        {
            "name": "short$subexpression$1",
            "symbols": [
                lexerAny4.has("H") ? {
                    type: "H"
                } : H
            ]
        },
        {
            "name": "short$subexpression$1",
            "symbols": [
                lexerAny4.has("M") ? {
                    type: "M"
                } : M
            ]
        },
        {
            "name": "short$subexpression$1",
            "symbols": [
                lexerAny4.has("S") ? {
                    type: "S"
                } : S
            ]
        },
        {
            "name": "short",
            "symbols": [
                "short$ebnf$1",
                "num",
                "short$subexpression$1"
            ],
            "postprocess": ([_, n, u])=>{
                n = parseFloat(n[0].value);
                u = u[0].type;
                switch(u){
                    case 'H':
                        return [
                            'hours',
                            n
                        ];
                    case 'M':
                        return [
                            'minutes',
                            n
                        ];
                    case 'S':
                        return [
                            'seconds',
                            n
                        ];
                    default:
                        throw new Error('Unexpected unit ' + u);
                }
            }
        }
    ],
    ParserStart: "num"
});
class NotSupported extends Error {
    constructor(what){
        super('Not supported' + (what ? ': ' + what : ''));
    }
    static never(value, msg) {
        return new NotSupported(`${msg ?? ''} ${JSON.stringify(value)}`);
    }
}
function trimNullish(value, depth = 5) {
    if (depth < 0) return value;
    if (value instanceof Array) {
        value.forEach((x)=>trimNullish(x, depth - 1));
    }
    if (typeof value !== 'object' || value instanceof Date) return value;
    if (!value) {
        return value;
    }
    for (const k8 of Object.keys(value)){
        const val = value[k8];
        if (val === undefined || val === null) delete value[k8];
        else trimNullish(val, depth - 1);
    }
    return value;
}
function astMapper(modifierBuilder) {
    const instance = new AstDefaultMapper();
    instance.wrapped = modifierBuilder(instance);
    return instance;
}
function assignChanged(orig, assign) {
    if (!orig) {
        return orig;
    }
    let changed = false;
    for (const k2 of Object.keys(assign)){
        if (orig[k2] !== assign[k2]) {
            changed = true;
            break;
        }
    }
    if (!changed) {
        return orig;
    }
    return trimNullish({
        ...orig,
        ...assign
    }, 0);
}
function arrayNilMap(collection, mapper) {
    if (!collection?.length) {
        return collection;
    }
    let changed = false;
    let ret13 = collection;
    for(let i15 = 0; i15 < collection.length; i15++){
        const orig = collection[i15];
        const val = mapper(orig);
        if (!val || val !== orig) {
            changed = true;
            ret13 = collection.slice(0, i15);
        }
        if (!val) {
            continue;
        }
        if (changed) {
            ret13.push(val);
        }
    }
    return ret13;
}
function withAccepts(val) {
    switch(val?.type){
        case 'select':
        case 'delete':
        case 'insert':
        case 'update':
        case 'union':
        case 'union all':
        case 'with':
            return true;
        default:
            return false;
    }
}
class AstDefaultMapper {
    wrapped;
    skipNext;
    super() {
        return new SkipModifier(this);
    }
    statement(val) {
        switch(val.type){
            case 'alter table':
                return this.alterTable(val);
            case 'commit':
            case 'start transaction':
            case 'rollback':
                return this.transaction(val);
            case 'create index':
                return this.createIndex(val);
            case 'create table':
                return this.createTable(val);
            case 'truncate table':
                return this.truncateTable(val);
            case 'delete':
                return this.delete(val);
            case 'insert':
                return this.insert(val);
            case 'with':
                return this.with(val);
            case 'with recursive':
                return this.withRecursive(val);
            case 'select':
                return this.selection(val);
            case 'update':
                return this.update(val);
            case 'create extension':
                return this.createExtension(val);
            case 'tablespace':
                return this.tablespace(val);
            case 'set':
                return this.setGlobal(val);
            case 'set timezone':
                return this.setTimezone(val);
            case 'create sequence':
                return this.createSequence(val);
            case 'alter sequence':
                return this.alterSequence(val);
            case 'begin':
                return this.begin(val);
            case 'drop table':
            case 'drop index':
            case 'drop sequence':
            case 'drop type':
                return this.drop(val);
            case 'create enum':
                return this.createEnum(val);
            case 'create composite type':
                return this.createCompositeType(val);
            case 'union':
            case 'union all':
                return this.union(val);
            case 'show':
                return this.show(val);
            case 'prepare':
                return this.prepare(val);
            case 'deallocate':
                return this.deallocate(val);
            case 'create view':
                return this.createView(val);
            case 'create materialized view':
                return this.createMaterializedView(val);
            case 'refresh materialized view':
                return this.refreshMaterializedView(val);
            case 'create schema':
                return this.createSchema(val);
            case 'raise':
                return this.raise(val);
            case 'comment':
                return this.comment(val);
            case 'do':
                return this.do(val);
            case 'create function':
                return this.createFunction(val);
            case 'drop function':
                return this.dropFunction(val);
            case 'values':
                return this.values(val);
            default:
                throw NotSupported.never(val);
        }
    }
    comment(val) {
        return val;
    }
    createView(val) {
        const query = this.select(val.query);
        if (!query) {
            return null;
        }
        const ref = this.tableRef(val.name);
        if (!ref) {
            return null;
        }
        return assignChanged(val, {
            query,
            name: ref
        });
    }
    createMaterializedView(val) {
        const query = this.select(val.query);
        if (!query) {
            return null;
        }
        const ref = this.tableRef(val.name);
        if (!ref) {
            return null;
        }
        return assignChanged(val, {
            query,
            name: ref
        });
    }
    refreshMaterializedView(val) {
        return val;
    }
    do(val) {
        return val;
    }
    createFunction(val) {
        const args = arrayNilMap(val.arguments, (a)=>{
            const type4 = this.dataType(a.type);
            return assignChanged(a, {
                type: type4
            });
        });
        let returns;
        if (val.returns) {
            switch(val.returns.kind){
                case 'table':
                    returns = assignChanged(val.returns, {
                        columns: arrayNilMap(val.returns.columns, (v)=>{
                            const type5 = this.dataType(v.type);
                            return type5 && assignChanged(v, {
                                type: type5
                            });
                        })
                    });
                    break;
                case undefined:
                case null:
                case 'array':
                    returns = this.dataType(val.returns);
                    break;
                default:
                    throw NotSupported.never(val.returns);
            }
        }
        return assignChanged(val, {
            returns,
            arguments: args
        });
    }
    dropFunction(val) {
        const args = arrayNilMap(val.arguments, (a)=>{
            const type6 = this.dataType(a.type);
            return assignChanged(a, {
                type: type6
            });
        });
        return assignChanged(val, {
            arguments: args
        });
    }
    show(val) {
        return val;
    }
    createEnum(val) {
        return val;
    }
    createCompositeType(val) {
        const attributes = arrayNilMap(val.attributes, (a)=>assignChanged(a, {
                dataType: this.dataType(a.dataType)
            }));
        return assignChanged(val, {
            attributes
        });
    }
    drop(val) {
        return val;
    }
    alterSequence(seq) {
        if (seq.change.type === 'set options') {
            if (seq.change.as) {
                this.dataType(seq.change.as);
            }
        }
        return seq;
    }
    begin(begin) {
        return begin;
    }
    createSequence(seq) {
        if (seq.options.as) {
            this.dataType(seq.options.as);
        }
        return seq;
    }
    tablespace(val) {
        return val;
    }
    setGlobal(val) {
        return val;
    }
    setTimezone(val) {
        return val;
    }
    update(val) {
        if (!val) {
            return val;
        }
        const table = this.tableRef(val.table);
        if (!table) {
            return null;
        }
        const where = val.where && this.expr(val.where);
        const sets = arrayNilMap(val.sets, (x)=>this.set(x));
        if (!sets?.length) {
            return null;
        }
        const returning = arrayNilMap(val.returning, (c)=>this.selectionColumn(c));
        return assignChanged(val, {
            table,
            where,
            sets,
            returning
        });
    }
    insert(val) {
        const into = this.tableRef(val.into);
        if (!into) {
            return null;
        }
        const select1 = val.insert && this.select(val.insert);
        if (!select1) {
            return null;
        }
        const returning = arrayNilMap(val.returning, (c)=>this.selectionColumn(c));
        const onConflictOn = arrayNilMap(val.onConflict?.on, (e)=>this.expr(e));
        let ocdo = val.onConflict?.do;
        if (ocdo && ocdo !== 'do nothing') {
            const sets = arrayNilMap(ocdo.sets, (x)=>this.set(x));
            if (!sets?.length) {
                ocdo = 'do nothing';
            } else if (ocdo.sets !== sets) {
                ocdo = {
                    sets
                };
            }
        }
        return assignChanged(val, {
            into,
            insert: select1,
            returning,
            onConflict: !ocdo ? val.onConflict : assignChanged(val.onConflict, {
                do: ocdo,
                on: onConflictOn
            })
        });
    }
    raise(val) {
        return assignChanged(val, {
            formatExprs: val.formatExprs && arrayNilMap(val.formatExprs, (x)=>this.expr(x)),
            using: val.using && arrayNilMap(val.using, (u)=>{
                return assignChanged(u, {
                    value: this.expr(u.value)
                });
            })
        });
    }
    delete(val) {
        const from = this.tableRef(val.from);
        if (!from) {
            return null;
        }
        const where = val.where && this.expr(val.where);
        const returning = arrayNilMap(val.returning, (c)=>this.selectionColumn(c));
        return assignChanged(val, {
            where,
            returning,
            from
        });
    }
    createSchema(val) {
        return val;
    }
    createTable(val) {
        const columns = arrayNilMap(val.columns, (col)=>{
            switch(col.kind){
                case 'column':
                    return this.createColumn(col);
                case 'like table':
                    return this.likeTable(col);
                default:
                    throw NotSupported.never(col);
            }
        });
        if (!columns?.length) {
            return null;
        }
        return assignChanged(val, {
            columns
        });
    }
    likeTable(col) {
        const like = this.tableRef(col.like);
        if (!like) {
            return null;
        }
        return assignChanged(col, {
            like
        });
    }
    truncateTable(val) {
        return val;
    }
    constraint(c) {
        switch(c.type){
            case 'not null':
            case 'null':
            case 'primary key':
            case 'unique':
            case 'add generated':
                return c;
            case 'default':
                {
                    const def = this.expr(c.default);
                    if (!def) {
                        return null;
                    }
                    return assignChanged(c, {
                        default: def
                    });
                }
            case 'check':
                {
                    const def = this.expr(c.expr);
                    if (!def) {
                        return null;
                    }
                    return assignChanged(c, {
                        expr: def
                    });
                }
            default:
                throw NotSupported.never(c);
        }
    }
    set(st) {
        const value = this.expr(st.value);
        if (!value) {
            return null;
        }
        return assignChanged(st, {
            value
        });
    }
    dataType(dataType) {
        return dataType;
    }
    tableRef(st) {
        return st;
    }
    transaction(val) {
        return val;
    }
    createExtension(val) {
        return val;
    }
    createIndex(val) {
        const expressions = arrayNilMap(val.expressions, (e)=>{
            const expression = this.expr(e.expression);
            if (expression === e.expression) {
                return e;
            }
            if (!expression) {
                return null;
            }
            return {
                ...e,
                expression
            };
        });
        if (!expressions?.length) {
            return null;
        }
        return assignChanged(val, {
            expressions
        });
    }
    prepare(st) {
        const statement = this.statement(st.statement);
        if (!statement) {
            return null;
        }
        return assignChanged(st, {
            args: arrayNilMap(st.args, (a)=>this.dataType(a)),
            statement
        });
    }
    deallocate(st) {
        return st;
    }
    alterTable(st) {
        const table = this.tableRef(st.table);
        if (!table) {
            return null;
        }
        let changes = [];
        let hasChanged = false;
        for(let i16 = 0; i16 < (st.changes?.length || 0); i16++){
            const currentChange = st.changes[i16];
            const change = this.tableAlteration(currentChange, st.table);
            hasChanged = hasChanged || change != currentChange;
            if (!!change) {
                changes.push(change);
            }
        }
        if (!changes.length) {
            return null;
        }
        if (!hasChanged) {
            return st;
        }
        return assignChanged(st, {
            table,
            changes
        });
    }
    tableAlteration(change, table) {
        switch(change.type){
            case 'add column':
                return this.addColumn(change, table);
            case 'add constraint':
                return this.addConstraint(change, table);
            case 'alter column':
                return this.alterColumn(change, table);
            case 'rename':
                return this.renameTable(change, table);
            case 'rename column':
                return this.renameColumn(change, table);
            case 'rename constraint':
                return this.renameConstraint(change, table);
            case 'drop column':
                return this.dropColumn(change, table);
            case 'drop constraint':
                return this.dropConstraint(change, table);
            case 'owner':
                return this.setTableOwner(change, table);
            default:
                throw NotSupported.never(change);
        }
    }
    dropColumn(change, table) {
        return change;
    }
    dropConstraint(change, table) {
        return change;
    }
    setTableOwner(change, table) {
        return change;
    }
    renameConstraint(change, table) {
        return change;
    }
    renameColumn(change, table) {
        return change;
    }
    renameTable(change, table) {
        return change;
    }
    alterColumn(change, inTable) {
        let alter;
        switch(change.alter.type){
            case 'set default':
                alter = this.setColumnDefault(change.alter, inTable, change.column);
                break;
            case 'set type':
                alter = this.setColumnType(change.alter, inTable, change.column);
                break;
            case 'drop default':
            case 'set not null':
            case 'drop not null':
                alter = this.alterColumnSimple(change.alter, inTable, change.column);
                break;
            case 'add generated':
                alter = this.alterColumnAddGenerated(change.alter, inTable, change.column);
                break;
            default:
                throw NotSupported.never(change.alter);
        }
        if (!alter) {
            return null;
        }
        return assignChanged(change, {
            alter
        });
    }
    setColumnType(alter, inTable, inColumn) {
        const dataType = this.dataType(alter.dataType);
        return assignChanged(alter, {
            dataType
        });
    }
    alterColumnAddGenerated(alter, inTable, inColumn) {
        return alter;
    }
    alterColumnSimple(alter, inTable, inColumn) {
        return alter;
    }
    setColumnDefault(alter, inTable, inColumn) {
        const def = this.expr(alter.default);
        if (!def) {
            return null;
        }
        return assignChanged(alter, {
            default: def
        });
    }
    addConstraint(change, inTable) {
        return change;
    }
    addColumn(change, inTable) {
        const column = this.createColumn(change.column);
        if (!column) {
            return null;
        }
        return assignChanged(change, {
            column
        });
    }
    createColumn(col) {
        const dataType = this.dataType(col.dataType);
        if (!dataType) {
            return null;
        }
        const constraints = arrayNilMap(col.constraints, (m)=>this.constraint(m)) ?? undefined;
        return assignChanged(col, {
            dataType,
            constraints
        });
    }
    select(val) {
        switch(val.type){
            case 'select':
                return this.selection(val);
            case 'union':
            case 'union all':
                return this.union(val);
            case 'with':
                return this.with(val);
            case 'values':
                return this.values(val);
            case 'with recursive':
                return this.withRecursive(val);
            default:
                throw NotSupported.never(val);
        }
    }
    selection(val) {
        const from = arrayNilMap(val.from, (c)=>this.from(c));
        const columns = arrayNilMap(val.columns, (c)=>this.selectionColumn(c));
        const where = val.where && this.expr(val.where);
        const groupBy = arrayNilMap(val.groupBy, (c)=>this.expr(c));
        const orderBy = this.orderBy(val.orderBy);
        const limit = assignChanged(val.limit, {
            limit: this.expr(val.limit?.limit),
            offset: this.expr(val.limit?.offset)
        });
        return assignChanged(val, {
            from,
            columns,
            where,
            groupBy,
            orderBy,
            limit
        });
    }
    orderBy(orderBy) {
        return arrayNilMap(orderBy, (c)=>{
            const by = this.expr(c.by);
            if (!by) {
                return null;
            }
            if (by === c.by) {
                return c;
            }
            return {
                ...c,
                by
            };
        });
    }
    union(val) {
        const left = this.select(val.left);
        const right = this.select(val.right);
        if (!left || !right) {
            return left ?? right;
        }
        return assignChanged(val, {
            left,
            right
        });
    }
    with(val) {
        const bind = arrayNilMap(val.bind, (s)=>{
            const statement = this.statement(s.statement);
            return withAccepts(statement) ? assignChanged(s, {
                statement
            }) : null;
        });
        if (!bind) {
            return null;
        }
        const _in = this.statement(val.in);
        if (!withAccepts(_in)) {
            return null;
        }
        return assignChanged(val, {
            bind,
            in: _in
        });
    }
    withRecursive(val) {
        const statement = this.union(val.bind);
        if (!statement) {
            return null;
        }
        if (statement.type !== 'union' && statement.type !== 'union all') {
            return null;
        }
        const _in = this.statement(val.in);
        if (!withAccepts(_in)) {
            return null;
        }
        return assignChanged(val, {
            bind: statement,
            in: _in
        });
    }
    from(from) {
        switch(from.type){
            case 'table':
                return this.fromTable(from);
            case 'statement':
                return this.fromStatement(from);
            case 'call':
                return this.fromCall(from);
            default:
                throw NotSupported.never(from);
        }
    }
    fromCall(from) {
        const call = this.call(from);
        if (!call || call.type !== 'call') {
            return null;
        }
        return assignChanged(from, call);
    }
    fromStatement(from) {
        const statement = this.select(from.statement);
        if (!statement) {
            return null;
        }
        const join12 = from.join && this.join(from.join);
        return assignChanged(from, {
            statement,
            join: join12
        });
    }
    values(from) {
        const values1 = arrayNilMap(from.values, (x)=>arrayNilMap(x, (y)=>this.expr(y)));
        if (!values1?.length) {
            return null;
        }
        return assignChanged(from, {
            values: values1
        });
    }
    join(join13) {
        const on1 = join13.on && this.expr(join13.on);
        if (!on1 && !join13.using) {
            return join13;
        }
        return assignChanged(join13, {
            on: on1
        });
    }
    fromTable(from) {
        const nfrom = this.tableRef(from.name);
        if (!nfrom) {
            return null;
        }
        const join14 = from.join && this.join(from.join);
        return assignChanged(from, {
            name: nfrom,
            join: join14
        });
    }
    selectionColumn(val) {
        const expr = this.expr(val.expr);
        if (!expr) {
            return null;
        }
        return assignChanged(val, {
            expr
        });
    }
    expr(val) {
        if (!val) {
            return val;
        }
        switch(val.type){
            case 'binary':
                return this.binary(val);
            case 'unary':
                return this.unary(val);
            case 'ref':
                return this.ref(val);
            case 'string':
            case 'numeric':
            case 'integer':
            case 'boolean':
            case 'constant':
            case 'null':
                return this.constant(val);
            case 'list':
            case 'array':
                return this.array(val);
            case 'array select':
                return this.arraySelect(val);
            case 'call':
                return this.call(val);
            case 'cast':
                return this.cast(val);
            case 'case':
                return this.case(val);
            case 'member':
                return this.member(val);
            case 'arrayIndex':
                return this.arrayIndex(val);
            case 'ternary':
                return this.ternary(val);
            case 'select':
            case 'union':
            case 'union all':
            case 'with':
            case 'with recursive':
                return this.select(val);
            case 'keyword':
                return this.valueKeyword(val);
            case 'parameter':
                return this.parameter(val);
            case 'extract':
                return this.extract(val);
            case 'overlay':
                return this.callOverlay(val);
            case 'substring':
                return this.callSubstring(val);
            case 'values':
                return this.values(val);
            case 'default':
                return this.default(val);
            default:
                throw NotSupported.never(val);
        }
    }
    arraySelect(val) {
        const select2 = this.select(val.select);
        if (!select2) {
            return null;
        }
        return assignChanged(val, {
            select: select2
        });
    }
    extract(st) {
        const from = this.expr(st.from);
        if (!from) {
            return null;
        }
        return assignChanged(st, {
            from
        });
    }
    valueKeyword(val) {
        return val;
    }
    ternary(val) {
        const value = this.expr(val.value);
        const lo = this.expr(val.lo);
        const hi = this.expr(val.hi);
        if (!value || !lo || !hi) {
            return null;
        }
        return assignChanged(val, {
            value,
            lo,
            hi
        });
    }
    parameter(st) {
        return st;
    }
    arrayIndex(val) {
        const array = this.expr(val.array);
        const index = this.expr(val.index);
        if (!array || !index) {
            return null;
        }
        return assignChanged(val, {
            array,
            index
        });
    }
    member(val) {
        const operand = this.expr(val.operand);
        if (!operand) {
            return null;
        }
        return assignChanged(val, {
            operand
        });
    }
    case(val) {
        const value1 = val.value && this.expr(val.value);
        const whens = arrayNilMap(val.whens, (w)=>{
            const when = this.expr(w.when);
            const value = this.expr(w.value);
            if (!when || !value) {
                return null;
            }
            return assignChanged(w, {
                value,
                when
            });
        });
        if (!whens?.length) {
            return null;
        }
        const els = val.else && this.expr(val.else);
        return assignChanged(val, {
            value: value1,
            whens,
            else: els
        });
    }
    cast(val) {
        const operand = this.expr(val.operand);
        if (!operand) {
            return null;
        }
        return assignChanged(val, {
            operand
        });
    }
    call(val) {
        const args = arrayNilMap(val.args, (a)=>this.expr(a));
        if (!args) {
            return null;
        }
        const orderBy = this.orderBy(val.orderBy);
        const filter = this.expr(val.filter);
        return assignChanged(val, {
            args,
            orderBy,
            filter
        });
    }
    callSubstring(val) {
        return assignChanged(val, {
            value: this.expr(val.value),
            from: this.expr(val.from),
            for: this.expr(val.for)
        });
    }
    callOverlay(val) {
        return assignChanged(val, {
            value: this.expr(val.value),
            placing: this.expr(val.placing),
            from: this.expr(val.from),
            for: this.expr(val.for)
        });
    }
    array(val) {
        const expressions = arrayNilMap(val.expressions, (a)=>this.expr(a));
        if (!expressions) {
            return null;
        }
        return assignChanged(val, {
            expressions
        });
    }
    constant(value) {
        return value;
    }
    default(value) {
        return value;
    }
    ref(val) {
        return val;
    }
    unary(val) {
        const operand = this.expr(val.operand);
        if (!operand) {
            return null;
        }
        return assignChanged(val, {
            operand
        });
    }
    binary(val) {
        const left = this.expr(val.left);
        const right = this.expr(val.right);
        if (!left || !right) {
            return null;
        }
        return assignChanged(val, {
            left,
            right
        });
    }
}
const proto = AstDefaultMapper.prototype;
for (const k1 of Object.getOwnPropertyNames(proto)){
    const orig = proto[k1];
    if (k1 === 'constructor' || k1 === 'super' || typeof orig !== 'function') {
        continue;
    }
    Object.defineProperty(proto, k1, {
        configurable: false,
        get () {
            return function(...args) {
                if (this.skipNext) {
                    this.skipNext = false;
                    return orig.apply(this, args);
                }
                const impl = this.wrapped?.[k1];
                if (!impl) {
                    return orig.apply(this, args);
                }
                return impl.apply(this.wrapped, args);
            };
        }
    });
}
class SkipModifier extends AstDefaultMapper {
    constructor(parent){
        super();
        this.parent = parent;
    }
    parent;
}
for (const k13 of Object.getOwnPropertyNames(proto)){
    const orig = proto[k13];
    if (k13 === 'constructor' || k13 === 'super' || typeof orig !== 'function') {
        continue;
    }
    Object.defineProperty(SkipModifier.prototype, k13, {
        configurable: false,
        get () {
            return function(...args) {
                this.parent.skipNext = true;
                return orig.apply(this.parent, args);
            };
        }
    });
}
class Visitor {
    mapper;
    visitor;
    super() {
        return new SkipVisitor(this);
    }
}
const mapperProto = AstDefaultMapper.prototype;
for (const k2 of Object.getOwnPropertyNames(mapperProto)){
    const orig = mapperProto[k2];
    if (k2 === 'constructor' || k2 === 'super' || typeof orig !== 'function') {
        continue;
    }
    Object.defineProperty(Visitor.prototype, k2, {
        configurable: false,
        get () {
            return function(...args) {
                const impl = this.visitor[k2];
                if (!impl) {
                    return orig.apply(this, args);
                }
                impl.apply(this.visitor, args);
                return args[0];
            };
        }
    });
}
class SkipVisitor {
    constructor(parent){
        this.parent = parent;
    }
    parent;
}
for (const k11 of Object.getOwnPropertyNames(mapperProto)){
    const orig = mapperProto[k11];
    if (k11 === 'constructor' || k11 === 'super' || typeof orig !== 'function') {
        continue;
    }
    Object.defineProperty(SkipVisitor.prototype, k11, {
        configurable: false,
        get () {
            return function(...args) {
                return orig.apply(this.parent, args);
            };
        }
    });
}
function astVisitor(visitorBuilder) {
    return astMapper((m)=>{
        const ret14 = new Visitor();
        ret14.mapper = m;
        ret14.visitor = visitorBuilder(ret14);
        return ret14;
    });
}
function literal1(val) {
    if (null == val) return 'NULL';
    if (Array.isArray(val)) {
        var vals = val.map(literal1);
        return "(" + vals.join(", ") + ")";
    }
    var backslash = ~val.indexOf('\\');
    var prefix = backslash ? 'E' : '';
    val = val.replace(/'/g, "''");
    val = val.replace(/\\/g, '\\\\');
    return prefix + "'" + val + "'";
}
const kwSet = new Set(sqlKeywords.map((x)=>x.toLowerCase()));
let ret = [];
function name(nm) {
    return ident(nm.name);
}
function ident(nm) {
    const low = nm.toLowerCase();
    if (low === nm && !kwSet.has(low) && /^[a-z][a-z0-9_]*$/.test(low)) {
        return nm;
    }
    return '"' + nm + '"';
}
function list(elems, act, addParen) {
    if (addParen) {
        ret.push('(');
    }
    let first = true;
    for (const e of elems){
        if (!first) {
            ret.push(', ');
        }
        first = false;
        act(e);
    }
    if (addParen) {
        ret.push(')');
    }
}
function addConstraint(c, m) {
    ret.push(c.type);
    switch(c.type){
        case 'foreign key':
            ret.push('(', ...c.localColumns.map(name).join(', '), ') REFERENCES ');
            m.tableRef(c.foreignTable);
            ret.push('(', ...c.foreignColumns.map(name).join(', '), ') ');
            if (c.match) {
                ret.push(' MATCH ', c.match.toUpperCase());
            }
            if (c.onDelete) {
                ret.push(' ON DELETE ', c.onDelete);
            }
            if (c.onUpdate) {
                ret.push(' ON UPDATE ', c.onUpdate);
            }
            break;
        case 'primary key':
        case 'unique':
            if ('columns' in c) {
                ret.push('(', ...c.columns.map(name).join(', '), ') ');
            }
            break;
        case 'check':
            m.expr(c.expr);
            break;
        case 'not null':
        case 'null':
            break;
        case 'default':
            ret.push(' DEFAULT ');
            m.expr(c.default);
            break;
        case 'add generated':
            ret.push(' GENERATED ');
            visitGenerated(m, c);
            break;
        default:
            throw NotSupported.never(c);
    }
}
function visitQualifiedName(cs) {
    if (cs.schema) {
        ret.push(ident(cs.schema), '.');
    }
    ret.push(ident(cs.name), ' ');
}
function visitQualifiedNameAliased(cs) {
    visitQualifiedName(cs);
    if (cs.alias) {
        ret.push(' AS ', ident(cs.alias), ' ');
    }
}
function visitOrderBy(m, orderBy) {
    ret.push(' ORDER BY ');
    list(orderBy, (e)=>{
        m.expr(e.by);
        if (e.order) {
            ret.push(' ', e.order, ' ');
        }
        if (e.nulls) {
            ret.push(' NULLS ', e.nulls, ' ');
        }
    }, false);
}
function visitSetVal(set) {
    switch(set.type){
        case 'default':
            ret.push('DEFAULT ');
            break;
        case 'identifier':
            ret.push(set.name);
            break;
        case 'list':
            let first = true;
            for (const v of set.values){
                if (!first) {
                    ret.push(', ');
                }
                first = false;
                visitSetVal(v);
            }
            break;
        case 'value':
            ret.push(typeof set.value === 'number' ? set.value.toString() : literal1(set.value));
            break;
        default:
            throw NotSupported.never(set);
    }
}
function visitGenerated(m, alter) {
    if (alter.always) {
        ret.push(alter.always.toUpperCase(), ' ');
    }
    ret.push('AS IDENTITY ');
    if (alter.sequence) {
        ret.push('(');
        if (alter.sequence.name) {
            ret.push('SEQUENCE NAME ');
            visitQualifiedName(alter.sequence.name);
            ret.push(' ');
        }
        visitSeqOpts(m, alter.sequence);
        ret.push(') ');
    }
}
function visitSeqOpts(m, cs) {
    if (cs.as) {
        ret.push('AS ');
        m.dataType(cs.as);
        ret.push(' ');
    }
    if (typeof cs.incrementBy === 'number') {
        ret.push('INCREMENT BY ', cs.incrementBy.toString(), ' ');
    }
    if (cs.minValue === 'no minvalue') {
        ret.push('NO MINVALUE ');
    }
    if (typeof cs.minValue === 'number') {
        ret.push('MINVALUE ', cs.minValue.toString(), ' ');
    }
    if (cs.maxValue === 'no maxvalue') {
        ret.push('NO MAXVALUE ');
    }
    if (typeof cs.maxValue === 'number') {
        ret.push('MAXVALUE ', cs.maxValue.toString(), ' ');
    }
    if (typeof cs.startWith === 'number') {
        ret.push('START WITH ', cs.startWith.toString(), ' ');
    }
    if (typeof cs.cache === 'number') {
        ret.push('CACHE ', cs.cache.toString(), ' ');
    }
    if (cs.cycle) {
        ret.push(cs.cycle, ' ');
    }
    if (cs.ownedBy === 'none') {
        ret.push('OWNED BY NONE ');
    } else if (cs.ownedBy) {
        ret.push('OWNED BY ');
        visitQColumn(cs.ownedBy);
    }
    if ('restart' in cs) {
        if (cs.restart === true) {
            ret.push('RESTART ');
        } else if (cs.restart) {
            ret.push('RESTART WITH ', cs.restart.toString(), ' ');
        }
    }
}
function visitQColumn(col) {
    if (col.schema) {
        ret.push(ident(col.schema), '.');
    }
    ret.push(ident(col.table), '.', ident(col.column), ' ');
}
function join(m, j, tbl) {
    if (!j) {
        tbl();
        return;
    }
    ret.push(j.type, ' ');
    tbl();
    if (j.on) {
        ret.push('ON ');
        m.expr(j.on);
    }
    if (j.using) {
        ret.push('USING (');
        list(j.using, (x)=>ret.push(name(x)), false);
        ret.push(') ');
    }
    ret.push(' ');
}
function visitOp(v) {
    if (v.opSchema) {
        ret.push(' operator(', ident(v.opSchema), '.', v.op, ') ');
    } else {
        ret.push(' ', v.op, ' ');
    }
}
const visitor = astVisitor((m)=>({
        addColumn: (...args)=>{
            ret.push(' ADD COLUMN ');
            if (args[0].ifNotExists) {
                ret.push('IF NOT EXISTS ');
            }
            m.super().addColumn(...args);
        },
        createExtension: (e)=>{
            ret.push('CREATE EXTENSION ');
            if (e.ifNotExists) {
                ret.push(' IF NOT EXISTS ');
            }
            ret.push(name(e.extension));
            if (!e.from && !e.version && !e.schema) {
                return;
            }
            ret.push(' WITH');
            if (e.schema) {
                ret.push(' SCHEMA ', name(e.schema));
            }
            if (e.version) {
                ret.push(' VERSION ', literal1(e.version.value));
            }
            if (e.from) {
                ret.push(' FROM ', literal1(e.from.value));
            }
        },
        tablespace: (t)=>{
            ret.push('TABLESPACE ', name(t.tablespace));
        },
        addConstraint: (c)=>{
            ret.push(' ADD ');
            const cname = c.constraint.constraintName;
            if (cname) {
                ret.push(' CONSTRAINT ', name(cname), ' ');
            }
            addConstraint(c.constraint, m);
        },
        alterColumn: (c, t)=>{
            ret.push(' ALTER COLUMN ', name(c.column), ' ');
            m.super().alterColumn(c, t);
        },
        setColumnDefault: (a, t, c)=>{
            ret.push(' SET DEFAULT ');
            m.expr(a.default);
            if (a.updateExisting) {
                throw new Error('Not implemented: updateExisting on set column default');
            }
        },
        createEnum: (t)=>{
            ret.push('CREATE TYPE ');
            visitQualifiedName(t.name);
            ret.push(' AS ENUM ');
            list(t.values, (x)=>ret.push(literal1(x.value)), true);
            ret.push(' ');
        },
        createCompositeType: (c)=>{
            ret.push('CREATE TYPE ');
            visitQualifiedName(c.name);
            ret.push(' AS ');
            list(c.attributes, (x)=>{
                ret.push(name(x.name), ' ');
                m.dataType(x.dataType);
                if (x.collate) {
                    ret.push('COLLATE ');
                    visitQualifiedName(x.collate);
                }
            }, true);
            ret.push(' ');
        },
        setTableOwner: (o)=>{
            ret.push(' OWNER TO ', name(o.to));
        },
        alterColumnSimple: (c)=>ret.push(c.type),
        alterColumnAddGenerated: (alter)=>{
            ret.push(' ADD GENERATED ');
            visitGenerated(m, alter);
        },
        setColumnType: (t)=>{
            ret.push(' SET DATA TYPE ');
            m.dataType(t.dataType);
            ret.push(' ');
        },
        alterTable: (t)=>{
            ret.push('ALTER TABLE ');
            if (t.ifExists) {
                ret.push(' IF EXISTS ');
            }
            if (t.only) {
                ret.push(' ONLY ');
            }
            visitQualifiedNameAliased(t.table);
            list(t.changes, (change)=>m.tableAlteration(change, t.table), false);
        },
        tableAlteration: (change, table)=>{
            switch(change.type){
                case 'add column':
                    return m.addColumn(change, table);
                case 'add constraint':
                    return m.addConstraint(change, table);
                case 'alter column':
                    return m.alterColumn(change, table);
                case 'rename':
                    return m.renameTable(change, table);
                case 'rename column':
                    return m.renameColumn(change, table);
                case 'rename constraint':
                    return m.renameConstraint(change, table);
                case 'drop column':
                    return m.dropColumn(change, table);
                case 'drop constraint':
                    return m.dropConstraint(change, table);
                case 'owner':
                    return m.setTableOwner(change, table);
                default:
                    throw NotSupported.never(change);
            }
        },
        array: (v)=>{
            ret.push(v.type === 'array' ? 'ARRAY[' : '(');
            list(v.expressions, (e)=>m.expr(e), false);
            ret.push(v.type === 'array' ? ']' : ')');
        },
        arrayIndex: (v)=>{
            m.expr(v.array);
            ret.push('[');
            m.expr(v.index);
            ret.push('] ');
        },
        expr: (e)=>{
            if (e.type === 'ref') {
                m.ref(e);
                return;
            }
            if (e.type === 'list') {
                m.super().expr(e);
                return;
            }
            ret.push('(');
            m.super().expr(e);
            ret.push(')');
        },
        callOverlay: (o)=>{
            ret.push('OVERLAY(');
            m.expr(o.value);
            ret.push(' PLACING ');
            m.expr(o.placing);
            ret.push(' FROM ');
            m.expr(o.from);
            if (o.for) {
                ret.push(' FOR ');
                m.expr(o.for);
            }
            ret.push(')');
        },
        callSubstring: (s)=>{
            ret.push('SUBSTRING(');
            m.expr(s.value);
            if (s.from) {
                ret.push(' FROM ');
                m.expr(s.from);
            }
            if (s.for) {
                ret.push(' FOR ');
                m.expr(s.for);
            }
            ret.push(')');
        },
        binary: (v)=>{
            m.expr(v.left);
            visitOp(v);
            m.expr(v.right);
        },
        call: (v)=>{
            visitQualifiedName(v.function);
            ret.push('(');
            if (v.distinct) {
                ret.push(v.distinct, ' ');
            }
            list(v.args, (e)=>m.expr(e), false);
            if (v.orderBy) {
                visitOrderBy(m, v.orderBy);
            }
            ret.push(') ');
            if (v.filter) {
                ret.push('filter (where ');
                m.expr(v.filter);
                ret.push(') ');
            }
            if (v.over) {
                ret.push('over (');
                if (v.over.partitionBy) {
                    ret.push('PARTITION BY ');
                    list(v.over.partitionBy, (x)=>m.expr(x), false);
                    ret.push(' ');
                }
                if (v.over.orderBy) {
                    visitOrderBy(m, v.over.orderBy);
                    ret.push(' ');
                }
                ret.push(') ');
            }
        },
        case: (c)=>{
            ret.push('CASE ');
            if (c.value) {
                m.expr(c.value);
            }
            for (const e of c.whens){
                ret.push(' WHEN ');
                m.expr(e.when);
                ret.push(' THEN ');
                m.expr(e.value);
            }
            if (c.else) {
                ret.push(' ELSE ');
                m.expr(c.else);
            }
            ret.push(' END ');
        },
        cast: (c)=>{
            m.expr(c.operand);
            ret.push('::');
            m.dataType(c.to);
        },
        constant: (c)=>{
            switch(c.type){
                case 'boolean':
                    ret.push(c.value ? 'true' : 'false');
                    break;
                case 'integer':
                    ret.push(c.value.toString(10));
                    break;
                case 'numeric':
                    ret.push(c.value.toString());
                    if (Number.isInteger(c.value)) {
                        ret.push('.');
                    }
                    break;
                case 'null':
                    ret.push('null');
                    break;
                case 'constant':
                    break;
                case 'string':
                    ret.push(literal1(c.value));
                    break;
                default:
                    throw NotSupported.never(c);
            }
        },
        valueKeyword: (v)=>{
            ret.push(v.keyword, ' ');
        },
        comment: (c)=>{
            ret.push('COMMENT ON ', c.on.type.toUpperCase(), ' ');
            switch(c.on.type){
                case 'column':
                    visitQColumn(c.on.column);
                    break;
                default:
                    visitQualifiedName(c.on.name);
                    break;
            }
            ret.push(' IS ', literal1(c.comment), ' ');
        },
        extract: (v)=>{
            ret.push('EXTRACT (', v.field.name.toUpperCase(), ' FROM ');
            m.expr(v.from);
            ret.push(') ');
        },
        createColumn: (c)=>{
            ret.push(name(c.name), ' ');
            m.dataType(c.dataType);
            ret.push(' ');
            if (c.collate) {
                ret.push('COLLATE ');
                visitQualifiedName(c.collate);
            }
            for (const cst of c.constraints ?? []){
                m.constraint(cst);
            }
        },
        begin: (beg)=>{
            ret.push('BEGIN ');
            if (beg.isolationLevel) {
                ret.push('ISOLATION LEVEL ', beg.isolationLevel.toUpperCase(), ' ');
            }
            if (beg.writeable) {
                ret.push(beg.writeable.toUpperCase(), ' ');
            }
            if (typeof beg.deferrable === 'boolean') {
                if (!beg.deferrable) {
                    ret.push('NOT ');
                }
                ret.push('DEFERRABLE ');
            }
        },
        alterSequence: (cs)=>{
            ret.push('ALTER SEQUENCE ');
            if (cs.ifExists) {
                ret.push('IF EXISTS ');
            }
            visitQualifiedName(cs.name);
            switch(cs.change.type){
                case 'set options':
                    visitSeqOpts(m, cs.change);
                    break;
                case 'rename':
                    ret.push('RENAME TO ', name(cs.change.newName), ' ');
                    break;
                case 'set schema':
                    ret.push('SET SCHEMA ', name(cs.change.newSchema), ' ');
                    break;
                case 'owner to':
                    cs.change.owner;
                    ret.push('OWNER TO ', name(cs.change.owner), ' ');
                    break;
                default:
                    throw NotSupported.never(cs.change);
            }
        },
        createSequence: (cs)=>{
            ret.push('CREATE ');
            if (cs.temp) {
                ret.push('TEMPORARY ');
            }
            ret.push('SEQUENCE ');
            if (cs.ifNotExists) {
                ret.push('IF NOT EXISTS ');
            }
            visitQualifiedName(cs.name);
            visitSeqOpts(m, cs.options);
        },
        drop: (val)=>{
            ret.push(val.type.toUpperCase(), ' ');
            if (val.concurrently) {
                ret.push('CONCURRENTLY ');
            }
            if (val.ifExists) {
                ret.push('IF EXISTS ');
            }
            list(val.names, (x)=>m.tableRef(x), false);
            if (val.cascade) {
                ret.push(val.cascade.toUpperCase(), ' ');
            }
        },
        constraint: (cst)=>{
            if (cst.constraintName) {
                ret.push(' CONSTRAINT ', name(cst.constraintName), ' ');
            }
            switch(cst.type){
                case 'not null':
                case 'null':
                case 'primary key':
                case 'unique':
                    ret.push(' ', cst.type, ' ');
                    return;
                case 'default':
                    ret.push(' DEFAULT ');
                    m.expr(cst.default);
                    break;
                case 'check':
                    ret.push(' CHECK ');
                    m.expr(cst.expr);
                    break;
                case 'add generated':
                    ret.push(' GENERATED ');
                    visitGenerated(m, cst);
                    break;
                default:
                    throw NotSupported.never(cst);
            }
        },
        do: (d)=>{
            ret.push('DO');
            if (d.language) {
                ret.push(' LANGUAGE ', d.language.name);
            }
            ret.push(' $$', d.code, '$$');
        },
        createFunction: (c)=>{
            ret.push(c.orReplace ? 'CREATE OR REPLACE FUNCTION ' : 'CREATE FUNCTION ');
            visitQualifiedName(c.name);
            list(c.arguments, (a)=>{
                if (a.mode) {
                    ret.push(a.mode, ' ');
                }
                if (a.name) {
                    ret.push(name(a.name), ' ');
                }
                m.dataType(a.type);
                if (a.default) {
                    ret.push(" = ");
                    m.expr(a.default);
                }
            }, true);
            if (c.returns) {
                switch(c.returns.kind){
                    case 'table':
                        ret.push(' RETURNS TABLE ');
                        list(c.returns.columns, (t)=>{
                            ret.push(name(t.name), ' ');
                            m.dataType(t.type);
                        }, true);
                        break;
                    case undefined:
                    case null:
                    case 'array':
                        ret.push(' RETURNS ');
                        m.dataType(c.returns);
                        break;
                    default:
                        throw NotSupported.never(c.returns);
                }
            }
            ret.push(' AS $$', c.code ?? '', '$$');
            if (c.language) {
                ret.push('LANGUAGE ', c.language.name, ' ');
            }
            if (c.purity) {
                ret.push(c.purity.toUpperCase(), ' ');
            }
            if (typeof c.leakproof === 'boolean') {
                ret.push(c.leakproof ? 'LEAKPROOF ' : 'NOT LEAKPROOF ');
            }
            switch(c.onNullInput){
                case 'call':
                    ret.push('CALLED ON NULL INPUT ');
                    break;
                case 'null':
                    ret.push('RETURNS NULL ON NULL INPUT ');
                    break;
                case 'strict':
                    ret.push('STRICT ');
                    break;
                case null:
                case undefined:
                    break;
                default:
                    throw NotSupported.never(c.onNullInput);
            }
        },
        dropFunction: (d)=>{
            ret.push('DROP FUNCTION ');
            if (d.ifExists) {
                ret.push('IF EXISTS ');
            }
            visitQualifiedName(d.name);
            if (d.arguments) {
                list(d.arguments, (a)=>{
                    if (a.name) {
                        visitQualifiedName(a.name);
                        ret.push(' ');
                    }
                    m.dataType(a.type);
                }, true);
            }
            ret.push(' ');
        },
        with: (w)=>{
            ret.push('WITH ');
            list(w.bind, (b10)=>{
                ret.push(name(b10.alias), ' AS (');
                m.statement(b10.statement);
                ret.push(') ');
            }, false);
            m.statement(w.in);
        },
        withRecursive: (val)=>{
            ret.push('WITH RECURSIVE ', name(val.alias), '(', ...val.columnNames.map(name).join(', '), ') AS (');
            m.union(val.bind);
            ret.push(') ');
            m.statement(val.in);
        },
        setGlobal: (g)=>{
            ret.push('SET ', name(g.variable), ' = ');
            visitSetVal(g.set);
        },
        setTimezone: (g)=>{
            ret.push('SET TIME ZONE ');
            switch(g.to.type){
                case 'default':
                case 'local':
                    ret.push(g.to.type.toUpperCase(), ' ');
                    break;
                case 'value':
                    ret.push(typeof g.to.value === 'string' ? literal1(g.to.value) : g.to.value.toString(10));
                    break;
                case 'interval':
                    ret.push('INTERVAL ', literal1(g.to.value), ' HOUR TO MINUTE');
                    break;
                default:
                    throw NotSupported.never(g.to);
            }
        },
        dataType: (d)=>{
            if (d?.kind === 'array') {
                m.dataType(d.arrayOf);
                ret.push('[]');
                return;
            }
            if (!d?.name) {
                ret.push('unkown');
                return;
            }
            let appendConfig = true;
            if (d.schema) {
                visitQualifiedName(d);
            } else {
                switch(d.name){
                    case 'double precision':
                    case 'character varying':
                    case 'bit varying':
                        ret.push(d.name, ' ');
                        break;
                    case 'time without time zone':
                    case 'timestamp without time zone':
                    case 'time with time zone':
                    case 'timestamp with time zone':
                        const parts = d.name.split(' ');
                        ret.push(parts.shift());
                        if (d.config?.length) {
                            list(d.config, (v)=>ret.push(v.toString(10)), true);
                        }
                        ret.push(' ');
                        ret.push(parts.join(' '), ' ');
                        appendConfig = false;
                        break;
                    default:
                        visitQualifiedName(d);
                        break;
                }
            }
            if (appendConfig && d.config?.length) {
                list(d.config, (v)=>ret.push(v.toString(10)), true);
            }
        },
        createIndex: (c)=>{
            ret.push(c.unique ? 'CREATE UNIQUE INDEX ' : 'CREATE INDEX ');
            if (c.ifNotExists) {
                ret.push(' IF NOT EXISTS ');
            }
            if (c.indexName) {
                ret.push(name(c.indexName), ' ');
            }
            ret.push('ON ');
            m.tableRef(c.table);
            if (c.using) {
                ret.push('USING ', name(c.using), ' ');
            }
            list(c.expressions, (e)=>{
                m.expr(e.expression);
                ret.push(' ');
                if (e.collate) {
                    ret.push('COLLATE ');
                    visitQualifiedName(e.collate);
                }
                if (e.opclass) {
                    visitQualifiedName(e.opclass);
                }
                if (e.order) {
                    ret.push(e.order, ' ');
                }
                if (e.nulls) {
                    ret.push('nulls ', e.nulls, ' ');
                }
            }, true);
            if (c.with) {
                ret.push('WITH ');
                list(c.with, (w)=>{
                    ret.push(w.parameter, ' = ', literal1(w.value));
                }, true);
            }
            if (c.tablespace) {
                ret.push('TABLESPACE ', ident(c.tablespace));
            }
            if (c.where) {
                ret.push(' WHERE ');
                m.expr(c.where);
            }
            ret.push(' ');
        },
        createTable: (t)=>{
            ret.push('CREATE ');
            if (t.locality) {
                ret.push(t.locality.toUpperCase(), ' ');
            }
            if (t.temporary) {
                ret.push('TEMPORARY ');
            }
            if (t.unlogged) {
                ret.push('UNLOGGED ');
            }
            ret.push(t.ifNotExists ? 'TABLE IF NOT EXISTS ' : 'TABLE ');
            m.tableRef(t.name);
            ret.push('(');
            list(t.columns, (c)=>{
                switch(c.kind){
                    case 'column':
                        return m.createColumn(c);
                    case 'like table':
                        return m.likeTable(c);
                    default:
                        throw NotSupported.never(c);
                }
            }, false);
            if (t.constraints) {
                ret.push(', ');
                list(t.constraints, (c)=>{
                    const cname = c.constraintName;
                    if (cname) {
                        ret.push('CONSTRAINT ', name(cname), ' ');
                    }
                    addConstraint(c, m);
                }, false);
            }
            ret.push(') ');
            if (t.inherits?.length) {
                ret.push(' INHERITS ');
                list(t.inherits, (i17)=>visitQualifiedName(i17), true);
            }
        },
        likeTable: (l)=>{
            ret.push(' LIKE ');
            m.tableRef(l.like);
            ret.push(' ');
            for (const { verb , option  } of l.options){
                ret.push(verb.toUpperCase(), ' ', option.toUpperCase(), ' ');
            }
        },
        createSchema: (s)=>{
            ret.push(s.ifNotExists ? 'CREATE SCHEMA IF NOT EXISTS ' : 'CREATE SCHEMA ');
            ret.push(name(s.name));
        },
        truncateTable: (t)=>{
            ret.push('TRUNCATE TABLE ');
            let first = true;
            for (const tbl of t.tables){
                if (!first) {
                    ret.push(', ');
                }
                first = false;
                m.tableRef(tbl);
            }
            if (t.identity) {
                switch(t.identity){
                    case 'restart':
                        ret.push(' RESTART IDENTITY ');
                        break;
                    case 'continue':
                        ret.push(' CONTINUE IDENTITY ');
                        break;
                }
            }
        },
        delete: (t)=>{
            ret.push('DELETE FROM ');
            m.tableRef(t.from);
            if (t.where) {
                ret.push(' WHERE ');
                m.expr(t.where);
            }
            if (t.returning) {
                ret.push(' RETURNING ');
                list(t.returning, (r)=>m.selectionColumn(r), false);
            }
            ret.push(' ');
        },
        dropColumn: (t)=>{
            ret.push(' DROP COLUMN ');
            if (t.ifExists) {
                ret.push(' IF EXISTS ');
            }
            ret.push(name(t.column));
        },
        dropConstraint: (t)=>{
            ret.push(' DROP CONSTRAINT ');
            if (t.ifExists) {
                ret.push(' IF EXISTS ');
            }
            ret.push(name(t.constraint));
            if (t.behaviour) {
                ret.push(' ', t.behaviour.toUpperCase(), ' ');
            }
        },
        from: (t)=>m.super().from(t),
        fromCall: (s)=>{
            join(m, s.join, ()=>{
                m.call(s);
                if (s.alias) {
                    ret.push(' AS ', name(s.alias), ' ');
                }
            });
            ret.push(' ');
        },
        fromStatement: (s)=>{
            join(m, s.join, ()=>{
                ret.push('(');
                m.select(s.statement);
                ret.push(') ');
                if (s.alias) {
                    ret.push(' AS ', ident(s.alias));
                    if (s.columnNames) {
                        list(s.columnNames, (c)=>ret.push(name(c)), true);
                    }
                    ret.push(' ');
                }
            });
            ret.push(' ');
        },
        values: (s)=>{
            ret.push('VALUES ');
            list(s.values, (vlist)=>{
                list(vlist, (e)=>{
                    m.expr(e);
                }, true);
            }, false);
        },
        fromTable: (s)=>{
            join(m, s.join, ()=>{
                m.tableRef(s.name);
                if (s.name.columnNames) {
                    if (!s.name.alias) {
                        throw new Error('Cannot specify aliased column names without an alias');
                    }
                    list(s.name.columnNames, (c)=>ret.push(name(c)), true);
                }
            });
        },
        join: (j)=>{
            throw new Error('Should not happen 💀');
        },
        insert: (i18)=>{
            ret.push('INSERT INTO ');
            m.tableRef(i18.into);
            if (i18.columns) {
                ret.push('(', i18.columns.map(name).join(', '), ')');
            }
            ret.push(' ');
            if (i18.overriding) {
                ret.push('OVERRIDING ', i18.overriding.toUpperCase(), ' VALUE ');
            }
            m.select(i18.insert);
            ret.push(' ');
            if (i18.onConflict) {
                ret.push('ON CONFLICT ');
                if (i18.onConflict.on) {
                    list(i18.onConflict.on, (e)=>m.expr(e), true);
                }
                if (i18.onConflict.do === 'do nothing') {
                    ret.push(' DO NOTHING');
                } else {
                    ret.push(' DO UPDATE SET ');
                    list(i18.onConflict.do.sets, (s)=>m.set(s), false);
                    if (i18.onConflict.where) {
                        ret.push(' WHERE ');
                        m.expr(i18.onConflict.where);
                    }
                }
                ret.push(' ');
            }
            if (i18.returning) {
                ret.push(' RETURNING ');
                list(i18.returning, (r)=>m.selectionColumn(r), false);
            }
        },
        raise: (r)=>{
            ret.push('RAISE ');
            if (r.level) {
                ret.push(r.level.toUpperCase(), ' ');
            }
            ret.push(literal1(r.format), ' ');
            if (r.formatExprs?.length) {
                ret.push(', ');
                list(r.formatExprs, (e)=>m.expr(e), false);
            }
            if (r.using?.length) {
                ret.push(' USING ');
                list(r.using, ({ type: type7 , value  })=>{
                    ret.push(type7.toUpperCase(), '=');
                    m.expr(value);
                }, false);
            }
            ret.push(' ');
        },
        default: ()=>{
            ret.push(' DEFAULT ');
        },
        member: (e)=>{
            m.expr(e.operand);
            ret.push(e.op);
            ret.push(typeof e.member === 'number' ? e.member.toString(10) : literal1(e.member));
        },
        ref: (r)=>{
            if (r.table) {
                visitQualifiedName(r.table);
                ret.push('.');
            }
            ret.push(r.name === '*' ? '*' : ident(r.name));
        },
        parameter: (p)=>{
            ret.push(p.name);
        },
        renameColumn: (r)=>{
            ret.push(' RENAME COLUMN ', name(r.column), ' TO ', name(r.to));
        },
        renameConstraint: (r)=>{
            ret.push(' RENAME CONSTRAINT ', name(r.constraint), ' TO ', name(r.to));
        },
        renameTable: (r)=>{
            ret.push(' RENAME TO ', name(r.to));
        },
        createView: (c1)=>{
            ret.push('CREATE ');
            if (c1.orReplace) {
                ret.push('OR REPLACE ');
            }
            if (c1.temp) {
                ret.push('TEMP ');
            }
            if (c1.recursive) {
                ret.push('RECURSIVE ');
            }
            ret.push('VIEW ');
            m.tableRef(c1.name);
            if (c1.columnNames) {
                list(c1.columnNames, (c)=>ret.push(name(c)), true);
            }
            const opts = c1.parameters && Object.entries(c1.parameters);
            if (opts?.length) {
                ret.push(' WITH ');
                list(opts, ([k1, v])=>ret.push(k1, '=', v), false);
            }
            ret.push(' AS ');
            m.select(c1.query);
            if (c1.checkOption) {
                ret.push(' WITH ', c1.checkOption.toUpperCase(), ' CHECK OPTION');
            }
        },
        createMaterializedView: (c2)=>{
            ret.push('CREATE MATERIALIZED VIEW ');
            if (c2.ifNotExists) {
                ret.push('IF NOT EXISTS ');
            }
            m.tableRef(c2.name);
            if (c2.columnNames) {
                list(c2.columnNames, (c)=>ret.push(name(c)), true);
            }
            const opts = c2.parameters && Object.entries(c2.parameters);
            if (opts?.length) {
                ret.push(' WITH ');
                list(opts, ([k21, v])=>ret.push(k21, '=', v), false);
            }
            if (c2.tablespace) {
                ret.push(' TABLESPACE ', name(c2.tablespace));
            }
            ret.push(' AS ');
            m.select(c2.query);
            if (typeof c2.withData === 'boolean') {
                ret.push(c2.withData ? ' WITH DATA' : ' WITH NO DATA');
            }
        },
        refreshMaterializedView: (val)=>{
            ret.push('REFRESH MATERIALIZED VIEW ');
            if (val.concurrently) {
                ret.push('CONCURRENTLY ');
            }
            m.tableRef(val.name);
            if (typeof val.withData === 'boolean') {
                ret.push(val.withData ? ' WITH DATA' : ' WITH NO DATA');
            }
        },
        select: (s)=>m.super().select(s),
        selection: (s)=>{
            ret.push('SELECT ');
            if (s.distinct) {
                if (typeof s.distinct === 'string') {
                    ret.push(s.distinct.toUpperCase());
                } else {
                    ret.push(' DISTINCT ON ');
                    list(s.distinct, (v)=>m.expr(v), true);
                }
                ret.push(' ');
            }
            if (s.columns) {
                list(s.columns, (c)=>m.selectionColumn(c), false);
            }
            ret.push(' ');
            if (s.from) {
                ret.push('FROM ');
                const tblCnt = s.from.length;
                for(let i19 = 0; i19 < tblCnt; i19++){
                    const f = s.from[i19];
                    if (i19 > 0 && !f.join) {
                        ret.push(',');
                    }
                    m.from(f);
                }
                ret.push(' ');
            }
            if (s.where) {
                ret.push('WHERE ');
                m.expr(s.where);
                ret.push(' ');
            }
            if (s.groupBy) {
                ret.push('GROUP BY ');
                list(s.groupBy, (e)=>m.expr(e), false);
                ret.push(' ');
            }
            if (s.orderBy) {
                visitOrderBy(m, s.orderBy);
                ret.push(' ');
            }
            if (s.limit) {
                if (s.limit.offset) {
                    ret.push(`OFFSET `);
                    m.expr(s.limit.offset);
                }
                if (s.limit.limit) {
                    ret.push(`LIMIT `);
                    m.expr(s.limit.limit);
                }
            }
            if (s.for) {
                ret.push('FOR ', s.for.type.toUpperCase());
            }
        },
        show: (s)=>{
            ret.push('SHOW ', name(s.variable));
        },
        prepare: (s)=>{
            ret.push('PREPARE ', name(s.name));
            if (s.args?.length) {
                list(s.args, (a)=>m.dataType(a), true);
            }
            ret.push(' AS ');
            m.statement(s.statement);
        },
        deallocate: (s)=>{
            ret.push('DEALLOCATE ');
            if ('name' in s.target) {
                ret.push(s.target.name);
                return;
            }
            ret.push('ALL');
        },
        arraySelect: (s)=>{
            ret.push('array(');
            m.select(s.select);
            ret.push(')');
        },
        union: (s)=>{
            ret.push('(');
            m.statement(s.left);
            ret.push(') ', s.type.toUpperCase(), ' ');
            if (s.right.type === 'union' || s.right.type === 'union all') {
                m.union(s.right);
            } else {
                ret.push('(');
                m.statement(s.right);
                ret.push(')');
            }
        },
        selectionColumn: (c)=>{
            m.expr(c.expr);
            if (c.alias) {
                ret.push(' AS ', name(c.alias));
            }
            ret.push(' ');
        },
        set: (s)=>{
            ret.push(name(s.column), ' = ');
            m.expr(s.value);
            ret.push(' ');
        },
        statement: (s)=>m.super().statement(s),
        tableRef: (r)=>{
            visitQualifiedName(r);
            if (r.alias) {
                ret.push(' AS ', ident(r.alias));
            }
            ret.push(' ');
        },
        ternary: (t)=>{
            m.expr(t.value);
            ret.push(' ', t.op, ' ');
            m.expr(t.lo);
            ret.push(' AND ');
            m.expr(t.hi);
            ret.push(' ');
        },
        transaction: (t)=>{
            ret.push(t.type);
        },
        unary: (t)=>{
            switch(t.op){
                case '+':
                case '-':
                    visitOp(t);
                    m.expr(t.operand);
                    break;
                case 'NOT':
                    ret.push(t.op);
                    ret.push(' ');
                    m.expr(t.operand);
                    break;
                default:
                    m.expr(t.operand);
                    ret.push(' ');
                    ret.push(t.op);
            }
        },
        update: (u)=>{
            ret.push('UPDATE ');
            m.tableRef(u.table);
            ret.push(' SET ');
            list(u.sets, (s)=>m.set(s), false);
            ret.push(' ');
            if (u.where) {
                ret.push('WHERE ');
                m.expr(u.where);
                ret.push(' ');
            }
            if (u.returning) {
                ret.push(' RETURNING ');
                list(u.returning, (r)=>m.selectionColumn(r), false);
                ret.push(' ');
            }
        }
    }));
const toSql = {};
const proto1 = AstDefaultMapper.prototype;
for (const k3 of Object.getOwnPropertyNames(proto1)){
    const orig = proto1[k3];
    if (k3 === 'constructor' || k3 === 'super' || typeof orig !== 'function') {
        continue;
    }
    toSql[k3] = function(...args) {
        try {
            visitor[k3].apply(visitor, args);
            return ret.join('').trim();
        } finally{
            ret = [];
        }
    };
}
const associations = {
    user: {
        user_account: {
            kind: "1xN",
            table: "user_account",
            fks: {
                user_id: "id"
            }
        },
        account: {
            kind: "MxN",
            associativeTable: "user_account",
            table: "account",
            fks: {
                user_id: [
                    "user",
                    "id"
                ],
                account_id: [
                    "account",
                    "id"
                ]
            }
        }
    },
    account: {
        user_account: {
            kind: "1xN",
            table: "user_account",
            fks: {
                account_id: "id"
            }
        },
        user: {
            kind: "MxN",
            associativeTable: "user_account",
            table: "user",
            fks: {
                user_id: [
                    "user",
                    "id"
                ],
                account_id: [
                    "account",
                    "id"
                ]
            }
        }
    },
    user_account: null
};
function addReturning(builder) {
    const returningMapper = (columnNames)=>astMapper((_map)=>({
                with: (t)=>{
                    if (t.in.type === "insert") {
                        return {
                            ...t,
                            in: {
                                ...t.in,
                                returning: columnNames.map((c)=>({
                                        expr: {
                                            type: "ref",
                                            name: c.name
                                        }
                                    }))
                            }
                        };
                    }
                },
                insert: (t)=>{
                    if (t.insert) {
                        return {
                            ...t,
                            returning: columnNames.map((c)=>({
                                    expr: {
                                        type: "ref",
                                        name: c.name
                                    }
                                }))
                        };
                    }
                }
            }));
    const returning = function(options) {
        const returningColumns = options.map((c)=>({
                name: c
            }));
        const statementWithReturning = returningMapper(returningColumns).statement(builder.statement);
        const seedBuilder = {
            table: builder.table,
            statement: statementWithReturning,
            toSql: ()=>toSql.statement(statementWithReturning)
        };
        return addReturning(seedBuilder);
    };
    return {
        ...builder,
        returning
    };
}
function insert(table) {
    return function(valueMap, associationMap) {
        const columns = Object.keys(valueMap).map((k9)=>({
                name: k9
            }));
        const values2 = [
            Object.values(valueMap).map((value)=>typeof value === "string" ? {
                    value,
                    type: "string"
                } : typeof value === "object" && value !== null && ("returnType" in value || "type" in value && value["type"] == "ref") ? value : {
                    value: JSON.stringify(value),
                    type: "string"
                }), 
        ];
        const statement = {
            "type": "insert",
            "into": {
                "name": table
            },
            "insert": {
                "type": "values",
                values: values2
            },
            columns
        };
        const builder = addReturning({
            table,
            toSql: ()=>toSql.statement(statement),
            statement
        });
        if (associationMap) {
            for (const [associated, associatedValues] of Object.entries(associationMap)){
                const association = associations[table]?.[associated];
                if (association?.kind == "MxN") {
                    const { fks , associativeTable  } = association;
                    const associativeValues = Object.keys(fks).reduce((previousValue, currentValue)=>{
                        previousValue[currentValue] = {
                            "type": "ref",
                            "table": {
                                "name": fks[currentValue][0]
                            },
                            "name": fks[currentValue][1]
                        };
                        return previousValue;
                    }, {});
                    const returningFksAssociation = Object.values(fks).filter(([fkTable])=>fkTable == association.table).map(([_, fkColumn])=>fkColumn);
                    const returningFksBuilder = Object.values(fks).filter(([fkTable])=>fkTable == builder.table).map(([_, fkColumn])=>fkColumn);
                    const withStatement = insertWith(insert(association.table)(associatedValues).returning(returningFksAssociation))(insertWith(builder.returning(returningFksBuilder))(insert(associativeTable)(associativeValues)));
                    return addReturning({
                        table,
                        toSql: ()=>toSql.statement(withStatement.statement),
                        statement: withStatement.statement
                    });
                }
            }
        }
        return builder;
    };
}
function upsert(table) {
    const onConflictMapper = (conflictValues)=>astMapper((_map)=>({
                insert: (t)=>{
                    if (t.insert) {
                        return {
                            ...t,
                            onConflict: {
                                "do": {
                                    "sets": Object.keys(conflictValues).map((k10)=>({
                                            "column": {
                                                "name": k10
                                            },
                                            "value": {
                                                "type": "string",
                                                "value": String(conflictValues[k10])
                                            }
                                        }))
                                }
                            }
                        };
                    }
                }
            }));
    return (insertValues, updateValues)=>{
        const { statement  } = insert(table)(insertValues);
        const withOnConflict = onConflictMapper(updateValues || insertValues).statement(statement);
        const seedBuilder = {
            table,
            toSql: ()=>toSql.statement(statement),
            statement: withOnConflict
        };
        return addReturning(seedBuilder);
    };
}
function update(table) {
    return (keyValues, setValues)=>{
        const binaryOp = (op)=>(left, right)=>({
                    "type": "binary",
                    left,
                    right,
                    op
                });
        const eq = (name9, value)=>binaryOp("=")({
                "type": "ref",
                name: name9
            }, {
                "type": "string",
                value
            });
        const and = binaryOp("AND");
        const statement = {
            "type": "update",
            "table": {
                "name": table
            },
            "sets": Object.keys(setValues).map((k14)=>({
                    "column": {
                        "name": k14
                    },
                    "value": {
                        "type": "string",
                        "value": String(setValues[k14])
                    }
                })),
            "where": Object.keys(keyValues).reduce((previousValue, currentValue)=>{
                const currentEquality = eq(currentValue, String(keyValues[currentValue]));
                return "type" in previousValue ? and(previousValue, currentEquality) : currentEquality;
            }, {})
        };
        const seedBuilder = {
            table,
            statement,
            toSql: ()=>toSql.statement(statement)
        };
        return addReturning(seedBuilder);
    };
}
function insertWith(context) {
    return function(insert1) {
        const statement = insert1.statement.type === "with" ? {
            ...insert1.statement,
            "bind": [
                ...insert1.statement.bind,
                {
                    "alias": {
                        "name": context.table
                    },
                    "statement": context.statement
                }
            ]
        } : {
            "type": "with",
            "bind": [
                {
                    "alias": {
                        "name": context.table
                    },
                    "statement": context.statement
                }
            ],
            "in": insert1.statement
        };
        const seedBuilder = {
            statement,
            table: insert1.table,
            toSql: ()=>toSql.statement(statement)
        };
        return addReturning(seedBuilder);
    };
}
export { insert as insert, insertWith as insertWith, update as update, upsert as upsert };
function addSignalListener(...args) {
    if (typeof Deno.addSignalListener == "function") {
        return Deno.addSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function futime(...args) {
    if (typeof Deno.futime == "function") {
        return Deno.futime(...args);
    } else {
        return Promise.reject(new TypeError("Requires --unstable"));
    }
}
function futimeSync(...args) {
    if (typeof Deno.futimeSync == "function") {
        return Deno.futimeSync(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function getUid(...args) {
    if (typeof Deno.getUid == "function") {
        return Deno.getUid(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function hostname(...args) {
    if (typeof Deno.hostname == "function") {
        return Deno.hostname(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function loadavg(...args) {
    if (typeof Deno.loadavg == "function") {
        return Deno.loadavg(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function osRelease(...args) {
    if (typeof Deno.osRelease == "function") {
        return Deno.osRelease(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function removeSignalListener(...args) {
    if (typeof Deno.removeSignalListener == "function") {
        return Deno.removeSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function setRaw(...args) {
    if (typeof Deno.setRaw == "function") {
        return Deno.setRaw(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function systemMemoryInfo(...args) {
    if (typeof Deno.systemMemoryInfo == "function") {
        return Deno.systemMemoryInfo(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function utime(...args) {
    if (typeof Deno.utime == "function") {
        return Deno.utime(...args);
    } else {
        return Promise.reject(new TypeError("Requires --unstable"));
    }
}
function utimeSync(...args) {
    if (typeof Deno.utimeSync == "function") {
        return Deno.utimeSync(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function networkInterfaces(...args) {
    if (typeof Deno.networkInterfaces == "function") {
        return Deno.networkInterfaces(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function delay(ms, options = {}) {
    const { signal  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve6, reject)=>{
        const abort = ()=>{
            clearTimeout(i20);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve6();
        };
        const i20 = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
    });
}
const { Deno: Deno1  } = globalThis;
const noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
let enabled = !noColor;
function code(open1, close1) {
    return {
        open: `\x1b[${open1.join(";")}m`,
        close: `\x1b[${close1}m`,
        regexp: new RegExp(`\\x1b\\[${close1}m`, "g")
    };
}
function run(str, code1) {
    return enabled ? `${code1.open}${str.replace(code1.regexp, code1.open)}${code1.close}` : str;
}
function bold(str) {
    return run(str, code([
        1
    ], 22));
}
function red(str) {
    return run(str, code([
        31
    ], 39));
}
function green(str) {
    return run(str, code([
        32
    ], 39));
}
function white(str) {
    return run(str, code([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run(str, code([
        90
    ], 39));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType1) {
    DiffType1["removed"] = "removed";
    DiffType1["common"] = "common";
    DiffType1["added"] = "added";
})(DiffType || (DiffType = {}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse1) {
    const common1 = [];
    if (A.length === 0 || B.length === 0) return [];
    for(let i21 = 0; i21 < Math.min(A.length, B.length); i21 += 1){
        if (A[reverse1 ? A.length - i21 - 1 : i21] === B[reverse1 ? B.length - i21 - 1 : i21]) {
            common1.push(A[reverse1 ? A.length - i21 - 1 : i21]);
        } else {
            return common1;
        }
    }
    return common1;
}
function diff(A1, B1) {
    const prefixCommon = createCommon(A1, B1);
    const suffixCommon = createCommon(A1.slice(prefixCommon.length), B1.slice(prefixCommon.length), true).reverse();
    A1 = suffixCommon.length ? A1.slice(prefixCommon.length, -suffixCommon.length) : A1.slice(prefixCommon.length);
    B1 = suffixCommon.length ? B1.slice(prefixCommon.length, -suffixCommon.length) : B1.slice(prefixCommon.length);
    const swapped1 = B1.length > A1.length;
    [A1, B1] = swapped1 ? [
        B1,
        A1
    ] : [
        A1,
        B1
    ];
    const M1 = A1.length;
    const N1 = B1.length;
    if (!M1 && !N1 && !suffixCommon.length && !prefixCommon.length) return [];
    if (!N1) {
        return [
            ...prefixCommon.map((c)=>({
                    type: DiffType.common,
                    value: c
                })),
            ...A1.map((a)=>({
                    type: swapped1 ? DiffType.added : DiffType.removed,
                    value: a
                })),
            ...suffixCommon.map((c)=>({
                    type: DiffType.common,
                    value: c
                })), 
        ];
    }
    const offset = N1;
    const delta = M1 - N1;
    const size2 = M1 + N1 + 1;
    const fp1 = Array.from({
        length: size2
    }, ()=>({
            y: -1,
            id: -1
        }));
    const routes = new Uint32Array((M1 * N1 + size2 + 1) * 2);
    const diffTypesPtrOffset = routes.length / 2;
    let ptr = 0;
    let p = -1;
    function backTrace(A, B, current, swapped) {
        const M = A.length;
        const N = B.length;
        const result = [];
        let a = M - 1;
        let b11 = N - 1;
        let j = routes[current.id];
        let type8 = routes[current.id + diffTypesPtrOffset];
        while(true){
            if (!j && !type8) break;
            const prev = j;
            if (type8 === 1) {
                result.unshift({
                    type: swapped ? DiffType.removed : DiffType.added,
                    value: B[b11]
                });
                b11 -= 1;
            } else if (type8 === 3) {
                result.unshift({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: A[a]
                });
                a -= 1;
            } else {
                result.unshift({
                    type: DiffType.common,
                    value: A[a]
                });
                a -= 1;
                b11 -= 1;
            }
            j = routes[prev];
            type8 = routes[prev + diffTypesPtrOffset];
        }
        return result;
    }
    function createFP(slide, down, k15, M) {
        if (slide && slide.y === -1 && down && down.y === -1) {
            return {
                y: 0,
                id: 0
            };
        }
        if (down && down.y === -1 || k15 === M || (slide && slide.y) > (down && down.y) + 1) {
            const prev = slide.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = ADDED;
            return {
                y: slide.y,
                id: ptr
            };
        } else {
            const prev = down.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = REMOVED;
            return {
                y: down.y + 1,
                id: ptr
            };
        }
    }
    function snake(k16, slide, down, _offset, A, B) {
        const M = A.length;
        const N = B.length;
        if (k16 < -N || M < k16) return {
            y: -1,
            id: -1
        };
        const fp = createFP(slide, down, k16, M);
        while(fp.y + k16 < M && fp.y < N && A[fp.y + k16] === B[fp.y]){
            const prev = fp.id;
            ptr++;
            fp.id = ptr;
            fp.y += 1;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp;
    }
    while(fp1[delta + offset].y < N1){
        p = p + 1;
        for(let k17 = -p; k17 < delta; ++k17){
            fp1[k17 + offset] = snake(k17, fp1[k17 - 1 + offset], fp1[k17 + 1 + offset], offset, A1, B1);
        }
        for(let k1 = delta + p; k1 > delta; --k1){
            fp1[k1 + offset] = snake(k1, fp1[k1 - 1 + offset], fp1[k1 + 1 + offset], offset, A1, B1);
        }
        fp1[delta + offset] = snake(delta, fp1[delta - 1 + offset], fp1[delta + 1 + offset], offset, A1, B1);
    }
    return [
        ...prefixCommon.map((c)=>({
                type: DiffType.common,
                value: c
            })),
        ...backTrace(A1, B1, fp1[delta + offset], swapped1),
        ...suffixCommon.map((c)=>({
                type: DiffType.common,
                value: c
            })), 
    ];
}
function diffstr(A, B) {
    function unescape1(string) {
        return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
    }
    function tokenize(string, { wordDiff =false  } = {}) {
        if (wordDiff) {
            const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
            const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
            for(let i22 = 0; i22 < tokens.length - 1; i22++){
                if (!tokens[i22 + 1] && tokens[i22 + 2] && words.test(tokens[i22]) && words.test(tokens[i22 + 2])) {
                    tokens[i22] += tokens[i22 + 2];
                    tokens.splice(i22 + 1, 2);
                    i22--;
                }
            }
            return tokens.filter((token)=>token);
        } else {
            const tokens = [], lines = string.split(/(\n|\r\n)/);
            if (!lines[lines.length - 1]) {
                lines.pop();
            }
            for(let i23 = 0; i23 < lines.length; i23++){
                if (i23 % 2) {
                    tokens[tokens.length - 1] += lines[i23];
                } else {
                    tokens.push(lines[i23]);
                }
            }
            return tokens;
        }
    }
    function createDetails(line, tokens) {
        return tokens.filter(({ type: type9  })=>type9 === line.type || type9 === DiffType.common).map((result, i24, t)=>{
            if (result.type === DiffType.common && t[i24 - 1] && t[i24 - 1]?.type === t[i24 + 1]?.type && /\s+/.test(result.value)) {
                result.type = t[i24 - 1].type;
            }
            return result;
        });
    }
    const diffResult = diff(tokenize(`${unescape1(A)}\n`), tokenize(`${unescape1(B)}\n`));
    const added = [], removed = [];
    for (const result1 of diffResult){
        if (result1.type === DiffType.added) {
            added.push(result1);
        }
        if (result1.type === DiffType.removed) {
            removed.push(result1);
        }
    }
    const aLines = added.length < removed.length ? added : removed;
    const bLines = aLines === removed ? added : removed;
    for (const a of aLines){
        let tokens = [], b12;
        while(bLines.length){
            b12 = bLines.shift();
            tokens = diff(tokenize(a.value, {
                wordDiff: true
            }), tokenize(b12?.value ?? "", {
                wordDiff: true
            }));
            if (tokens.some(({ type: type10 , value  })=>type10 === DiffType.common && value.trim().length)) {
                break;
            }
        }
        a.details = createDetails(a, tokens);
        if (b12) {
            b12.details = createDetails(b12, tokens);
        }
    }
    return diffResult;
}
const CAN_NOT_DISPLAY = "[Cannot display]";
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function _format(v) {
    const { Deno  } = globalThis;
    return typeof Deno?.inspect === "function" ? Deno.inspect(v, {
        depth: Infinity,
        sorted: true,
        trailingComma: true,
        compact: false,
        iterableLimit: Infinity
    }) : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}
function createColor(diffType, { background =false  } = {}) {
    switch(diffType){
        case DiffType.added:
            return (s)=>background ? bgGreen(white(s)) : green(bold(s));
        case DiffType.removed:
            return (s)=>background ? bgRed(white(s)) : red(bold(s));
        default:
            return white;
    }
}
function createSign(diffType) {
    switch(diffType){
        case DiffType.added:
            return "+   ";
        case DiffType.removed:
            return "-   ";
        default:
            return "    ";
    }
}
function buildMessage(diffResult, { stringDiff =false  } = {}) {
    const messages1 = [], diffMessages = [];
    messages1.push("");
    messages1.push("");
    messages1.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
    messages1.push("");
    messages1.push("");
    diffResult.forEach((result)=>{
        const c = createColor(result.type);
        const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
                background: true
            })(detail.value) : detail.value).join("") ?? result.value;
        diffMessages.push(c(`${createSign(result.type)}${line}`));
    });
    messages1.push(...stringDiff ? [
        diffMessages.join("")
    ] : diffMessages);
    messages1.push("");
    return messages1;
}
function isKeyedCollection(x) {
    return [
        Symbol.iterator,
        "size"
    ].every((k18)=>k18 in x);
}
function equal(c, d) {
    const seen = new Map();
    return function compare1(a, b13) {
        if (a && b13 && (a instanceof RegExp && b13 instanceof RegExp || a instanceof URL && b13 instanceof URL)) {
            return String(a) === String(b13);
        }
        if (a instanceof Date && b13 instanceof Date) {
            const aTime = a.getTime();
            const bTime = b13.getTime();
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                return true;
            }
            return aTime === bTime;
        }
        if (typeof a === "number" && typeof b13 === "number") {
            return Number.isNaN(a) && Number.isNaN(b13) || a === b13;
        }
        if (Object.is(a, b13)) {
            return true;
        }
        if (a && typeof a === "object" && b13 && typeof b13 === "object") {
            if (a && b13 && !constructorsEqual(a, b13)) {
                return false;
            }
            if (a instanceof WeakMap || b13 instanceof WeakMap) {
                if (!(a instanceof WeakMap && b13 instanceof WeakMap)) return false;
                throw new TypeError("cannot compare WeakMap instances");
            }
            if (a instanceof WeakSet || b13 instanceof WeakSet) {
                if (!(a instanceof WeakSet && b13 instanceof WeakSet)) return false;
                throw new TypeError("cannot compare WeakSet instances");
            }
            if (seen.get(a) === b13) {
                return true;
            }
            if (Object.keys(a || {}).length !== Object.keys(b13 || {}).length) {
                return false;
            }
            if (isKeyedCollection(a) && isKeyedCollection(b13)) {
                if (a.size !== b13.size) {
                    return false;
                }
                let unmatchedEntries = a.size;
                for (const [aKey, aValue] of a.entries()){
                    for (const [bKey, bValue] of b13.entries()){
                        if (aKey === aValue && bKey === bValue && compare1(aKey, bKey) || compare1(aKey, bKey) && compare1(aValue, bValue)) {
                            unmatchedEntries--;
                        }
                    }
                }
                return unmatchedEntries === 0;
            }
            const merged = {
                ...a,
                ...b13
            };
            for (const key of [
                ...Object.getOwnPropertyNames(merged),
                ...Object.getOwnPropertySymbols(merged), 
            ]){
                if (!compare1(a && a[key], b13 && b13[key])) {
                    return false;
                }
                if (key in a && !(key in b13) || key in b13 && !(key in a)) {
                    return false;
                }
            }
            seen.set(a, b13);
            if (a instanceof WeakRef || b13 instanceof WeakRef) {
                if (!(a instanceof WeakRef && b13 instanceof WeakRef)) return false;
                return compare1(a.deref(), b13.deref());
            }
            return true;
        }
        return false;
    }(c, d);
}
function constructorsEqual(a, b14) {
    return a.constructor === b14.constructor || a.constructor === Object && !b14.constructor || !a.constructor && b14.constructor === Object;
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new AssertionError(msg);
    }
}
function assertEquals(actual, expected, msg) {
    if (equal(actual, expected)) {
        return;
    }
    let message = "";
    const actualString = _format(actual);
    const expectedString = _format(expected);
    try {
        const stringDiff = typeof actual === "string" && typeof expected === "string";
        const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
        const diffMsg = buildMessage(diffResult, {
            stringDiff
        }).join("\n");
        message = `Values are not equal:\n${diffMsg}`;
    } catch  {
        message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
    }
    if (msg) {
        message = msg;
    }
    throw new AssertionError(message);
}
function unreachable() {
    throw new AssertionError("unreachable");
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
function indexOf(source, pattern, fromIndex = 0) {
    if (fromIndex >= source.length) {
        return -1;
    }
    if (fromIndex < 0) {
        fromIndex = Math.max(0, source.length + fromIndex);
    }
    const s = pattern[0];
    for(let i25 = fromIndex; i25 < source.length; i25++){
        if (source[i25] !== s) continue;
        const pin = i25;
        let matched = 1;
        let j = i25;
        while(matched < pattern.length){
            j++;
            if (source[j] !== pattern[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === pattern.length) {
            return pin;
        }
    }
    return -1;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size3 = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size3);
    }
    constructor(rd, size4 = 4096){
        if (size4 < 16) {
            size4 = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size4), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i26 = 100; i26 > 0; i26--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert1(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p);
                const nread = rr ?? 0;
                assert1(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert1(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer5 = await this.readSlice(delim.charCodeAt(0));
        if (buffer5 === null) return null;
        return new TextDecoder().decode(buffer5);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert1(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert1(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i27 = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i27 >= 0) {
                i27 += s;
                slice = this.#buf.subarray(this.#r, this.#r + i27 + 1);
                this.#r += i27 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n6 && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n6 && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n6) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n6);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size5 = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size5);
    }
    constructor(writer, size6 = 4096){
        super(new Uint8Array(size6 <= 0 ? 4096 : size6));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data3) {
        if (this.err !== null) throw this.err;
        if (data3.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data3.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data3);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data3, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data3 = data3.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data3, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size7 = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size7);
    }
    constructor(writer, size8 = 4096){
        super(new Uint8Array(size8 <= 0 ? 4096 : size8));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data4) {
        if (this.err !== null) throw this.err;
        if (data4.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data4.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data4);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data4, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data4 = data4.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data4, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
function writeAllSync(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += w.writeSync(arr.subarray(nwritten));
    }
}
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    console.warn(message);
}
TextDecoder;
TextEncoder;
function intoCallbackAPIWithIntercept(func, interceptor, cb, ...args) {
    func(...args).then((value)=>cb && cb(null, interceptor(value)), (err)=>cb && cb(err));
}
function spliceOne(list1, index) {
    for(; index + 1 < list1.length; index++)list1[index] = list1[index + 1];
    list1.pop();
}
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function validateIntegerRange(value, name10, min1 = -2147483648, max = 2147483647) {
    if (!Number.isInteger(value)) {
        throw new Error(`${name10} must be 'an integer' but was ${value}`);
    }
    if (value < min1 || value > max) {
        throw new Error(`${name10} must be >= ${min1} && <= ${max}. Value was ${value}`);
    }
}
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object";
const _isFunctionLike = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp1(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp: isRegExp1,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp1,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
Symbol("kKeyObject");
Symbol("kKeyType");
const _toString1 = Object.prototype.toString;
const _isObjectLike1 = (value)=>value !== null && typeof value === "object";
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isBigUint64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object BigUint64Array]";
}
function isFloat32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float64Array]";
}
function isTypedArray(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike1(value) && reTypedTag.test(_toString1.call(value));
}
function isUint8Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8Array]";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp2 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1 ,  } = mod;
const codes = {};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const octalReg = /^[0-7]+$/;
const modeDesc = "must be a 32-bit unsigned integer or an octal string";
function parseFileMode(value, name11, def) {
    value ??= def;
    if (typeof value === "string") {
        if (!octalReg.test(value)) {
            throw new codes.ERR_INVALID_ARG_VALUE(name11, value, modeDesc);
        }
        value = Number.parseInt(value, 8);
    }
    validateInt32(value, name11, 0, 2 ** 32 - 1);
    return value;
}
const validateBuffer = hideStackFrames((buffer6, name12 = "buffer")=>{
    if (!isArrayBufferView(buffer6)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name12, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer6);
    }
});
const validateInteger = hideStackFrames((value, name13, min2 = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name13, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name13, "an integer", value);
    }
    if (value < min2 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name13, `>= ${min2} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name14, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name14, "Object", value);
    }
});
const validateInt32 = hideStackFrames((value, name15, min3 = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name15, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name15, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name15, `>= ${min3} && <= ${max}`, value);
    }
    if (value < min3 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name15, `>= ${min3} && <= ${max}`, value);
    }
});
const validateUint32 = hideStackFrames((value, name16, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name16, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name16, "an integer", value);
        }
        const min4 = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name16, `>= ${min4} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name16, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name17) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name17, "string", value);
    }
}
function validateBoolean(value, name18) {
    if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name18, "boolean", value);
    }
}
hideStackFrames((value, name19, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name19, value, reason);
    }
});
function validateEncoding(data5, encoding) {
    const normalizedEncoding = normalizeEncoding1(encoding);
    const length = data5.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new codes.ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
}
const validateCallback = hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
const validateAbortSignal = hideStackFrames((signal, name20)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name20, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name21)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name21, "Function", value);
    }
});
hideStackFrames((value, name22, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name22, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name22, value, reason);
    }
});
function guessHandleType(_fd) {
    notImplemented();
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i28 = 0;
                for(; i28 < length; ++i28){
                    ch = value.charCodeAt(i28);
                    if (i28 === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k19)=>!isArrayIndex(k19));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod1 = function() {
    return {
        guessHandleType: guessHandleType,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex,
        getOwnNonIndexProperties: getOwnNonIndexProperties
    };
}();
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret15 = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret15, null);
        for (const key of Object.keys(ret15)){
            if ((typeof ret15[key] === "object" || typeof ret15[key] === "function") && ret15[key] !== null) {
                delete ret15[key];
            }
        }
        ret15.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret15;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i29 = 0; i29 < optKeys.length; ++i29){
                const key = optKeys[i29];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)];
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last3 = 0;
    const lastIndex = str.length;
    for(let i30 = 0; i30 < lastIndex; i30++){
        const point = str.charCodeAt(i30);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last3 === i30) {
                result += meta[point];
            } else {
                result += `${str.slice(last3, i30)}${meta[point]}`;
            }
            last3 = i30 + 1;
        }
    }
    if (last3 !== lastIndex) {
        result += str.slice(last3);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret16 = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret16 !== context) {
                if (typeof ret16 !== "string") {
                    return formatValue(ctx, ret16, recurseTimes);
                }
                return ret16.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag1 = value[Symbol.toStringTag];
    if (typeof tag1 !== "string") {
        tag1 = "";
    }
    let base2 = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i31 = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag1 !== "" ? getPrefix(constructor, tag1, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size9 = value.size;
            const prefix = getPrefix(constructor, tag1, "Set", `(${size9})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size9 === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size10 = value.size;
            const prefix = getPrefix(constructor, tag1, "Map", `(${size10})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size10 === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            const size11 = value.length;
            const prefix = getPrefix(constructor, tag1, fallback, `(${size11})`);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size11);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag1);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag1);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag1 !== "") {
                braces[0] = `${getPrefix(constructor, tag1, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base2 = getFunctionBase(value, constructor, tag1);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base2, "special");
            }
        } else if (isRegExp2(value)) {
            base2 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix = getPrefix(constructor, tag1, "RegExp");
            if (prefix !== "RegExp ") {
                base2 = `${prefix}${base2}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base2, "regexp");
            }
        } else if (isDate1(value)) {
            base2 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix = getPrefix(constructor, tag1, "Date");
            if (prefix !== "Date ") {
                base2 = `${prefix}${base2}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base2, "date");
            }
        } else if (value instanceof Error) {
            base2 = formatError(value, constructor, tag1, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base2;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix = getPrefix(constructor, tag1, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix}{`;
            Array.prototype.unshift(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "DataView")}{`;
            Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base2 = getBoxedBase(value, ctx, keys, constructor, tag1);
            if (keys.length === 0 && protoProps === undefined) {
                return base2;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag1)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag1)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag1).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i31 = 0; i31 < keys.length; i31++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i31], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName = getCtxStyle(value, constructor, tag1).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base2 = base2 === "" ? reference : `${reference} ${base2}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base2, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push(ctx.seen, main);
        for (const key1 of keys){
            if (key1 === "constructor" || main.hasOwnProperty(key1) || depth !== 0 && keySet.has(key1)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key1);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key1, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push(output, value);
            }
        }
        Array.prototype.pop(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto2) {
    try {
        return object instanceof proto2;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag2, fallback, size12 = "") {
    if (constructor === null) {
        if (tag2 !== "" && fallback !== tag2) {
            return `[${fallback}${size12}: null prototype] [${tag2}] `;
        }
        return `[${fallback}${size12}: null prototype] `;
    }
    if (tag2 !== "" && constructor !== tag2) {
        return `${constructor}${size12} [${tag2}] `;
    }
    return `${constructor}${size12} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i32 = 0; i32 < len; i32++){
        if (!value.hasOwnProperty(i32)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i32);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i32, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag3) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag3) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag3, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k20 , 1: v  } of value){
        output.push(`${formatValue(ctx, k20, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i33 = 0; i33 < maxLength; ++i33){
        output[i33] = elementFormatter(ctx.stylize, value[i33]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type11, tag4) {
    if (tag4 !== `${type11} Iterator`) {
        if (tag4 !== "") {
            tag4 += "] [";
        }
        tag4 += `${type11} Iterator`;
    }
    return [
        `[${tag4}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag5) {
    const stringified = Function.prototype.toString(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag5);
        }
    }
    let type12 = "Function";
    if (isGeneratorFunction1(value)) {
        type12 = `Generator${type12}`;
    }
    if (isAsyncFunction1(value)) {
        type12 = `Async${type12}`;
    }
    let base3 = `[${type12}`;
    if (constructor === null) {
        base3 += " (null prototype)";
    }
    if (value.name === "") {
        base3 += " (anonymous)";
    } else {
        base3 += `: ${value.name}`;
    }
    base3 += "]";
    if (constructor !== type12 && constructor !== null) {
        base3 += ` ${constructor}`;
    }
    if (tag5 !== "" && constructor !== tag5) {
        base3 += ` [${tag5}]`;
    }
    return base3;
}
function formatError(err, constructor, tag6, ctx, keys) {
    const name23 = err.name != null ? String(err.name) : "Error";
    let len = name23.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name24 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name24);
            if (index !== -1 && stack.includes(err[name24])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name23.endsWith("Error") && stack.startsWith(name23) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag6, fallback).slice(0, -1);
        if (name23 !== prefix) {
            if (prefix.includes(name23)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name23}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos === 0 ? line : line.slice(pos);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer7;
    try {
        buffer7 = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer7, 0, Math.min(ctx.maxArrayLength, buffer7.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer7.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state13 , 1: result  } = value;
    if (state13 === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state13 === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type13, desc, original = value) {
    let name25, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff2 = ctx.compact !== true || type13 !== 0 ? 2 : 3;
        ctx.indentationLvl += diff2;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff2 === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff2;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type13 === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name25 = `[${ctx.stylize(tmp, "symbol")}]`;
    } else if (key === "__proto__") {
        name25 = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp = key.replace(strEscapeSequencesReplacer, escapeFn);
        name25 = `[${tmp}]`;
    } else if (keyStrRegExp.test(key)) {
        name25 = ctx.stylize(key, "name");
    } else {
        name25 = ctx.stylize(strEscape(key), "string");
    }
    return `${name25}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base4) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i34 = 0; i34 < output.length; i34++){
        if (ctx.colors) {
            totalLength += removeColors(output[i34]).length;
        } else {
            totalLength += output[i34].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base4 === "" || !base4.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i35 = 0; i35 < keys.length; i35++){
        try {
            output[i35] = formatProperty(ctx, value, recurseTimes, keys[i35], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i35]]: ""
            };
            output[i35] = formatProperty(ctx, tmp, recurseTimes, keys[i35], kObjectType);
            const pos = output[i35].lastIndexOf(" ");
            output[i35] = output[i35].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i36) {
    const keys = Object.keys(value);
    let index = i36;
    for(; i36 < keys.length && output.length < maxLength; i36++){
        const key = keys[i36];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending = remaining > 1 ? "s" : "";
            const message = `<${remaining} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag7) {
    let type14;
    if (isNumberObject1(value)) {
        type14 = "Number";
    } else if (isStringObject1(value)) {
        type14 = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type14 = "Boolean";
    } else if (isBigIntObject1(value)) {
        type14 = "BigInt";
    } else {
        type14 = "Symbol";
    }
    let base5 = `[${type14}`;
    if (type14 !== constructor) {
        if (constructor === null) {
            base5 += " (null prototype)";
        } else {
            base5 += ` (${constructor})`;
        }
    }
    base5 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag7 !== "" && tag7 !== constructor) {
        base5 += ` [${tag7}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base5;
    }
    return ctx.stylize(base5, type14.toLowerCase());
}
function getClassBase(value, constructor, tag8) {
    const hasName = value.hasOwnProperty("name");
    const name26 = hasName && value.name || "(anonymous)";
    let base6 = `class ${name26}`;
    if (constructor !== "Function" && constructor !== null) {
        base6 += ` [${constructor}]`;
    }
    if (tag8 !== "" && constructor !== tag8) {
        base6 += ` [${tag8}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base6 += ` extends ${superName}`;
        }
    } else {
        base6 += " extends [null prototype]";
    }
    return `[${base6}]`;
}
function reduceToSingleString(ctx, output, base7, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base7.length + 10;
                if (isBelowBreakLength(ctx, output, start, base7)) {
                    return `${base7 ? `${base7} ` : ""}${braces[0]} ${join1(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base7 ? `${base7} ` : ""}${braces[0]}${indentation}  ` + `${join1(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base7)) {
        return `${braces[0]}${base7 ? ` ${base7}` : ""} ${join1(output, ", ")} ` + braces[1];
    }
    const indentation = " ".repeat(ctx.indentationLvl);
    const ln = base7 === "" && braces[0].length === 1 ? " " : `${base7 ? ` ${base7}` : ""}\n${indentation}  `;
    return `${braces[0]}${ln}${join1(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function join1(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i37 = 0; i37 < lastIndex; i37++){
            str += output[i37];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i38 = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i38 < outputLength; i38++){
        const len = getStringWidth(output[i38], ctx.colors);
        dataLen[i38] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i39 = 0; i39 < columns; i39++){
            let lineMaxLength = 0;
            for(let j = i39; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i39] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i40 = 0; i40 < output.length; i40++){
                if (typeof value[i40] !== "number" && typeof value[i40] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i1 = 0; i1 < outputLength; i1 += columns){
            const max = Math.min(i1 + columns, outputLength);
            let str = "";
            let j = i1;
            for(; j < max - 1; j++){
                const padding = maxLineLength[j - i1] + output[j].length - dataLen[j];
                str += `${output[j]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding = maxLineLength[j - i1] + output[j].length - dataLen[j] - 2;
                str += output[j].padStart(padding, " ");
            } else {
                str += output[j];
            }
            Array.prototype.push(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state14) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i41 = 0;
    ctx.indentationLvl += 2;
    if (state14 === 0) {
        for(; i41 < maxLength; i41++){
            const pos = i41 * 2;
            output[i41] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i41 < maxLength; i41++){
            const pos = i41 * 2;
            const res = [
                formatValue(ctx, entries[pos], recurseTimes),
                formatValue(ctx, entries[pos + 1], recurseTimes), 
            ];
            output[i41] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state15) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i42 = 0; i42 < maxLength; i42++){
        output[i42] = formatValue(ctx, entries[i42], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state15 === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code2 = __char.codePointAt(0);
        if (isFullWidthCodePoint(code2)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code2)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code3)=>{
    return code3 >= 0x1100 && (code3 <= 0x115f || code3 === 0x2329 || code3 === 0x232a || code3 >= 0x2e80 && code3 <= 0x3247 && code3 !== 0x303f || code3 >= 0x3250 && code3 <= 0x4dbf || code3 >= 0x4e00 && code3 <= 0xa4c6 || code3 >= 0xa960 && code3 <= 0xa97c || code3 >= 0xac00 && code3 <= 0xd7a3 || code3 >= 0xf900 && code3 <= 0xfaff || code3 >= 0xfe10 && code3 <= 0xfe19 || code3 >= 0xfe30 && code3 <= 0xfe6b || code3 >= 0xff01 && code3 <= 0xff60 || code3 >= 0xffe0 && code3 <= 0xffe6 || code3 >= 0x1b000 && code3 <= 0x1b001 || code3 >= 0x1f200 && code3 <= 0x1f251 || code3 >= 0x1f300 && code3 <= 0x1f64f || code3 >= 0x20000 && code3 <= 0x3fffd);
};
const isZeroWidthCodePoint = (code4)=>{
    return code4 <= 0x1F || code4 >= 0x7F && code4 <= 0x9F || code4 >= 0x300 && code4 <= 0x36F || code4 >= 0x200B && code4 <= 0x200F || code4 >= 0x20D0 && code4 <= 0x20FF || code4 >= 0xFE00 && code4 <= 0xFE0F || code4 >= 0xFE20 && code4 <= 0xFE2F || code4 >= 0xE0100 && code4 <= 0xE01EF;
};
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
function once(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve7;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve7 = res;
        reject = rej;
    });
    return {
        promise,
        resolve: resolve7,
        reject
    };
}
new Set();
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve8, reject)=>{
            args.push((err, ...values3)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values3.length > 1) {
                    const obj = {};
                    for(let i43 = 0; i43 < argumentNames.length; i43++){
                        obj[argumentNames[i43]] = values3[i43];
                    }
                    resolve8(obj);
                } else {
                    resolve8(values3[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data6) {
        this.list[this.top] = data6;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data7) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data7);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    function processTicksAndRejections() {
        let tock;
        do {
            while(tock = queue.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core.runMicrotasks();
        }while (!queue.isEmpty())
        core.setHasTickScheduled(false);
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateCallback(callback);
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i44 = 0; i44 < args.length; i44++){
                    args_[i44] = args[i44];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick2(callback, ...args) {
    _nextTick(callback, ...args);
}
var State1;
(function(State2) {
    State2[State2["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State2[State2["PERCENT"] = 1] = "PERCENT";
    State2[State2["POSITIONAL"] = 2] = "POSITIONAL";
    State2[State2["PRECISION"] = 3] = "PRECISION";
    State2[State2["WIDTH"] = 4] = "WIDTH";
})(State1 || (State1 = {}));
var WorP;
(function(WorP1) {
    WorP1[WorP1["WIDTH"] = 0] = "WIDTH";
    WorP1[WorP1["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F1) {
    F1[F1["sign"] = 1] = "sign";
    F1[F1["mantissa"] = 2] = "mantissa";
    F1[F1["fractional"] = 3] = "fractional";
    F1[F1["esign"] = 4] = "esign";
    F1[F1["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State1.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format6, ...args){
        this.format = format6;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State1.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State1.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State1.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State1.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i45 = 0; i45 !== this.haveSeen.length; ++i45){
            if (!this.haveSeen[i45]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i45])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State1.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State1.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State1.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State1.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State1.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State1.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State1.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State1.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State1.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State1.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val = parseInt(c);
                        if (isNaN(val)) {
                            this.i--;
                            this.state = State1.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format7 = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format7[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format7[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i46 = 0; i46 !== arg.length; ++i46){
            if (i46 !== 0) str += ", ";
            str += this._handleVerb(arg[i46]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State1.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        let esign = m[F.esign];
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n1) {
        const special = this.fmtFloatSpecial(n1);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i47 = 0; i47 !== Math.abs(e) - 1; ++i47){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n1));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n1 < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i48 = 0; i48 !== end; ++i48){
                        if (i48 !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i48) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format8, ...args) {
    const printf1 = new Printf(format8, ...args);
    return printf1.doPrintf();
}
let debugImpls;
let testEnabled;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled = (str)=>debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled = ()=>false;
    }
}
function emitWarningIfNeeded(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop = ()=>{};
function debuglogImpl(enabled1, set) {
    if (debugImpls[set] === undefined) {
        if (enabled1) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect(arg)).join(" ");
                console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }
    return debugImpls[set];
}
function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled2 = testEnabled(set);
    }
    let debug1 = (...args)=>{
        init();
        debug1 = debuglogImpl(enabled2, set);
        if (typeof cb === "function") {
            cb(debug1);
        }
        return debug1(...args);
    };
    let enabled2;
    let test = ()=>{
        init();
        test = ()=>enabled2;
        return enabled2;
    };
    const logger = (...args)=>debug1(...args);
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let state = "";
if (Deno.permissions) {
    state = (await Deno.permissions.query({
        name: "env",
        variable: "NODE_DEBUG"
    })).state;
}
if (state === "granted") {
    initializeDebugEnv(Deno.env.get("NODE_DEBUG") ?? "");
} else {
    initializeDebugEnv("");
}
const osType = (()=>{
    const { Deno  } = globalThis;
    if (typeof Deno?.build?.os === "string") {
        return Deno.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
function uvTranslateSysError(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const os = {
    UV_UDP_REUSEADDR: 4,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
const fs = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto1 = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod2 = {
    os: os,
    fs: fs,
    crypto: crypto1,
    zlib: zlib,
    trace: trace
};
const UV_EEXIST = os.errno.EEXIST;
const UV_ENOENT = os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error2]])=>[
        error2,
        status
    ]);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code5]])=>[
        code5,
        status
    ]);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code6]])=>[
        code6,
        status
    ]);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
    if (osType === "windows") {
        const code7 = uvTranslateSysError(sysErrno);
        return codeMap.get(code7) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const mod3 = {
    UV_EEXIST: UV_EEXIST,
    UV_ENOENT: UV_ENOENT,
    errorMap: errorMap,
    codeMap: codeMap,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno
};
var Encodings;
(function(Encodings1) {
    Encodings1[Encodings1["ASCII"] = 0] = "ASCII";
    Encodings1[Encodings1["UTF8"] = 1] = "UTF8";
    Encodings1[Encodings1["BASE64"] = 2] = "BASE64";
    Encodings1[Encodings1["UCS2"] = 3] = "UCS2";
    Encodings1[Encodings1["BINARY"] = 4] = "BINARY";
    Encodings1[Encodings1["HEX"] = 5] = "HEX";
    Encodings1[Encodings1["BUFFER"] = 6] = "BUFFER";
    Encodings1[Encodings1["BASE64URL"] = 7] = "BASE64URL";
    Encodings1[Encodings1["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
const __default1 = {
    encodings
};
const mod4 = {
    encodings: encodings,
    default: __default1
};
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer8, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer8.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer8.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer8[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer8.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer9, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer9.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer9, byteOffset);
    }
    if (buffer9.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOf(targetBuffer, buffer9, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const __default2 = {
    indexOfBuffer,
    indexOfNumber
};
const mod5 = {
    indexOfBuffer: indexOfBuffer,
    indexOfNumber: indexOfNumber,
    numberToBytes: numberToBytes,
    default: __default2
};
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode(data8) {
    const uint8 = typeof data8 === "string" ? new TextEncoder().encode(data8) : data8 instanceof Uint8Array ? data8 : new Uint8Array(data8);
    let result = "", i49;
    const l = uint8.length;
    for(i49 = 2; i49 < l; i49 += 3){
        result += base64abc[uint8[i49 - 2] >> 2];
        result += base64abc[(uint8[i49 - 2] & 0x03) << 4 | uint8[i49 - 1] >> 4];
        result += base64abc[(uint8[i49 - 1] & 0x0f) << 2 | uint8[i49] >> 6];
        result += base64abc[uint8[i49] & 0x3f];
    }
    if (i49 === l + 1) {
        result += base64abc[uint8[i49 - 2] >> 2];
        result += base64abc[(uint8[i49 - 2] & 0x03) << 4];
        result += "==";
    }
    if (i49 === l) {
        result += base64abc[uint8[i49 - 2] >> 2];
        result += base64abc[(uint8[i49 - 2] & 0x03) << 4 | uint8[i49 - 1] >> 4];
        result += base64abc[(uint8[i49 - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size13 = binString.length;
    const bytes = new Uint8Array(size13);
    for(let i50 = 0; i50 < size13; i50++){
        bytes[i50] = binString.charCodeAt(i50);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data9) {
    return convertBase64ToBase64url(encode(data9));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i51 = 0; i51 < str.length; ++i51){
        byteArray.push(str.charCodeAt(i51) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode1(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i52;
    for(i52 = 0; i52 < byteArray.length; i52++){
        const a = Number.parseInt(str[i52 * 2], 16);
        const b15 = Number.parseInt(str[i52 * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b15)) {
            break;
        }
        byteArray[i52] = a << 4 | b15;
    }
    return new Uint8Array(i52 === byteArray.length ? byteArray : byteArray.slice(0, i52));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i53 = 0; i53 < str.length; ++i53){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i53);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret17 = "";
    for(let i54 = 0; i54 < bytes.length; ++i54){
        ret17 += String.fromCharCode(bytes[i54] & 127);
    }
    return ret17;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i55 = 0; i55 < bytes.length - 1; i55 += 2){
        res += String.fromCharCode(bytes[i55] + bytes[i55 + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last4 = buf[offset + 5];
    if (first === undefined || last4 === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last4 * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last5 = buf[offset + 4];
    if (first === undefined || last5 === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last5 * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last6 = buf[offset + 2];
    if (first === undefined || last6 === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last6 * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last7 = buf[offset + 5];
    if (first === undefined || last7 === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last7;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last8 = buf[offset + 4];
    if (first === undefined || last8 === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last8;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last9 = buf[offset + 2];
    if (first === undefined || last9 === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last9;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last10 = this[offset + 1];
    if (first === undefined || last10 === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last10;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last11 = this[offset + 3];
    if (first === undefined || last11 === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last11;
}
function readDoubleBackwards(buffer10, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer10[offset];
    const last12 = buffer10[offset + 7];
    if (first === undefined || last12 === undefined) {
        boundsError(offset, buffer10.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer10[++offset];
    uInt8Float64Array[5] = buffer10[++offset];
    uInt8Float64Array[4] = buffer10[++offset];
    uInt8Float64Array[3] = buffer10[++offset];
    uInt8Float64Array[2] = buffer10[++offset];
    uInt8Float64Array[1] = buffer10[++offset];
    uInt8Float64Array[0] = last12;
    return float64Array[0];
}
function readDoubleForwards(buffer11, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer11[offset];
    const last13 = buffer11[offset + 7];
    if (first === undefined || last13 === undefined) {
        boundsError(offset, buffer11.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer11[++offset];
    uInt8Float64Array[2] = buffer11[++offset];
    uInt8Float64Array[3] = buffer11[++offset];
    uInt8Float64Array[4] = buffer11[++offset];
    uInt8Float64Array[5] = buffer11[++offset];
    uInt8Float64Array[6] = buffer11[++offset];
    uInt8Float64Array[7] = last13;
    return float64Array[0];
}
function writeDoubleForwards(buffer12, val, offset = 0) {
    val = +val;
    checkBounds(buffer12, offset, 7);
    float64Array[0] = val;
    buffer12[offset++] = uInt8Float64Array[0];
    buffer12[offset++] = uInt8Float64Array[1];
    buffer12[offset++] = uInt8Float64Array[2];
    buffer12[offset++] = uInt8Float64Array[3];
    buffer12[offset++] = uInt8Float64Array[4];
    buffer12[offset++] = uInt8Float64Array[5];
    buffer12[offset++] = uInt8Float64Array[6];
    buffer12[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer13, val, offset = 0) {
    val = +val;
    checkBounds(buffer13, offset, 7);
    float64Array[0] = val;
    buffer13[offset++] = uInt8Float64Array[7];
    buffer13[offset++] = uInt8Float64Array[6];
    buffer13[offset++] = uInt8Float64Array[5];
    buffer13[offset++] = uInt8Float64Array[4];
    buffer13[offset++] = uInt8Float64Array[3];
    buffer13[offset++] = uInt8Float64Array[2];
    buffer13[offset++] = uInt8Float64Array[1];
    buffer13[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer14, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer14[offset];
    const last14 = buffer14[offset + 3];
    if (first === undefined || last14 === undefined) {
        boundsError(offset, buffer14.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer14[++offset];
    uInt8Float32Array[1] = buffer14[++offset];
    uInt8Float32Array[0] = last14;
    return float32Array[0];
}
function readFloatForwards(buffer15, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer15[offset];
    const last15 = buffer15[offset + 3];
    if (first === undefined || last15 === undefined) {
        boundsError(offset, buffer15.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer15[++offset];
    uInt8Float32Array[2] = buffer15[++offset];
    uInt8Float32Array[3] = last15;
    return float32Array[0];
}
function writeFloatForwards(buffer16, val, offset = 0) {
    val = +val;
    checkBounds(buffer16, offset, 3);
    float32Array[0] = val;
    buffer16[offset++] = uInt8Float32Array[0];
    buffer16[offset++] = uInt8Float32Array[1];
    buffer16[offset++] = uInt8Float32Array[2];
    buffer16[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer17, val, offset = 0) {
    val = +val;
    checkBounds(buffer17, offset, 3);
    float32Array[0] = val;
    buffer17[offset++] = uInt8Float32Array[3];
    buffer17[offset++] = uInt8Float32Array[2];
    buffer17[offset++] = uInt8Float32Array[1];
    buffer17[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last16 = buf[offset + 2];
    if (first === undefined || last16 === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last16 * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last17 = buf[offset + 4];
    if (first === undefined || last17 === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last17 | (last17 & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last18 = buf[offset + 5];
    if (first === undefined || last18 === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last18 * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last19 = buf[offset + 2];
    if (first === undefined || last19 === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last19;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last20 = buf[offset + 5];
    if (first === undefined || last20 === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last20;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last21 = buf[offset + 4];
    if (first === undefined || last21 === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last21;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type15) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type15);
        throw new codes.ERR_OUT_OF_RANGE(type15 || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type15 || "offset", `>= ${type15 ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name27) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name27, "number", value);
    }
}
function checkBounds(buf, offset, byteLength1) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength1] === undefined) {
        boundsError(offset, buf.length - (byteLength1 + 1));
    }
}
function checkInt(value, min5, max, buf, offset, byteLength2) {
    if (value > max || value < min5) {
        const n = typeof min5 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min5 === 0 || min5 === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min5}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min6, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min6) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min6} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min7, max) {
    value = +value;
    checkInt(value, min7, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min8, max) {
    value = +value;
    checkInt(value, min8, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min9, max) {
    value = +value;
    checkInt(value, min9, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min10, max) {
    value = +value;
    checkInt(value, min10, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min11, max) {
    value = +value;
    checkInt(value, min11, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min12, max) {
    value = +value;
    checkInt(value, min12, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min13, max) {
    value = +value;
    checkInt(value, min13, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min14, max) {
    value = +value;
    checkInt(value, min14, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name28, min15 = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name28, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name28, "an integer", value);
    }
    if (value < min15 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name28, `>= ${min15} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min16, max) {
    value = +value;
    checkInt(value, min16, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min17, max) {
    value = +value;
    checkInt(value, min17, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min18, max) {
    value = +value;
    checkInt(value, min18, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min19, max) {
    value = +value;
    checkInt(value, min19, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol1 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b16 = fromObject(value);
        if (b16) {
            return b16;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size14) {
    validateNumber(size14, "size");
    if (!(size14 >= 0 && size14 <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size14);
    }
}
function _alloc(size15, fill, encoding) {
    assertSize(size15);
    const buffer18 = createBuffer(size15);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer18.fill(fill, encoding);
    }
    return buffer18;
}
Buffer.alloc = function alloc(size16, fill, encoding) {
    return _alloc(size16, fill, encoding);
};
function _allocUnsafe(size17) {
    assertSize(size17);
    return createBuffer(size17 < 0 ? 0 : checked(size17) | 0);
}
Buffer.allocUnsafe = function allocUnsafe(size18) {
    return _allocUnsafe(size18);
};
Buffer.allocUnsafeSlow = function allocUnsafeSlow(size19) {
    return _allocUnsafe(size19);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i56 = 0; i56 < length; i56 += 1){
        buf[i56] = array[i56] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer.isBuffer = function isBuffer(b17) {
    return b17 != null && b17._isBuffer === true && b17 !== Buffer.prototype;
};
Buffer.compare = function compare(a, b18) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b18, Uint8Array)) {
        b18 = Buffer.from(b18, b18.offset, b18.byteLength);
    }
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b18)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b18) {
        return 0;
    }
    let x = a.length;
    let y = b18.length;
    for(let i57 = 0, len = Math.min(x, y); i57 < len; ++i57){
        if (a[i57] !== b18[i57]) {
            x = a[i57];
            y = b18[i57];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding1(encoding) !== undefined;
};
Buffer.concat = function concat(list2, length) {
    if (!Array.isArray(list2)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list2);
    }
    if (list2.length === 0) {
        return Buffer.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i58 = 0; i58 < list2.length; i58++){
            if (list2[i58].length) {
                length += list2[i58].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer19 = Buffer.allocUnsafe(length);
    let pos = 0;
    for(let i59 = 0; i59 < list2.length; i59++){
        const buf = list2[i59];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i59}]`, [
                "Buffer",
                "Uint8Array"
            ], list2[i59]);
        }
        pos += _copyActual(buf, buffer19, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer19.fill(0, pos, length);
    }
    return buffer19;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer.byteLength = byteLength;
Buffer.prototype._isBuffer = true;
function swap(b19, n, m) {
    const i60 = b19[n];
    b19[n] = b19[m];
    b19[m] = i60;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i61 = 0; i61 < len; i61 += 2){
        swap(this, i61, i61 + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i62 = 0; i62 < len; i62 += 4){
        swap(this, i62, i62 + 3);
        swap(this, i62 + 1, i62 + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i63 = 0; i63 < len; i63 += 8){
        swap(this, i63, i63 + 7);
        swap(this, i63 + 1, i63 + 6);
        swap(this, i63 + 2, i63 + 5);
        swap(this, i63 + 3, i63 + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b20) {
    if (!isUint8Array(b20)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b20);
    }
    if (this === b20) {
        return true;
    }
    return Buffer.compare(this, b20) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol1) {
    Buffer.prototype[customInspectSymbol1] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i64 = 0; i64 < len; ++i64){
        if (thisCopy[i64] !== targetCopy[i64]) {
            x = thisCopy[i64];
            y = targetCopy[i64];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer20, val, byteOffset, encoding, dir) {
    validateBuffer(buffer20);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer20.length || buffer20.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer20, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer20, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer20, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer21 = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer21, Buffer.prototype);
    return buffer21;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i65 = start;
    while(i65 < end){
        const firstByte = buf[i65];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i65 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i65 + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i65 + 1];
                    thirdByte = buf[i65 + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i65 + 1];
                    thirdByte = buf[i65 + 2];
                    fourthByte = buf[i65 + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i65 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i66 = 0;
    while(i66 < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i66, i66 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret18 = "";
    end = Math.min(buf.length, end);
    for(let i67 = start; i67 < end; ++i67){
        ret18 += String.fromCharCode(buf[i67]);
    }
    return ret18;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i68 = start; i68 < end; ++i68){
        out += hexSliceLookupTable[buf[i68]];
    }
    return out;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength1 === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength1 === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength1 === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength1 === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength1 === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength1 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength1, 6, "byteLength");
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength2 === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength2 === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength2 === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength2 === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength2 === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength2 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength2, 6, "byteLength");
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = readUInt16BE;
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last22 = this[offset + 1];
    if (first === undefined || last22 === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last22 * 2 ** 8;
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last23 = this[offset + 3];
    if (first === undefined || last23 === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last23 * 2 ** 24;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = readUInt32BE;
Buffer.prototype.readBigUint64LE = Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last24 = this[offset + 7];
    if (first === void 0 || last24 === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last24 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUint64BE = Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last25 = this[offset + 7];
    if (first === void 0 || last25 === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last25;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength3 === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength3 === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength3 === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength3 === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength3 === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength3 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength3, 6, "byteLength");
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength4) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength4 === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength4 === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength4 === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength4 === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength4 === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength4 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength4, 6, "byteLength");
};
Buffer.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last26 = this[offset + 1];
    if (first === undefined || last26 === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last26 * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last27 = this[offset + 1];
    if (first === undefined || last27 === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last27;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last28 = this[offset + 3];
    if (first === undefined || last28 === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last28 << 24);
};
Buffer.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last29 = this[offset + 3];
    if (first === undefined || last29 === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last29;
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last30 = this[offset + 7];
    if (first === void 0 || last30 === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last30 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last31 = this[offset + 7];
    if (first === void 0 || last31 === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last31);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5) {
    if (byteLength5 === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength5 === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength5 === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength5 === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength5 === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength5 === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength5, 6, "byteLength");
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6) {
    if (byteLength6 === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength6 === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength6 === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength6 === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength6 === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength6 === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength6, 6, "byteLength");
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min20, max) {
    checkIntBI(value, min20, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min21, max) {
    checkIntBI(value, min21, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUint64LE = Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUint64BE = Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7) {
    if (byteLength7 === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength7 === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength7 === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength7 === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength7 === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength7 === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength7, 6, "byteLength");
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8) {
    if (byteLength8 === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength8 === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength8 === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength8 === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength8 === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength8 === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength8, 6, "byteLength");
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code8 = val.charCodeAt(0);
            if (encoding === "utf8" && code8 < 128 || encoding === "latin1") {
                val = code8;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i69;
    if (typeof val === "number") {
        for(i69 = start; i69 < end; ++i69){
            this[i69] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i69 = 0; i69 < end - start; ++i69){
            this[i69 + start] = bytes[i69 % len];
        }
    }
    return this;
};
function checkBounds1(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min22, max, buf, offset, byteLength2) {
    if (value > max || value < min22) {
        const n = typeof min22 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min22 === 0 || min22 === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min22}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds1(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i70 = 0; i70 < length; ++i70){
        codePoint = string.charCodeAt(i70);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i70 + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, length) {
    let i71;
    for(i71 = 0; i71 < length; ++i71){
        if (i71 + offset >= dst.length || i71 >= src.length) {
            break;
        }
        dst[i71 + offset] = src[i71];
    }
    return i71;
}
function isInstance(obj, type16) {
    return obj instanceof type16 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type16.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i72 = 0; i72 < 16; ++i72){
        const i16 = i72 * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i72] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType;
(function(valueType1) {
    valueType1[valueType1["noIterator"] = 0] = "noIterator";
    valueType1[valueType1["isArray"] = 1] = "isArray";
    valueType1[valueType1["isSet"] = 2] = "isSet";
    valueType1[valueType1["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function innerDeepEqual(val1, val2, strict, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError1(val1) || val1 instanceof Error) {
        if (!isNativeError1(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()).toString();
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter);
        const keysVal2 = getOwnNonIndexProperties(val2, filter);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.noIterator, keysVal1);
    } else if (isSet1(val1)) {
        if (!isSet1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isSet);
    } else if (isMap1(val1)) {
        if (!isMap1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isMap);
    } else if (isAnyArrayBuffer1(val1)) {
        if (!isAnyArrayBuffer1(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive1(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet1(val2) || isMap1(val2) || isDate1(val2) || isRegExp2(val2) || isAnyArrayBuffer1(val2) || isBoxedPrimitive1(val2) || isNativeError1(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i73 = 0;
    for(; i73 < aKeys.length; i73++){
        if (!val2.propertyIsEnumerable(aKeys[i73])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i73 = 0; i73 < symbolKeysA.length; i73++){
                const key = symbolKeysA[i73];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a, b21) {
    return a.source === b21.source && a.flags === b21.flags && a.lastIndex === b21.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i74 = 0; i74 < arr1.byteLength; i74++){
        if (arr1[i74] !== arr2[i74]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b22) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b22).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b22).length) {
        return false;
    }
    if (isNumberObject1(a)) {
        return isNumberObject1(b22) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b22));
    }
    if (isStringObject1(a)) {
        return isStringObject1(b22) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b22);
    }
    if (isBooleanObject1(a)) {
        return isBooleanObject1(b22) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b22);
    }
    if (isBigIntObject1(a)) {
        return isBigIntObject1(b22) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b22);
    }
    if (isSymbolObject1(a)) {
        return isSymbolObject1(b22) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b22);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key));
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
    let i75 = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i75 < obj1.length; i75++){
            if (obj1.hasOwnProperty(i75)) {
                if (!obj2.hasOwnProperty(i75) || !innerDeepEqual(obj1[i75], obj2[i75], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i75)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i75 < keys1.length; i75++){
                    const key = keys1[i75];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i75 = 0; i75 < keys.length; i75++){
        const key = keys[i75];
        if (!innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item of set2){
            if (typeof item === "object" && item !== null) {
                if (!setHasEqualElement(set, item, strict, memos)) return false;
            } else if (!strict && !set1.has(item) && !setHasEqualElement(set, item, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key , 1: item  } of map2){
            if (typeof key === "object" && key !== null) {
                if (!mapHasEqualEntry(set, map1, key, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key) || !innerDeepEqual(map1.get(key), item, false, memos)) && !mapHasEqualEntry(set, map1, key, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code9) {
    if (typeof code9 !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code9);
    }
    if (code9 >= 0 || !NumberIsSafeInteger(code9)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code9);
    }
    return errorMap.get(code9)?.[0];
}
const { errno: { ENOTDIR , ENOENT  } ,  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
class AbortError extends Error {
    code;
    constructor(){
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator(val) {
    let res = "";
    let i76 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i76 >= start + 4; i76 -= 3){
        res = `_${val.slice(i76 - 3, i76)}${res}`;
    }
    return `${val.slice(0, i76)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code10 , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code10}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code10;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function errnoException(err, syscall, original) {
    const code11 = getSystemErrorName(err);
    const message = original ? `${syscall} ${code11} ${original}` : `${syscall} ${code11}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code11;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name29) {
    return errorMap.get(name29);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
const uvException = hideStackFrames(function uvException(ctx) {
    const { 0: code12 , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code12}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path6;
    let dest;
    if (ctx.path) {
        path6 = ctx.path.toString();
        message += ` '${path6}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code12;
    if (path6) {
        err.path = path6;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code13 = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code13}${details}`);
    ex.errno = err;
    ex.code = code13;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function(code14, syscall, hostname2) {
    let errno;
    if (typeof code14 === "number") {
        errno = code14;
        if (code14 === codeMap.get("EAI_NODATA") || code14 === codeMap.get("EAI_NONAME")) {
            code14 = "ENOTFOUND";
        } else {
            code14 = getSystemErrorName(code14);
        }
    }
    const message = `${syscall} ${code14}${hostname2 ? ` ${hostname2}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code14;
    ex.syscall = syscall;
    if (hostname2) {
        ex.hostname = hostname2;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name30, code15, message){
        super(message);
        this.code = code15;
        this.name = name30;
        this.stack = this.stack && `${name30} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code16, message){
        super(Error.prototype.name, code16, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code17, message){
        super(RangeError.prototype.name, code17, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code18, message){
        super(TypeError.prototype.name, code18, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeURIError extends NodeErrorAbstraction {
    constructor(code19, message){
        super(URIError.prototype.name, code19, message);
        Object.setPrototypeOf(this, URIError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
const ERR_FS_EISDIR = makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name31, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name31.endsWith(" argument")) {
        msg += `${name31} `;
    } else {
        const type17 = name31.includes(".") ? "property" : "argument";
        msg += `"${name31}" ${type17} `;
    }
    msg += "must be ";
    const types2 = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types2.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types2.indexOf("object");
        if (pos !== -1) {
            types2.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types2.length > 0) {
        if (types2.length > 2) {
            const last32 = types2.pop();
            msg += `one of type ${types2.join(", ")}, or ${last32}`;
        } else if (types2.length === 2) {
            msg += `one of type ${types2[0]} or ${types2[1]}`;
        } else {
            msg += `of type ${types2[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last33 = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last33}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last34 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last34}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name32, expected, actual){
        const msg = createInvalidArgType(name32, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name33, expected, actual){
        const msg = createInvalidArgType(name33, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name34, value, reason = "is invalid"){
        const type18 = name34.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type18} '${name34}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name35, value, reason = "is invalid"){
        const type19 = name35.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type19} '${name35}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert1(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name: name36  } = this;
        this.name = `${name36} [${this.code}]`;
        this.stack;
        this.name = name36;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name37){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name37 ? `"${name37}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_FS_INVALID_SYMLINK_TYPE extends NodeError {
    constructor(x){
        super("ERR_FS_INVALID_SYMLINK_TYPE", `Symlink type must be one of "dir", "file", or "junction". Received "${x}"`);
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
    }
}
class ERR_INVALID_FILE_URL_HOST extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FILE_URL_HOST", `File URL host must be "localhost" or empty on ${x}`);
    }
}
class ERR_INVALID_FILE_URL_PATH extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FILE_URL_PATH", `File URL path ${x}`);
    }
}
class ERR_INVALID_OPT_VALUE_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_OPT_VALUE_ENCODING", `The value "${x}" is invalid for option "encoding"`);
    }
}
class ERR_INVALID_URI extends NodeURIError {
    constructor(){
        super("ERR_INVALID_URI", `URI malformed`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED extends NodeError {
    constructor(x){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap1 = (a)=>`"${a}"`;
        args = args.map((a)=>Array.isArray(a) ? a.map(wrap1).join(" or ") : wrap1(a));
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_MULTIPLE_CALLBACK extends NodeError {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name38, port, allowZero = true){
        assert1(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name38} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_STREAM_ALREADY_FINISHED extends NodeError {
    constructor(x){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE extends NodeError {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES extends NodeTypeError {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF extends NodeError {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends NodeError {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRITE_AFTER_END extends NodeError {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
class ERR_UNKNOWN_SIGNAL extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
    }
}
function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}
class ERR_INVALID_RETURN_VALUE extends NodeTypeError {
    constructor(input, name39, value){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name39}" function but got ${buildReturnPropertyType(value)}.`);
    }
}
class ERR_INVALID_URL_SCHEME extends NodeTypeError {
    constructor(expected){
        expected = Array.isArray(expected) ? expected : [
            expected
        ];
        const res = expected.length === 2 ? `one of scheme ${expected[0]} or ${expected[1]}` : `of scheme ${expected[0]}`;
        super("ERR_INVALID_URL_SCHEME", `The URL must be ${res}`);
    }
}
class ERR_INTERNAL_ASSERTION extends NodeError {
    constructor(message){
        const suffix = "This is caused by either a bug in Node.js " + "or incorrect usage of Node.js internals.\n" + "Please open an issue with this stack trace at " + "https://github.com/nodejs/node/issues\n";
        super("ERR_INTERNAL_ASSERTION", message === undefined ? suffix : `${message}\n${suffix}`);
    }
}
class ERR_FS_RMDIR_ENOTDIR extends NodeSystemError {
    constructor(path7){
        const code20 = isWindows ? "ENOENT" : "ENOTDIR";
        const ctx = {
            message: "not a directory",
            path: path7,
            syscall: "rmdir",
            code: code20,
            errno: isWindows ? ENOENT : ENOTDIR
        };
        super(code20, ctx, "Path is not a directory");
    }
}
function denoErrorToNodeError(e, ctx) {
    const errno = extractOsErrorNumberFromErrorMessage(e);
    if (typeof errno === "undefined") {
        return e;
    }
    const ex = uvException({
        errno: mapSysErrnoToUvErrno(errno),
        ...ctx
    });
    return ex;
}
function extractOsErrorNumberFromErrorMessage(e) {
    const match = e instanceof Error ? e.message.match(/\(os error (\d+)\)/) : false;
    if (match) {
        return +match[1];
    }
    return undefined;
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError, 
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once1;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
function checkListener(listener) {
    validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
EventEmitter.setMaxListeners = function(n = defaultMaxListeners, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n;
    } else {
        for(let i77 = 0; i77 < eventTargets.length; i77++){
            const target = eventTargets[i77];
            if (target instanceof EventTarget) {
                target[kMaxEventTargetListeners] = n;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
};
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type20, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err, type20, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr(ee, err, type21, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err, type21, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type22, ...args) {
    let doError = type22 === "error";
    const events1 = this._events;
    if (events1 !== undefined) {
        if (doError && events1[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events1.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events1[type22];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type22, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i78 = 0; i78 < len; ++i78){
            const result = listeners[i78].apply(this, args);
            if (result !== undefined && result !== null) {
                addCatch(this, result, type22, args);
            }
        }
    }
    return true;
};
function _addListener(target, type23, listener, prepend) {
    let m;
    let events2;
    let existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === undefined) {
        events2 = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events2.newListener !== undefined) {
            target.emit("newListener", type23, listener.listener ?? listener);
            events2 = target._events;
        }
        existing = events2[type23];
    }
    if (existing === undefined) {
        events2[type23] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events2[type23] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type23)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type23;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type24, listener) {
    return _addListener(this, type24, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type25, listener) {
    return _addListener(this, type25, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type26, listener) {
    const state16 = {
        fired: false,
        wrapFn: undefined,
        target,
        type: type26,
        listener
    };
    const wrapped = onceWrapper.bind(state16);
    wrapped.listener = listener;
    state16.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type27, listener) {
    checkListener(listener);
    this.on(type27, _onceWrap(this, type27, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type28, listener) {
    checkListener(listener);
    this.prependListener(type28, _onceWrap(this, type28, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type29, listener) {
    checkListener(listener);
    const events3 = this._events;
    if (events3 === undefined) {
        return this;
    }
    const list3 = events3[type29];
    if (list3 === undefined) {
        return this;
    }
    if (list3 === listener || list3.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events3[type29];
            if (events3.removeListener) {
                this.emit("removeListener", type29, list3.listener || listener);
            }
        }
    } else if (typeof list3 !== "function") {
        let position = -1;
        for(let i79 = list3.length - 1; i79 >= 0; i79--){
            if (list3[i79] === listener || list3[i79].listener === listener) {
                position = i79;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list3.shift();
        } else {
            spliceOne(list3, position);
        }
        if (list3.length === 1) {
            events3[type29] = list3[0];
        }
        if (events3.removeListener !== undefined) {
            this.emit("removeListener", type29, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type30) {
    const events4 = this._events;
    if (events4 === undefined) {
        return this;
    }
    if (events4.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events4[type30] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events4[type30];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events4)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events4[type30];
    if (typeof listeners === "function") {
        this.removeListener(type30, listeners);
    } else if (listeners !== undefined) {
        for(let i80 = listeners.length - 1; i80 >= 0; i80--){
            this.removeListener(type30, listeners[i80]);
        }
    }
    return this;
};
function _listeners(target, type31, unwrap2) {
    const events5 = target._events;
    if (events5 === undefined) {
        return [];
    }
    const evlistener = events5[type31];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap2 ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap2 ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type32) {
    return _listeners(this, type32, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type33) {
    return _listeners(this, type33, false);
};
EventEmitter.listenerCount = function(emitter, type34) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type34);
    }
    return listenerCount.call(emitter, type34);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type35) {
    const events6 = this._events;
    if (events6 !== undefined) {
        const evlistener = events6[type35];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret19 = arrayClone(arr);
    for(let i81 = 0; i81 < ret19.length; ++i81){
        const orig = ret19[i81].listener;
        if (typeof orig === "function") {
            ret19[i81] = orig;
        }
    }
    return ret19;
}
function getEventListeners(emitterOrTarget, type36) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type36);
    }
    if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type36);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once1(emitter, name40, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve9, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name40, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve9(args);
        };
        eventTargetAgnosticAddListener(emitter, name40, resolver, {
            once: true
        });
        if (name40 !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name40, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name41, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name41, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name41, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name42, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name42, listener);
        } else {
            emitter.on(name42, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name42, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error3 = null;
    let finished1 = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error3) {
                const p = Promise.reject(error3);
                error3 = null;
                return p;
            }
            if (finished1) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve10, reject) {
                unconsumedPromises.push({
                    resolve: resolve10,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished1 = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
            }
            error3 = err;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished1 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error3 = err;
        }
        iterator.return();
    }
}
const { hasOwn  } = Object;
function get2(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v = get2(obj, key);
    assert1(v != null);
    return v;
}
function isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get2(o, key) ?? {};
    });
    const key1 = keys[keys.length - 1];
    return key1 in o;
}
function parse(args, { "--": doubleDash = false , alias: alias3 = {} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , unknown =(i82)=>i82  } = {}) {
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
            }
        }
    }
    const aliases = {};
    if (alias3 !== undefined) {
        for(const key in alias3){
            const val = getForce(alias3, key);
            if (typeof val === "string") {
                aliases[key] = [
                    val
                ];
            } else {
                aliases[key] = val;
            }
            for (const alias1 of getForce(aliases, key)){
                aliases[alias1] = [
                    key
                ].concat(aliases[key].filter((y)=>alias1 !== y));
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key of stringArgs.filter(Boolean)){
            flags.strings[key] = true;
            const alias = get2(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.strings[al] = true;
                }
            }
        }
    }
    const argv1 = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get2(flags.bools, key) || !!get2(flags.strings, key) || !!get2(aliases, key);
    }
    function setKey(obj, keys, value) {
        let o = obj;
        keys.slice(0, -1).forEach(function(key) {
            if (get2(o, key) === undefined) {
                o[key] = {};
            }
            o = get2(o, key);
        });
        const key4 = keys[keys.length - 1];
        if (get2(o, key4) === undefined || get2(flags.bools, key4) || typeof get2(o, key4) === "boolean") {
            o[key4] = value;
        } else if (Array.isArray(get2(o, key4))) {
            o[key4].push(value);
        } else {
            o[key4] = [
                get2(o, key4),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get2(flags.strings, key) && isNumber(val) ? Number(val) : val;
        setKey(argv1, key.split("."), value);
        const alias = get2(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv1, x.split("."), value);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x)=>typeof get2(flags.bools, x) === "boolean");
    }
    for (const key3 of Object.keys(flags.bools)){
        setArg(key3, defaults[key3] === undefined ? false : defaults[key3]);
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i83 = 0; i83 < args.length; i83++){
        const arg = args[i83];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert1(m != null);
            const [, key, value] = m;
            if (flags.bools[key]) {
                const booleanValue = value !== "false";
                setArg(key, booleanValue, arg);
            } else {
                setArg(key, value, arg);
            }
        } else if (/^--no-.+/.test(arg)) {
            const m = arg.match(/^--no-(.+)/);
            assert1(m != null);
            setArg(m[1], false, arg);
        } else if (/^--.+/.test(arg)) {
            const m = arg.match(/^--(.+)/);
            assert1(m != null);
            const [, key] = m;
            const next = args[i83 + 1];
            if (next !== undefined && !/^-/.test(next) && !get2(flags.bools, key) && !flags.allBools && (get2(aliases, key) ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i83++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key, next === "true", arg);
                i83++;
            } else {
                setArg(key, get2(flags.strings, key) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next = arg.slice(j + 2);
                if (next === "-") {
                    setArg(letters[j], next, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get2(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key] = arg.slice(-1);
            if (!broken && key !== "-") {
                if (args[i83 + 1] && !/^(-|--)[^-]/.test(args[i83 + 1]) && !get2(flags.bools, key) && (get2(aliases, key) ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i83 + 1], arg);
                    i83++;
                } else if (args[i83 + 1] && /^(true|false)$/.test(args[i83 + 1])) {
                    setArg(key, args[i83 + 1] === "true", arg);
                    i83++;
                } else {
                    setArg(key, get2(flags.strings, key) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv1._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv1._.push(...args.slice(i83 + 1));
                break;
            }
        }
    }
    for (const key2 of Object.keys(defaults)){
        if (!hasKey(argv1, key2.split("."))) {
            setKey(argv1, key2.split("."), defaults[key2]);
            if (aliases[key2]) {
                for (const x of aliases[key2]){
                    setKey(argv1, x.split("."), defaults[key2]);
                }
            }
        }
    }
    if (doubleDash) {
        argv1["--"] = [];
        for (const key of notFlags){
            argv1["--"].push(key);
        }
    } else {
        for (const key of notFlags){
            argv1._.push(key);
        }
    }
    return argv1;
}
function getOptions() {
    const args = parse(Deno.args);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
const CHAR_FORWARD_SLASH = 47;
function assertPath(path8) {
    if (typeof path8 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path8)}`);
    }
}
function isPosixPathSeparator(code21) {
    return code21 === 47;
}
function isPathSeparator(code22) {
    return isPosixPathSeparator(code22) || code22 === 92;
}
function isWindowsDeviceRoot(code23) {
    return code23 >= 97 && code23 <= 122 || code23 >= 65 && code23 <= 90;
}
function normalizeString(path9, allowAboveRoot, separator, isPathSeparator1) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code24;
    for(let i84 = 0, len = path9.length; i84 <= len; ++i84){
        if (i84 < len) code24 = path9.charCodeAt(i84);
        else if (isPathSeparator1(code24)) break;
        else code24 = CHAR_FORWARD_SLASH;
        if (isPathSeparator1(code24)) {
            if (lastSlash === i84 - 1 || dots === 1) {} else if (lastSlash !== i84 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i84;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i84;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path9.slice(lastSlash + 1, i84);
                else res = path9.slice(lastSlash + 1, i84);
                lastSegmentLength = i84 - lastSlash - 1;
            }
            lastSlash = i84;
            dots = 0;
        } else if (code24 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep6, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base8 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base8;
    if (dir === pathObject.root) return dir + base8;
    return dir + sep6 + base8;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i85 = pathSegments.length - 1; i85 >= -1; i85--){
        let path10;
        const { Deno  } = globalThis;
        if (i85 >= 0) {
            path10 = pathSegments[i85];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path10 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path10 = Deno.cwd();
            if (path10 === undefined || path10.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path10 = `${resolvedDevice}\\`;
            }
        }
        assertPath(path10);
        const len = path10.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute1 = false;
        const code25 = path10.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code25)) {
                isAbsolute1 = true;
                if (isPathSeparator(path10.charCodeAt(1))) {
                    let j = 2;
                    let last35 = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path10.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last35) {
                        const firstPart = path10.slice(last35, j);
                        last35 = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path10.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last35) {
                            last35 = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path10.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path10.slice(last35)}`;
                                rootEnd = j;
                            } else if (j !== last35) {
                                device = `\\\\${firstPart}\\${path10.slice(last35, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code25)) {
                if (path10.charCodeAt(1) === 58) {
                    device = path10.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path10.charCodeAt(2))) {
                            isAbsolute1 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code25)) {
            rootEnd = 1;
            isAbsolute1 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path10.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute1;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path11) {
    assertPath(path11);
    const len = path11.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code26 = path11.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code26)) {
            isAbsolute2 = true;
            if (isPathSeparator(path11.charCodeAt(1))) {
                let j = 2;
                let last36 = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path11.charCodeAt(j))) break;
                }
                if (j < len && j !== last36) {
                    const firstPart = path11.slice(last36, j);
                    last36 = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path11.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last36) {
                        last36 = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path11.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path11.slice(last36)}\\`;
                        } else if (j !== last36) {
                            device = `\\\\${firstPart}\\${path11.slice(last36, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code26)) {
            if (path11.charCodeAt(1) === 58) {
                device = path11.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path11.charCodeAt(2))) {
                        isAbsolute2 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code26)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path11.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute2) tail = ".";
    if (tail.length > 0 && isPathSeparator(path11.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute2) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute2) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path12) {
    assertPath(path12);
    const len = path12.length;
    if (len === 0) return false;
    const code27 = path12.charCodeAt(0);
    if (isPathSeparator(code27)) {
        return true;
    } else if (isWindowsDeviceRoot(code27)) {
        if (len > 2 && path12.charCodeAt(1) === 58) {
            if (isPathSeparator(path12.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join2(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i86 = 0; i86 < pathsCount; ++i86){
        const path13 = paths[i86];
        assertPath(path13);
        if (path13.length > 0) {
            if (joined === undefined) joined = firstPart = path13;
            else joined += `\\${path13}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i87 = 0;
    for(; i87 <= length; ++i87){
        if (i87 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i87) === 92) {
                    return toOrig.slice(toStart + i87 + 1);
                } else if (i87 === 2) {
                    return toOrig.slice(toStart + i87);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i87) === 92) {
                    lastCommonSep = i87;
                } else if (i87 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i87);
        const toCode = to.charCodeAt(toStart + i87);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i87;
    }
    if (i87 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i87 = fromStart + lastCommonSep + 1; i87 <= fromEnd; ++i87){
        if (i87 === fromEnd || from.charCodeAt(i87) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path14) {
    if (typeof path14 !== "string") return path14;
    if (path14.length === 0) return "";
    const resolvedPath = resolve(path14);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code28 = resolvedPath.charCodeAt(2);
                if (code28 !== 63 && code28 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path14;
}
function dirname(path15) {
    assertPath(path15);
    const len = path15.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code29 = path15.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code29)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path15.charCodeAt(1))) {
                let j = 2;
                let last37 = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path15.charCodeAt(j))) break;
                }
                if (j < len && j !== last37) {
                    last37 = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path15.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last37) {
                        last37 = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path15.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path15;
                        }
                        if (j !== last37) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code29)) {
            if (path15.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path15.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code29)) {
        return path15;
    }
    for(let i88 = len - 1; i88 >= offset; --i88){
        if (isPathSeparator(path15.charCodeAt(i88))) {
            if (!matchedSlash) {
                end = i88;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path15.slice(0, end);
}
function basename(path16, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path16);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i89;
    if (path16.length >= 2) {
        const drive = path16.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path16.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path16.length) {
        if (ext.length === path16.length && ext === path16) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i89 = path16.length - 1; i89 >= start; --i89){
            const code30 = path16.charCodeAt(i89);
            if (isPathSeparator(code30)) {
                if (!matchedSlash) {
                    start = i89 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i89 + 1;
                }
                if (extIdx >= 0) {
                    if (code30 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i89;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path16.length;
        return path16.slice(start, end);
    } else {
        for(i89 = path16.length - 1; i89 >= start; --i89){
            if (isPathSeparator(path16.charCodeAt(i89))) {
                if (!matchedSlash) {
                    start = i89 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i89 + 1;
            }
        }
        if (end === -1) return "";
        return path16.slice(start, end);
    }
}
function extname(path17) {
    assertPath(path17);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path17.length >= 2 && path17.charCodeAt(1) === 58 && isWindowsDeviceRoot(path17.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i90 = path17.length - 1; i90 >= start; --i90){
        const code31 = path17.charCodeAt(i90);
        if (isPathSeparator(code31)) {
            if (!matchedSlash) {
                startPart = i90 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i90 + 1;
        }
        if (code31 === 46) {
            if (startDot === -1) startDot = i90;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path17.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse1(path18) {
    assertPath(path18);
    const ret20 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path18.length;
    if (len === 0) return ret20;
    let rootEnd = 0;
    let code32 = path18.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code32)) {
            rootEnd = 1;
            if (isPathSeparator(path18.charCodeAt(1))) {
                let j = 2;
                let last38 = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path18.charCodeAt(j))) break;
                }
                if (j < len && j !== last38) {
                    last38 = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path18.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last38) {
                        last38 = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path18.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last38) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code32)) {
            if (path18.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path18.charCodeAt(2))) {
                        if (len === 3) {
                            ret20.root = ret20.dir = path18;
                            return ret20;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret20.root = ret20.dir = path18;
                    return ret20;
                }
            }
        }
    } else if (isPathSeparator(code32)) {
        ret20.root = ret20.dir = path18;
        return ret20;
    }
    if (rootEnd > 0) ret20.root = path18.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i91 = path18.length - 1;
    let preDotState = 0;
    for(; i91 >= rootEnd; --i91){
        code32 = path18.charCodeAt(i91);
        if (isPathSeparator(code32)) {
            if (!matchedSlash) {
                startPart = i91 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i91 + 1;
        }
        if (code32 === 46) {
            if (startDot === -1) startDot = i91;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret20.base = ret20.name = path18.slice(startPart, end);
        }
    } else {
        ret20.name = path18.slice(startPart, startDot);
        ret20.base = path18.slice(startPart, end);
        ret20.ext = path18.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret20.dir = path18.slice(0, startPart - 1);
    } else ret20.dir = ret20.root;
    return ret20;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path19 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path19 = `\\\\${url.hostname}${path19}`;
    }
    return path19;
}
function toFileUrl(path20) {
    if (!isAbsolute(path20)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname3, pathname] = path20.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname3 != null && hostname3 != "localhost") {
        url.hostname = hostname3;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod6 = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join2,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse1,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i92 = pathSegments.length - 1; i92 >= -1 && !resolvedAbsolute; i92--){
        let path21;
        if (i92 >= 0) path21 = pathSegments[i92];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path21 = Deno.cwd();
        }
        assertPath(path21);
        if (path21.length === 0) {
            continue;
        }
        resolvedPath = `${path21}/${resolvedPath}`;
        resolvedAbsolute = path21.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path22) {
    assertPath(path22);
    if (path22.length === 0) return ".";
    const isAbsolute1 = path22.charCodeAt(0) === 47;
    const trailingSeparator = path22.charCodeAt(path22.length - 1) === 47;
    path22 = normalizeString(path22, !isAbsolute1, "/", isPosixPathSeparator);
    if (path22.length === 0 && !isAbsolute1) path22 = ".";
    if (path22.length > 0 && trailingSeparator) path22 += "/";
    if (isAbsolute1) return `/${path22}`;
    return path22;
}
function isAbsolute1(path23) {
    assertPath(path23);
    return path23.length > 0 && path23.charCodeAt(0) === 47;
}
function join3(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i93 = 0, len = paths.length; i93 < len; ++i93){
        const path24 = paths[i93];
        assertPath(path24);
        if (path24.length > 0) {
            if (!joined) joined = path24;
            else joined += `/${path24}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i94 = 0;
    for(; i94 <= length; ++i94){
        if (i94 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i94) === 47) {
                    return to.slice(toStart + i94 + 1);
                } else if (i94 === 0) {
                    return to.slice(toStart + i94);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i94) === 47) {
                    lastCommonSep = i94;
                } else if (i94 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i94);
        const toCode = to.charCodeAt(toStart + i94);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i94;
    }
    let out = "";
    for(i94 = fromStart + lastCommonSep + 1; i94 <= fromEnd; ++i94){
        if (i94 === fromEnd || from.charCodeAt(i94) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path25) {
    return path25;
}
function dirname1(path26) {
    assertPath(path26);
    if (path26.length === 0) return ".";
    const hasRoot = path26.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i95 = path26.length - 1; i95 >= 1; --i95){
        if (path26.charCodeAt(i95) === 47) {
            if (!matchedSlash) {
                end = i95;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path26.slice(0, end);
}
function basename1(path27, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path27);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i96;
    if (ext !== undefined && ext.length > 0 && ext.length <= path27.length) {
        if (ext.length === path27.length && ext === path27) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i96 = path27.length - 1; i96 >= 0; --i96){
            const code33 = path27.charCodeAt(i96);
            if (code33 === 47) {
                if (!matchedSlash) {
                    start = i96 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i96 + 1;
                }
                if (extIdx >= 0) {
                    if (code33 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i96;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path27.length;
        return path27.slice(start, end);
    } else {
        for(i96 = path27.length - 1; i96 >= 0; --i96){
            if (path27.charCodeAt(i96) === 47) {
                if (!matchedSlash) {
                    start = i96 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i96 + 1;
            }
        }
        if (end === -1) return "";
        return path27.slice(start, end);
    }
}
function extname1(path28) {
    assertPath(path28);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i97 = path28.length - 1; i97 >= 0; --i97){
        const code34 = path28.charCodeAt(i97);
        if (code34 === 47) {
            if (!matchedSlash) {
                startPart = i97 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i97 + 1;
        }
        if (code34 === 46) {
            if (startDot === -1) startDot = i97;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path28.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse2(path29) {
    assertPath(path29);
    const ret21 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path29.length === 0) return ret21;
    const isAbsolute2 = path29.charCodeAt(0) === 47;
    let start;
    if (isAbsolute2) {
        ret21.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i98 = path29.length - 1;
    let preDotState = 0;
    for(; i98 >= start; --i98){
        const code35 = path29.charCodeAt(i98);
        if (code35 === 47) {
            if (!matchedSlash) {
                startPart = i98 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i98 + 1;
        }
        if (code35 === 46) {
            if (startDot === -1) startDot = i98;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute2) {
                ret21.base = ret21.name = path29.slice(1, end);
            } else {
                ret21.base = ret21.name = path29.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute2) {
            ret21.name = path29.slice(1, startDot);
            ret21.base = path29.slice(1, end);
        } else {
            ret21.name = path29.slice(startPart, startDot);
            ret21.base = path29.slice(startPart, end);
        }
        ret21.ext = path29.slice(startDot, end);
    }
    if (startPart > 0) ret21.dir = path29.slice(0, startPart - 1);
    else if (isAbsolute2) ret21.dir = "/";
    return ret21;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path30) {
    if (!isAbsolute1(path30)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path30.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod7 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join3,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse2,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod6 : mod7;
const { join: join4 , normalize: normalize2  } = path;
const path1 = isWindows ? mod6 : mod7;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join5 , normalize: normalize3 , parse: parse3 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch = _arch();
const chdir = Deno.chdir;
const cwd = Deno.cwd;
const nextTick1 = nextTick2;
const env = new Proxy({}, {
    get (_target, prop) {
        return Deno.env.get(String(prop));
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject()),
    getOwnPropertyDescriptor: (_target, name43)=>{
        const e = Deno.env.toObject();
        if (name43 in Deno.env.toObject()) {
            const o = {
                enumerable: true,
                configurable: true
            };
            if (typeof name43 === "string") {
                o.value = e[name43];
            }
            return o;
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return value;
    }
});
const pid = Deno.pid;
const platform = isWindows ? "win32" : Deno.build.os;
const version = "v16.11.1";
const versions = {
    node: "16.11.1",
    uv: "1.42.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.17.2",
    modules: "93",
    nghttp2: "1.45.1",
    napi: "8",
    llhttp: "6.0.4",
    openssl: "1.1.1l",
    cldr: "39.0",
    icu: "69.1",
    tz: "2021a",
    unicode: "13.0",
    ...Deno.version
};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state17 = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state17 && state17.autoDestroy && state17.emitClose && state17.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick2(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick2(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
const validateAbortSignal1 = (signal, name44)=>{
    if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name44, "AbortSignal", signal);
    }
};
function isStream(obj) {
    return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal(signal, stream) {
    validateAbortSignal1(signal, "signal");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
    }
    const onAbort = ()=>{
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, ()=>signal.removeEventListener("abort", onAbort));
    }
    return stream;
}
const kDestroy = Symbol("kDestroy");
const kConstruct = Symbol("kConstruct");
function checkError(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }
    return this;
}
function _destroy(self, err1, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self._readableState;
        const w = self._writableState;
        checkError(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick2(emitErrorCloseNT, self, err);
        } else {
            nextTick2(emitCloseNT, self);
        }
    }
    try {
        const result = self._destroy(err1 || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onDestroy, null);
                }, function(err) {
                    nextTick2(onDestroy, err);
                });
            }
        }
    } catch (err) {
        onDestroy(err);
    }
}
function emitErrorCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    const r = self._readableState;
    const w = self._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self.emit("close");
    }
}
function emitErrorNT(self, err) {
    const r = self._readableState;
    const w = self._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self.emit("error", err);
}
function undestroy() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = false;
        r.endEmitted = false;
    }
    if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.ended = false;
        w.ending = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.finished = false;
    }
}
function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w && w.destroyed || r && r.destroyed) {
        return this;
    }
    if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err);
    } else if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick2(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}
function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
        return;
    }
    const r = stream._readableState;
    const w = stream._writableState;
    if (r) {
        r.constructed = false;
    }
    if (w) {
        w.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
        return;
    }
    nextTick2(constructNT, stream);
}
function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
        if (called) {
            errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
            r.constructed = true;
        }
        if (w) {
            w.constructed = true;
        }
        if (s.destroyed) {
            stream.emit(kDestroy, err);
        } else if (err) {
            errorOrDestroy(stream, err, true);
        } else {
            nextTick2(emitConstructNT, stream);
        }
    }
    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onConstruct, null);
                }, function(err) {
                    nextTick2(onConstruct, err);
                });
            }
        }
    } catch (err) {
        onConstruct(err);
    }
}
function emitConstructNT(stream) {
    stream.emit(kConstruct);
}
function isRequest1(stream) {
    return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err) {
    if (!stream) return;
    if (isRequest1(stream)) return stream.abort();
    if (isRequest1(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === "function") return stream.destroy(err);
    if (typeof stream.close === "function") return stream.close();
}
const __default3 = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
};
const kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isIterable(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === "function";
    if (isAsync === false) return typeof obj[Symbol.iterator] === "function";
    return typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state18 = wState || rState;
    return !!(stream.destroyed || state18?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
    return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable1(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}
const stdio = {};
function isBlob(object) {
    return object instanceof Blob;
}
function _from1(Readable1, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer) {
        return new Readable1({
            objectMode: true,
            ...opts,
            read () {
                this.push(iterable);
                this.push(null);
            }
        });
    }
    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", [
            "Iterable"
        ], iterable);
    }
    const readable = new Readable1({
        objectMode: true,
        highWaterMark: 1,
        ...opts
    });
    let reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    readable._destroy = function(error4, cb) {
        close2(error4).then(()=>nextTick1(cb, error4), (e)=>nextTick1(cb, e || error4));
    };
    async function close2(error5) {
        const hadError = error5 !== undefined && error5 !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
            const { value , done  } = await iterator.throw(error5);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === "function") {
            const { value  } = await iterator.return();
            await value;
        }
    }
    async function next() {
        for(;;){
            try {
                const { value , done  } = isAsync ? await iterator.next() : iterator.next();
                if (done) {
                    readable.push(null);
                } else {
                    const res = value && typeof value.then === "function" ? await value : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err) {
                readable.destroy(err);
            }
            break;
        }
    }
    return readable;
}
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state19, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name45 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name45, hwm);
        }
        return Math.floor(hwm);
    }
    return getDefaultHighWaterMark(state19.objectMode);
}
function Stream(opts) {
    EventEmitter.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, "error") === 0) {
            this.emit("error", er);
        }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
};
function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
    }
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [
            fn,
            emitter._events[event]
        ];
    }
}
var NotImplemented;
(function(NotImplemented1) {
    NotImplemented1[NotImplemented1["ascii"] = 0] = "ascii";
    NotImplemented1[NotImplemented1["latin1"] = 1] = "latin1";
    NotImplemented1[NotImplemented1["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding2(enc) {
    const encoding = normalizeEncoding(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function utf8CheckByte(__byte) {
    if (__byte <= 0x7f) return 0;
    else if (__byte >> 5 === 0x06) return 2;
    else if (__byte >> 4 === 0x0e) return 3;
    else if (__byte >> 3 === 0x1e) return 4;
    return __byte >> 6 === 0x02 ? -1 : -2;
}
function utf8CheckIncomplete(self, buf, i99) {
    let j = buf.length - 1;
    if (j < i99) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i99 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i99 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self, buf) {
    if ((buf[0] & 0xc0) !== 0x80) {
        self.lastNeed = 0;
        return "\ufffd";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xc0) !== 0x80) {
            self.lastNeed = 1;
            return "\ufffd";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i100) {
    const total = utf8CheckIncomplete(this, buf, i100);
    if (!this.lastNeed) return buf.toString("utf8", i100);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i100, end);
}
function utf8End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i101;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i101 = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i101 = 0;
    }
    if (i101 < buf.length) return r ? r + this.text(buf, i101) : this.text(buf, i101);
    return r || "";
}
function base64Text(buf, i102) {
    const n = (buf.length - i102) % 3;
    if (n === 0) return buf.toString("base64", i102);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i102, buf.length - n);
}
function base64End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    lastChar;
    lastNeed;
    lastTotal;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
    }
    encoding;
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        let decoder;
        switch(encoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
class BufferList {
    constructor(){
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(v) {
        const entry = {
            data: v,
            next: null
        };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }
    unshift(v) {
        const entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }
    shift() {
        if (this.length === 0) {
            return;
        }
        const ret22 = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret22;
    }
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    join(s) {
        if (this.length === 0) {
            return "";
        }
        let p = this.head;
        let ret23 = "" + p.data;
        while(p = p.next){
            ret23 += s + p.data;
        }
        return ret23;
    }
    concat(n) {
        if (this.length === 0) {
            return Buffer.alloc(0);
        }
        const ret24 = Buffer.allocUnsafe(n >>> 0);
        let p = this.head;
        let i103 = 0;
        while(p){
            ret24.set(p.data, i103);
            i103 += p.data.length;
            p = p.next;
        }
        return ret24;
    }
    consume(n, hasStrings) {
        const data10 = this.head.data;
        if (n < data10.length) {
            const slice = data10.slice(0, n);
            this.head.data = data10.slice(n);
            return slice;
        }
        if (n === data10.length) {
            return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
        return this.head.data;
    }
    *[Symbol.iterator]() {
        for(let p = this.head; p; p = p.next){
            yield p.data;
        }
    }
    _getString(n) {
        let ret25 = "";
        let p = this.head;
        let c = 0;
        do {
            const str = p.data;
            if (n > str.length) {
                ret25 += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret25 += str;
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret25 += str.slice(0, n);
                    this.head = p;
                    p.data = str.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret25;
    }
    _getBuffer(n) {
        const ret26 = Buffer.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
            const buf = p.data;
            if (n > buf.length) {
                ret26.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret26.set(buf, retLen - n);
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret26.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
                    this.head = p;
                    p.data = buf.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret26;
    }
    [inspect.custom](_, options) {
        return inspect(this, {
            ...options,
            depth: 0,
            customInspect: false
        });
    }
}
let debug = debuglog("stream", (fn)=>{
    debug = fn;
});
const kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
const nop1 = ()=>{};
const { errorOrDestroy: errorOrDestroy1  } = __default3;
function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = stream instanceof Stream.Duplex;
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.constructed = true;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused] = null;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.destroyed = false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;
    this.readingMore = false;
    this.dataEmitted = false;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    if (!(this instanceof Readable)) {
        return new Readable(options);
    }
    const isDuplex = this instanceof Stream.Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
        if (typeof options.read === "function") {
            this._read = options.read;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default3.construct(this, ()=>{
        if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
        }
    });
}
Readable.prototype.destroy = __default3.destroy;
Readable.prototype._undestroy = __default3.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
Readable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state20 = stream._readableState;
    let err;
    if (!state20.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state20.defaultEncoding;
            if (state20.encoding !== encoding) {
                if (addToFront && state20.encoding) {
                    chunk = Buffer.from(chunk, encoding).toString(state20.encoding);
                } else {
                    chunk = Buffer.from(chunk, encoding);
                    encoding = "";
                }
            }
        } else if (chunk instanceof Buffer) {
            encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "";
        } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    if (err) {
        errorOrDestroy1(stream, err);
    } else if (chunk === null) {
        state20.reading = false;
        onEofChunk(stream, state20);
    } else if (state20.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
            if (state20.endEmitted) {
                errorOrDestroy1(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            } else {
                addChunk(stream, state20, chunk, true);
            }
        } else if (state20.ended) {
            errorOrDestroy1(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state20.destroyed || state20.errored) {
            return false;
        } else {
            state20.reading = false;
            if (state20.decoder && !encoding) {
                chunk = state20.decoder.write(chunk);
                if (state20.objectMode || chunk.length !== 0) {
                    addChunk(stream, state20, chunk, false);
                } else {
                    maybeReadMore(stream, state20);
                }
            } else {
                addChunk(stream, state20, chunk, false);
            }
        }
    } else if (!addToFront) {
        state20.reading = false;
        maybeReadMore(stream, state20);
    }
    return !state20.ended && (state20.length < state20.highWaterMark || state20.length === 0);
}
function addChunk(stream, state21, chunk, addToFront) {
    if (state21.flowing && state21.length === 0 && !state21.sync && stream.listenerCount("data") > 0) {
        if (state21.multiAwaitDrain) {
            state21.awaitDrainWriters.clear();
        } else {
            state21.awaitDrainWriters = null;
        }
        state21.dataEmitted = true;
        stream.emit("data", chunk);
    } else {
        state21.length += state21.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state21.buffer.unshift(chunk);
        } else {
            state21.buffer.push(chunk);
        }
        if (state21.needReadable) {
            emitReadable(stream);
        }
    }
    maybeReadMore(stream, state21);
}
Readable.prototype.isPaused = function() {
    const state22 = this._readableState;
    return state22[kPaused] === true || state22.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer22 = this._readableState.buffer;
    let content = "";
    for (const data11 of buffer22){
        content += decoder.write(data11);
    }
    buffer22.clear();
    if (content !== "") {
        buffer22.push(content);
    }
    this._readableState.length = content.length;
    return this;
};
const MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= 0x40000000) {
        n = MAX_HWM;
    } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
function howMuchToRead(n, state23) {
    if (n <= 0 || state23.length === 0 && state23.ended) {
        return 0;
    }
    if (state23.objectMode) {
        return 1;
    }
    if (Number.isNaN(n)) {
        if (state23.flowing && state23.length) {
            return state23.buffer.first().length;
        }
        return state23.length;
    }
    if (n <= state23.length) {
        return n;
    }
    return state23.ended ? state23.length : 0;
}
Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
        n = NaN;
    } else if (!Number.isInteger(n)) {
        n = Number.parseInt(n, 10);
    }
    const state24 = this._readableState;
    const nOrig = n;
    if (n > state24.highWaterMark) {
        state24.highWaterMark = computeNewHighWaterMark(n);
    }
    if (n !== 0) {
        state24.emittedReadable = false;
    }
    if (n === 0 && state24.needReadable && ((state24.highWaterMark !== 0 ? state24.length >= state24.highWaterMark : state24.length > 0) || state24.ended)) {
        debug("read: emitReadable", state24.length, state24.ended);
        if (state24.length === 0 && state24.ended) {
            endReadable(this);
        } else {
            emitReadable(this);
        }
        return null;
    }
    n = howMuchToRead(n, state24);
    if (n === 0 && state24.ended) {
        if (state24.length === 0) {
            endReadable(this);
        }
        return null;
    }
    let doRead = state24.needReadable;
    debug("need readable", doRead);
    if (state24.length === 0 || state24.length - n < state24.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    if (state24.ended || state24.reading || state24.destroyed || state24.errored || !state24.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
    } else if (doRead) {
        debug("do read");
        state24.reading = true;
        state24.sync = true;
        if (state24.length === 0) {
            state24.needReadable = true;
        }
        this._read(state24.highWaterMark);
        state24.sync = false;
        if (!state24.reading) {
            n = howMuchToRead(nOrig, state24);
        }
    }
    let ret27;
    if (n > 0) {
        ret27 = fromList(n, state24);
    } else {
        ret27 = null;
    }
    if (ret27 === null) {
        state24.needReadable = state24.length <= state24.highWaterMark;
        n = 0;
    } else {
        state24.length -= n;
        if (state24.multiAwaitDrain) {
            state24.awaitDrainWriters.clear();
        } else {
            state24.awaitDrainWriters = null;
        }
    }
    if (state24.length === 0) {
        if (!state24.ended) {
            state24.needReadable = true;
        }
        if (nOrig !== n && state24.ended) {
            endReadable(this);
        }
    }
    if (ret27 !== null) {
        state24.dataEmitted = true;
        this.emit("data", ret27);
    }
    return ret27;
};
function onEofChunk(stream, state25) {
    debug("onEofChunk");
    if (state25.ended) return;
    if (state25.decoder) {
        const chunk = state25.decoder.end();
        if (chunk && chunk.length) {
            state25.buffer.push(chunk);
            state25.length += state25.objectMode ? 1 : chunk.length;
        }
    }
    state25.ended = true;
    if (state25.sync) {
        emitReadable(stream);
    } else {
        state25.needReadable = false;
        state25.emittedReadable = true;
        emitReadable_(stream);
    }
}
function emitReadable(stream) {
    const state26 = stream._readableState;
    debug("emitReadable", state26.needReadable, state26.emittedReadable);
    state26.needReadable = false;
    if (!state26.emittedReadable) {
        debug("emitReadable", state26.flowing);
        state26.emittedReadable = true;
        nextTick2(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    const state27 = stream._readableState;
    debug("emitReadable_", state27.destroyed, state27.length, state27.ended);
    if (!state27.destroyed && !state27.errored && (state27.length || state27.ended)) {
        stream.emit("readable");
        state27.emittedReadable = false;
    }
    state27.needReadable = !state27.flowing && !state27.ended && state27.length <= state27.highWaterMark;
    flow(stream);
}
function maybeReadMore(stream, state28) {
    if (!state28.readingMore && state28.constructed) {
        state28.readingMore = true;
        nextTick2(maybeReadMore_, stream, state28);
    }
}
function maybeReadMore_(stream, state29) {
    while(!state29.reading && !state29.ended && (state29.length < state29.highWaterMark || state29.flowing && state29.length === 0)){
        const len = state29.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state29.length) {
            break;
        }
    }
    state29.readingMore = false;
}
Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state30 = this._readableState;
    if (state30.pipes.length === 1) {
        if (!state30.multiAwaitDrain) {
            state30.multiAwaitDrain = true;
            state30.awaitDrainWriters = new Set(state30.awaitDrainWriters ? [
                state30.awaitDrainWriters
            ] : []);
        }
    }
    state30.pipes.push(dest);
    debug("pipe count=%d opts=%j", state30.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state30.endEmitted) {
        nextTick2(endFn);
    } else {
        src.once("end", endFn);
    }
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
            dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state30.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
            ondrain();
        }
    }
    function pause() {
        if (!cleanedUp) {
            if (state30.pipes.length === 1 && state30.pipes[0] === dest) {
                debug("false write response, pause", 0);
                state30.awaitDrainWriters = dest;
                state30.multiAwaitDrain = false;
            } else if (state30.pipes.length > 1 && state30.pipes.includes(dest)) {
                debug("false write response, pause", state30.awaitDrainWriters.size);
                state30.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            ondrain = pipeOnDrain(src, dest);
            dest.on("drain", ondrain);
        }
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        const ret28 = dest.write(chunk);
        debug("dest.write", ret28);
        if (ret28 === false) {
            pause();
        }
    }
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EventEmitter.listenerCount(dest, "error") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
                errorOrDestroy1(dest, er);
            } else {
                dest.emit("error", er);
            }
        }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
        if (state30.flowing) {
            pause();
        }
    } else if (!state30.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state31 = src._readableState;
        if (state31.awaitDrainWriters === dest) {
            debug("pipeOnDrain", 1);
            state31.awaitDrainWriters = null;
        } else if (state31.multiAwaitDrain) {
            debug("pipeOnDrain", state31.awaitDrainWriters.size);
            state31.awaitDrainWriters.delete(dest);
        }
        if ((!state31.awaitDrainWriters || state31.awaitDrainWriters.size === 0) && EventEmitter.listenerCount(src, "data")) {
            state31.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    const state32 = this._readableState;
    const unpipeInfo = {
        hasUnpiped: false
    };
    if (state32.pipes.length === 0) {
        return this;
    }
    if (!dest) {
        const dests = state32.pipes;
        state32.pipes = [];
        this.pause();
        for(let i104 = 0; i104 < dests.length; i104++){
            dests[i104].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    const index = state32.pipes.indexOf(dest);
    if (index === -1) {
        return this;
    }
    state32.pipes.splice(index, 1);
    if (state32.pipes.length === 0) {
        this.pause();
    }
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state33 = this._readableState;
    if (ev === "data") {
        state33.readableListening = this.listenerCount("readable") > 0;
        if (state33.flowing !== false) {
            this.resume();
        }
    } else if (ev === "readable") {
        if (!state33.endEmitted && !state33.readableListening) {
            state33.readableListening = state33.needReadable = true;
            state33.flowing = false;
            state33.emittedReadable = false;
            debug("on readable", state33.length, state33.reading);
            if (state33.length) {
                emitReadable(this);
            } else if (!state33.reading) {
                nextTick2(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        nextTick2(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        nextTick2(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self) {
    const state34 = self._readableState;
    state34.readableListening = self.listenerCount("readable") > 0;
    if (state34.resumeScheduled && state34[kPaused] === false) {
        state34.flowing = true;
    } else if (self.listenerCount("data") > 0) {
        self.resume();
    } else if (!state34.readableListening) {
        state34.flowing = null;
    }
}
function nReadingNextTick(self) {
    debug("readable nexttick read 0");
    self.read(0);
}
Readable.prototype.resume = function() {
    const state35 = this._readableState;
    if (!state35.flowing) {
        debug("resume");
        state35.flowing = !state35.readableListening;
        resume(this, state35);
    }
    state35[kPaused] = false;
    return this;
};
function resume(stream, state36) {
    if (!state36.resumeScheduled) {
        state36.resumeScheduled = true;
        nextTick2(resume_, stream, state36);
    }
}
function resume_(stream, state37) {
    debug("resume", state37.reading);
    if (!state37.reading) {
        stream.read(0);
    }
    state37.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state37.flowing && !state37.reading) {
        stream.read(0);
    }
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
};
function flow(stream) {
    const state38 = stream._readableState;
    debug("flow", state38.flowing);
    while(state38.flowing && stream.read() !== null);
}
Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk)=>{
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });
    stream.on("end", ()=>{
        this.push(null);
    });
    stream.on("error", (err)=>{
        errorOrDestroy1(this, err);
    });
    stream.on("close", ()=>{
        this.destroy();
    });
    stream.on("destroy", ()=>{
        this.destroy();
    });
    this._read = ()=>{
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };
    const streamKeys = Object.keys(stream);
    for(let j = 1; j < streamKeys.length; j++){
        const i105 = streamKeys[j];
        if (this[i105] === undefined && typeof stream[i105] === "function") {
            this[i105] = stream[i105].bind(stream);
        }
    }
    return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
    return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
        validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
            objectMode: true
        });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
}
async function* createAsyncIterator(stream, options) {
    let callback = nop1;
    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options
    };
    function next(resolve11) {
        if (this === stream) {
            callback();
            callback = nop1;
        } else {
            callback = resolve11;
        }
    }
    const state39 = stream._readableState;
    let error6 = state39.errored;
    let errorEmitted = state39.errorEmitted;
    let endEmitted = state39.endEmitted;
    let closeEmitted = state39.closeEmitted;
    stream.on("readable", next).on("error", function(err) {
        error6 = err;
        errorEmitted = true;
        next.call(this);
    }).on("end", function() {
        endEmitted = true;
        next.call(this);
    }).on("close", function() {
        closeEmitted = true;
        next.call(this);
    });
    let errorThrown = false;
    try {
        while(true){
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error6;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err) {
        if (opts.destroyOnError) {
            __default3.destroyer(stream, err);
        }
        errorThrown = true;
        throw err;
    } finally{
        if (!errorThrown && opts.destroyOnReturn) {
            if (state39.autoDestroy || !endEmitted) {
                __default3.destroyer(stream, null);
            }
        }
    }
}
Object.defineProperties(Readable.prototype, {
    readable: {
        get () {
            const r = this._readableState;
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set (val) {
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        }
    },
    readableDidRead: {
        enumerable: false,
        get: function() {
            return this._readableState.dataEmitted;
        }
    },
    readableAborted: {
        enumerable: false,
        get: function() {
            return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
        }
    },
    readableHighWaterMark: {
        enumerable: false,
        get: function() {
            return this._readableState.highWaterMark;
        }
    },
    readableBuffer: {
        enumerable: false,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    },
    readableFlowing: {
        enumerable: false,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(state40) {
            if (this._readableState) {
                this._readableState.flowing = state40;
            }
        }
    },
    readableLength: {
        enumerable: false,
        get () {
            return this._readableState.length;
        }
    },
    readableObjectMode: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.objectMode : false;
        }
    },
    readableEncoding: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.encoding : null;
        }
    },
    destroyed: {
        enumerable: false,
        get () {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set (value) {
            if (!this._readableState) {
                return;
            }
            this._readableState.destroyed = value;
        }
    },
    readableEnded: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.endEmitted : false;
        }
    }
});
Object.defineProperties(ReadableState.prototype, {
    pipesCount: {
        get () {
            return this.pipes.length;
        }
    },
    paused: {
        get () {
            return this[kPaused] !== false;
        },
        set (value) {
            this[kPaused] = !!value;
        }
    }
});
function fromList(n, state41) {
    if (state41.length === 0) {
        return null;
    }
    let ret29;
    if (state41.objectMode) {
        ret29 = state41.buffer.shift();
    } else if (!n || n >= state41.length) {
        if (state41.decoder) {
            ret29 = state41.buffer.join("");
        } else if (state41.buffer.length === 1) {
            ret29 = state41.buffer.first();
        } else {
            ret29 = state41.buffer.concat(state41.length);
        }
        state41.buffer.clear();
    } else {
        ret29 = state41.buffer.consume(n, state41.decoder);
    }
    return ret29;
}
function endReadable(stream) {
    const state42 = stream._readableState;
    debug("endReadable", state42.endEmitted);
    if (!state42.endEmitted) {
        state42.ended = true;
        nextTick2(endReadableNT, state42, stream);
    }
}
function endReadableNT(state43, stream) {
    debug("endReadableNT", state43.endEmitted, state43.length);
    if (!state43.errorEmitted && !state43.closeEmitted && !state43.endEmitted && state43.length === 0) {
        state43.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick2(endWritableNT, stream);
        } else if (state43.autoDestroy) {
            const wState = stream._writableState;
            const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}
function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
        stream.end();
    }
}
function readableFrom(iterable, opts) {
    return _from1(Readable, iterable, opts);
}
function wrap(src, options) {
    return new Readable({
        objectMode: (src.readableObjectMode ?? src.objectMode) ?? true,
        ...options,
        destroy (err, callback) {
            __default3.destroyer(src, err);
            callback(err);
        }
    }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
const { errorOrDestroy: errorOrDestroy2  } = __default3;
function isDuplexStream(maybe_duplex) {
    const isReadable2 = Readable.prototype.isPrototypeOf(maybe_duplex);
    let prototype = maybe_duplex;
    let isDuplex = false;
    while(prototype?.constructor && prototype.constructor.name !== "Object"){
        if (prototype.constructor.name === "Duplex") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }
    return isReadable2 && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop2() {}
const kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = isDuplexStream(stream);
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
}
function resetBuffer(state44) {
    state44.buffered = [];
    state44.bufferedIndex = 0;
    state44.allBuffers = true;
    state44.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
    get () {
        return this.buffered.length - this.bufferedIndex;
    }
});
function Writable(options) {
    const isDuplex = isDuplexStream(this);
    if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
        if (typeof options.write === "function") {
            this._write = options.write;
        }
        if (typeof options.writev === "function") {
            this._writev = options.writev;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.final === "function") {
            this._final = options.final;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default3.construct(this, ()=>{
        const state45 = this._writableState;
        if (!state45.writing) {
            clearBuffer(this, state45);
        }
        finishMaybe(this, state45);
    });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
    }
});
Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
    const state46 = stream._writableState;
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = state46.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state46.defaultEncoding;
        } else if (encoding !== "buffer" && !Buffer.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING(encoding);
        }
        if (typeof cb !== "function") {
            cb = nop2;
        }
    }
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (!state46.objectMode) {
        if (typeof chunk === "string") {
            if (state46.decodeStrings !== false) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "buffer";
            }
        } else if (chunk instanceof Buffer) {
            encoding = "buffer";
        } else if (isUint8Array(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
            encoding = "buffer";
        } else {
            throw new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    let err;
    if (state46.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state46.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
        nextTick2(cb, err);
        errorOrDestroy2(stream, err, true);
        return err;
    }
    state46.pendingcb++;
    return writeOrBuffer(stream, state46, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    const state47 = this._writableState;
    if (state47.corked) {
        state47.corked--;
        if (!state47.writing) {
            clearBuffer(this, state47);
        }
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};
function writeOrBuffer(stream, state48, chunk, encoding, callback) {
    const len = state48.objectMode ? 1 : chunk.length;
    state48.length += len;
    const ret30 = state48.length < state48.highWaterMark;
    if (!ret30) {
        state48.needDrain = true;
    }
    if (state48.writing || state48.corked || state48.errored || !state48.constructed) {
        state48.buffered.push({
            chunk,
            encoding,
            callback
        });
        if (state48.allBuffers && encoding !== "buffer") {
            state48.allBuffers = false;
        }
        if (state48.allNoop && callback !== nop2) {
            state48.allNoop = false;
        }
    } else {
        state48.writelen = len;
        state48.writecb = callback;
        state48.writing = true;
        state48.sync = true;
        stream._write(chunk, encoding, state48.onwrite);
        state48.sync = false;
    }
    return ret30 && !state48.errored && !state48.destroyed;
}
function doWrite(stream, state49, writev1, len, chunk, encoding, cb) {
    state49.writelen = len;
    state49.writecb = cb;
    state49.writing = true;
    state49.sync = true;
    if (state49.destroyed) {
        state49.onwrite(new ERR_STREAM_DESTROYED("write"));
    } else if (writev1) {
        stream._writev(chunk, state49.onwrite);
    } else {
        stream._write(chunk, encoding, state49.onwrite);
    }
    state49.sync = false;
}
function onwriteError(stream, state50, er, cb) {
    --state50.pendingcb;
    cb(er);
    errorBuffer(state50);
    errorOrDestroy2(stream, er);
}
function onwrite(stream, er) {
    const state51 = stream._writableState;
    const sync = state51.sync;
    const cb = state51.writecb;
    if (typeof cb !== "function") {
        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK());
        return;
    }
    state51.writing = false;
    state51.writecb = null;
    state51.length -= state51.writelen;
    state51.writelen = 0;
    if (er) {
        er.stack;
        if (!state51.errored) {
            state51.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }
        if (sync) {
            nextTick2(onwriteError, stream, state51, er, cb);
        } else {
            onwriteError(stream, state51, er, cb);
        }
    } else {
        if (state51.buffered.length > state51.bufferedIndex) {
            clearBuffer(stream, state51);
        }
        if (sync) {
            if (state51.afterWriteTickInfo !== null && state51.afterWriteTickInfo.cb === cb) {
                state51.afterWriteTickInfo.count++;
            } else {
                state51.afterWriteTickInfo = {
                    count: 1,
                    cb,
                    stream,
                    state: state51
                };
                nextTick2(afterWriteTick, state51.afterWriteTickInfo);
            }
        } else {
            afterWrite(stream, state51, 1, cb);
        }
    }
}
function afterWriteTick({ stream , state: state52 , count , cb  }) {
    state52.afterWriteTickInfo = null;
    return afterWrite(stream, state52, count, cb);
}
function afterWrite(stream, state53, count, cb) {
    const needDrain = !state53.ending && !stream.destroyed && state53.length === 0 && state53.needDrain;
    if (needDrain) {
        state53.needDrain = false;
        stream.emit("drain");
    }
    while(count-- > 0){
        state53.pendingcb--;
        cb();
    }
    if (state53.destroyed) {
        errorBuffer(state53);
    }
    finishMaybe(stream, state53);
}
function errorBuffer(state54) {
    if (state54.writing) {
        return;
    }
    for(let n = state54.bufferedIndex; n < state54.buffered.length; ++n){
        const { chunk , callback  } = state54.buffered[n];
        const len = state54.objectMode ? 1 : chunk.length;
        state54.length -= len;
        callback(new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state54[kOnFinished].splice(0);
    for(let i106 = 0; i106 < onfinishCallbacks.length; i106++){
        onfinishCallbacks[i106](new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state54);
}
function clearBuffer(stream, state55) {
    if (state55.corked || state55.bufferProcessing || state55.destroyed || !state55.constructed) {
        return;
    }
    const { buffered , bufferedIndex , objectMode  } = state55;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
        return;
    }
    let i107 = bufferedIndex;
    state55.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state55.pendingcb -= bufferedLength - 1;
        const callback = state55.allNoop ? nop2 : (err)=>{
            for(let n = i107; n < buffered.length; ++n){
                buffered[n].callback(err);
            }
        };
        const chunks = state55.allNoop && i107 === 0 ? buffered : buffered.slice(i107);
        chunks.allBuffers = state55.allBuffers;
        doWrite(stream, state55, true, state55.length, chunks, "", callback);
        resetBuffer(state55);
    } else {
        do {
            const { chunk , encoding , callback  } = buffered[i107];
            buffered[i107++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state55, false, len, chunk, encoding, callback);
        }while (i107 < buffered.length && !state55.writing)
        if (i107 === buffered.length) {
            resetBuffer(state55);
        } else if (i107 > 256) {
            buffered.splice(0, i107);
            state55.bufferedIndex = 0;
        } else {
            state55.bufferedIndex = i107;
        }
    }
    state55.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
        this._writev([
            {
                chunk,
                encoding
            }
        ], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    const state56 = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
        const ret31 = _write(this, chunk, encoding);
        if (ret31 instanceof Error) {
            err = ret31;
        }
    }
    if (state56.corked) {
        state56.corked = 1;
        this.uncork();
    }
    if (err) {} else if (!state56.errored && !state56.ending) {
        state56.ending = true;
        finishMaybe(this, state56, true);
        state56.ended = true;
    } else if (state56.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state56.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
        if (err || state56.finished) {
            nextTick1(cb, err);
        } else {
            state56[kOnFinished].push(cb);
        }
    }
    return this;
};
function needFinish(state57) {
    return state57.ending && state57.constructed && state57.length === 0 && !state57.errored && state57.buffered.length === 0 && !state57.finished && !state57.writing && !state57.errorEmitted && !state57.closeEmitted;
}
function callFinal(stream, state58) {
    let called = false;
    function onFinish(err) {
        if (called) {
            errorOrDestroy2(stream, err ?? ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        state58.pendingcb--;
        if (err) {
            const onfinishCallbacks = state58[kOnFinished].splice(0);
            for(let i108 = 0; i108 < onfinishCallbacks.length; i108++){
                onfinishCallbacks[i108](err);
            }
            errorOrDestroy2(stream, err, state58.sync);
        } else if (needFinish(state58)) {
            state58.prefinished = true;
            stream.emit("prefinish");
            state58.pendingcb++;
            nextTick2(finish, stream, state58);
        }
    }
    state58.sync = true;
    state58.pendingcb++;
    try {
        const result = stream._final(onFinish);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onFinish, null);
                }, function(err) {
                    nextTick2(onFinish, err);
                });
            }
        }
    } catch (err) {
        onFinish(stream, state58, err);
    }
    state58.sync = false;
}
function prefinish(stream, state59) {
    if (!state59.prefinished && !state59.finalCalled) {
        if (typeof stream._final === "function" && !state59.destroyed) {
            state59.finalCalled = true;
            callFinal(stream, state59);
        } else {
            state59.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state60, sync) {
    if (needFinish(state60)) {
        prefinish(stream, state60);
        if (state60.pendingcb === 0 && needFinish(state60)) {
            state60.pendingcb++;
            if (sync) {
                nextTick2(finish, stream, state60);
            } else {
                finish(stream, state60);
            }
        }
    }
}
function finish(stream, state61) {
    state61.pendingcb--;
    state61.finished = true;
    const onfinishCallbacks = state61[kOnFinished].splice(0);
    for(let i109 = 0; i109 < onfinishCallbacks.length; i109++){
        onfinishCallbacks[i109]();
    }
    stream.emit("finish");
    if (state61.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
            stream.destroy();
        }
    }
}
Object.defineProperties(Writable.prototype, {
    destroyed: {
        get () {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set (value) {
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        }
    },
    writable: {
        get () {
            const w = this._writableState;
            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set (val) {
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        }
    },
    writableFinished: {
        get () {
            return this._writableState ? this._writableState.finished : false;
        }
    },
    writableObjectMode: {
        get () {
            return this._writableState ? this._writableState.objectMode : false;
        }
    },
    writableBuffer: {
        get () {
            return this._writableState && this._writableState.getBuffer();
        }
    },
    writableEnded: {
        get () {
            return this._writableState ? this._writableState.ending : false;
        }
    },
    writableNeedDrain: {
        get () {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        }
    },
    writableHighWaterMark: {
        get () {
            return this._writableState && this._writableState.highWaterMark;
        }
    },
    writableCorked: {
        get () {
            return this._writableState ? this._writableState.corked : 0;
        }
    },
    writableLength: {
        get () {
            return this._writableState && this._writableState.length;
        }
    }
});
const destroy1 = __default3.destroy;
Writable.prototype.destroy = function(err, cb) {
    const state62 = this._writableState;
    if (!state62.destroyed && (state62.bufferedIndex < state62.buffered.length || state62[kOnFinished].length)) {
        nextTick1(errorBuffer, state62);
    }
    destroy1.call(this, err, cb);
    return this;
};
Writable.prototype._undestroy = __default3.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};
Writable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Writable.WritableState = WritableState;
Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);
{
    for (const method of Object.keys(Writable.prototype)){
        if (!Duplex.prototype[method]) {
            Duplex.prototype[method] = Writable.prototype[method];
        }
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) {
        return new Duplex(options);
    }
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }
        if (options.writable === false) {
            this.writable = false;
        }
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}
Object.defineProperties(Duplex.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable.prototype, "writable"),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
    writableObjectMode: Object.getOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
    writableBuffer: Object.getOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
    writableLength: Object.getOwnPropertyDescriptor(Writable.prototype, "writableLength"),
    writableFinished: Object.getOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
    writableCorked: Object.getOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
    writableEnded: Object.getOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
    writableNeedDrain: Object.getOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
    destroyed: {
        get () {
            if (this._readableState === undefined || this._writableState === undefined) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set (value) {
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        }
    }
});
class Duplexify extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function duplexify(body, name46) {
    if (isDuplexNodeStream(body)) {
        return body;
    }
    if (isReadableNodeStream(body)) {
        return _duplexify({
            readable: body
        });
    }
    if (isWritableNodeStream(body)) {
        return _duplexify({
            writable: body
        });
    }
    if (isNodeStream(body)) {
        return _duplexify({
            writable: false,
            readable: false
        });
    }
    if (typeof body === "function") {
        const { value , write: write1 , final: __final1 , destroy: destroy2  } = fromAsyncGen(body);
        if (isIterable(value)) {
            return _from1(Duplexify, value, {
                objectMode: true,
                write: write1,
                final: __final1,
                destroy: destroy2
            });
        }
        const then = value?.then;
        if (typeof then === "function") {
            let d;
            const promise = then.call(value, (val)=>{
                if (val != null) {
                    throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
                }
            }, (err)=>{
                destroyer(d, err);
            });
            return d = new Duplexify({
                objectMode: true,
                readable: false,
                write: write1,
                final (cb) {
                    __final1(async ()=>{
                        try {
                            await promise;
                            nextTick1(cb, null);
                        } catch (err) {
                            nextTick1(cb, err);
                        }
                    });
                },
                destroy: destroy2
            });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name46, value);
    }
    if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
        return _from1(Duplexify, body, {
            objectMode: true,
            writable: false
        });
    }
    if (typeof body?.writable === "object" || typeof body?.readable === "object") {
        const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : undefined;
        const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : undefined;
        return _duplexify({
            readable,
            writable
        });
    }
    const then = body?.then;
    if (typeof then === "function") {
        let d;
        then.call(body, (val)=>{
            if (val != null) {
                d.push(val);
            }
            d.push(null);
        }, (err)=>{
            destroyer(d, err);
        });
        return d = new Duplexify({
            objectMode: true,
            writable: false,
            read () {}
        });
    }
    throw new ERR_INVALID_ARG_TYPE(name46, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise", 
    ], body);
}
function fromAsyncGen(fn) {
    let { promise , resolve: resolve12  } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(async function*() {
        while(true){
            const _promise = promise;
            promise = null;
            const { chunk , done , cb  } = await _promise;
            nextTick2(cb);
            if (done) return;
            if (signal.aborted) throw new AbortError();
            ({ promise , resolve: resolve12  } = createDeferredPromise());
            yield chunk;
        }
    }(), {
        signal
    });
    return {
        value,
        write (chunk, encoding, cb) {
            const _resolve = resolve12;
            resolve12 = null;
            _resolve({
                chunk,
                done: false,
                cb
            });
        },
        final (cb) {
            const _resolve = resolve12;
            resolve12 = null;
            _resolve({
                done: true,
                cb
            });
        },
        destroy (err, cb) {
            ac.abort();
            cb(err);
        }
    };
}
function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w = pair.writable;
    let readable = !!isReadable1(r);
    let writable = !!isWritable1(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    d = new Duplexify({
        readableObjectMode: !!r?.readableObjectMode,
        writableObjectMode: !!w?.writableObjectMode,
        readable,
        writable
    });
    if (writable) {
        eos(w, (err)=>{
            writable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            w.end();
            onfinish = callback;
        };
        w.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        w.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        eos(r, (err)=>{
            readable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        r.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        r.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = r.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(w, err);
            destroyer(r, err);
        }
    };
    return d;
}
function duplexFrom(body) {
    return duplexify(body, "body");
}
Duplex.from = duplexFrom;
Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);
const kCallback = Symbol("kCallback");
function Transform(options) {
    if (!(this instanceof Transform)) {
        return new Transform(options);
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
        if (typeof options.transform === "function") {
            this._transform = options.transform;
        }
        if (typeof options.flush === "function") {
            this._flush = options.flush;
        }
    }
    this.on("prefinish", prefinish1);
}
function __final(cb) {
    let called = false;
    if (typeof this._flush === "function" && !this.destroyed) {
        const result = this._flush((er, data12)=>{
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }
            if (data12 != null) {
                this.push(data12);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === "function") {
                    then.call(result, (data13)=>{
                        if (called) {
                            return;
                        }
                        if (data13 != null) {
                            this.push(data13);
                        }
                        this.push(null);
                        if (cb) {
                            nextTick2(cb);
                        }
                    }, (err)=>{
                        if (cb) {
                            nextTick2(cb, err);
                        } else {
                            nextTick2(()=>this.destroy(err));
                        }
                    });
                }
            } catch (err) {
                nextTick2(()=>this.destroy(err));
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}
function prefinish1() {
    if (this._final !== __final) {
        __final.call(this);
    }
}
Transform.prototype._final = __final;
Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    let called = false;
    const result = this._transform(chunk, encoding, (err, val)=>{
        called = true;
        if (err) {
            callback(err);
            return;
        }
        if (val != null) {
            this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            callback();
        } else {
            this[kCallback] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, (val)=>{
                    if (called) {
                        return;
                    }
                    if (val != null) {
                        this.push(val);
                    }
                    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
                        nextTick1(callback);
                    } else {
                        this[kCallback] = callback;
                    }
                }, (err)=>{
                    nextTick1(callback, err);
                });
            }
        } catch (err) {
            nextTick1(callback, err);
        }
    }
};
Transform.prototype._read = function() {
    if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
    }
};
Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) {
        return new PassThrough(options);
    }
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};
function destroyer1(stream, reading, writing, callback) {
    callback = once(callback);
    let finished2 = false;
    stream.on("close", ()=>{
        finished2 = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, (err)=>{
        finished2 = !err;
        const rState = stream._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            stream.once("end", callback).once("error", callback);
        } else {
            callback(err);
        }
    });
    return (err)=>{
        if (finished2) return;
        finished2 = true;
        __default3.destroyer(stream, err);
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function popCallback(streams) {
    validateCallback(streams[streams.length - 1]);
    return streams.pop();
}
function makeAsyncIterable(val) {
    if (isIterable(val)) {
        return val;
    } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE("val", [
        "Readable",
        "Iterable",
        "AsyncIterable"
    ], val);
}
async function* fromReadable(val) {
    yield* Readable.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish1) {
    let error7;
    let onresolve = null;
    const resume1 = (err)=>{
        if (err) {
            error7 = err;
        }
        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };
    const wait = ()=>new Promise((resolve13, reject)=>{
            if (error7) {
                reject(error7);
            } else {
                onresolve = ()=>{
                    if (error7) {
                        reject(error7);
                    } else {
                        resolve13();
                    }
                };
            }
        });
    writable.on("drain", resume1);
    const cleanup = eos(writable, {
        readable: false
    }, resume1);
    try {
        if (writable.writableNeedDrain) {
            await wait();
        }
        for await (const chunk of iterable){
            if (!writable.write(chunk)) {
                await wait();
            }
        }
        writable.end();
        await wait();
        finish1();
    } catch (err) {
        finish1(error7 !== err ? aggregateTwoErrors(error7, err) : err);
    } finally{
        cleanup();
        writable.off("drain", resume1);
    }
}
function pipeline(...streams) {
    const callback = once(popCallback(streams));
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }
    return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
        finishImpl(new AbortError());
    }
    outerSignal?.addEventListener("abort", abort);
    let error8;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish2(err) {
        finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, __final2) {
        if (err && (!error8 || error8.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error8 = err;
        }
        if (!error8 && !__final2) {
            return;
        }
        while(destroys.length){
            destroys.shift()(error8);
        }
        outerSignal?.removeEventListener("abort", abort);
        ac.abort();
        if (__final2) {
            callback(error8, value);
        }
    }
    let ret32;
    for(let i110 = 0; i110 < streams.length; i110++){
        const stream = streams[i110];
        const reading = i110 < streams.length - 1;
        const writing = i110 > 0;
        if (isNodeStream(stream)) {
            finishCount++;
            destroys.push(destroyer1(stream, reading, writing, finish2));
        }
        if (i110 === 0) {
            if (typeof stream === "function") {
                ret32 = stream({
                    signal
                });
                if (!isIterable(ret32)) {
                    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret32);
                }
            } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                ret32 = stream;
            } else {
                ret32 = Duplex.from(stream);
            }
        } else if (typeof stream === "function") {
            ret32 = makeAsyncIterable(ret32);
            ret32 = stream(ret32, {
                signal
            });
            if (reading) {
                if (!isIterable(ret32, true)) {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i110 - 1}]`, ret32);
                }
            } else {
                const pt = new PassThrough({
                    objectMode: true
                });
                const then = ret32?.then;
                if (typeof then === "function") {
                    then.call(ret32, (val)=>{
                        value = val;
                        pt.end(val);
                    }, (err)=>{
                        pt.destroy(err);
                    });
                } else if (isIterable(ret32, true)) {
                    finishCount++;
                    pump(ret32, pt, finish2);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret32);
                }
                ret32 = pt;
                finishCount++;
                destroys.push(destroyer1(ret32, false, true, finish2));
            }
        } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret32)) {
                ret32.pipe(stream);
                if (stream === stdio.stdout || stream === stdio.stderr) {
                    ret32.on("end", ()=>stream.end());
                }
            } else {
                ret32 = makeAsyncIterable(ret32);
                finishCount++;
                pump(ret32, stream, finish2);
            }
            ret32 = stream;
        } else {
            ret32 = Duplex.from(stream);
        }
    }
    if (signal?.aborted || outerSignal?.aborted) {
        nextTick2(abort);
    }
    return ret32;
}
class ComposeDuplex extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function compose(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
        return Duplex.from(streams[0]);
    }
    const orgStreams = [
        ...streams
    ];
    if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
    }
    for(let n = 0; n < streams.length; ++n){
        if (!isNodeStream(streams[n])) {
            continue;
        }
        if (n < streams.length - 1 && !isReadable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !isWritable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!isWritable1(head);
    const readable = !!isReadable1(tail);
    d = new ComposeDuplex({
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable
    });
    if (writable) {
        d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            head.end();
            onfinish = callback;
        };
        head.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        tail.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        tail.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        tail.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = tail.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(tail, err);
        }
    };
    return d;
}
function pipeline1(...streams) {
    return new Promise((resolve14, reject)=>{
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }
        pipelineImpl(streams, (err, value)=>{
            if (err) {
                reject(err);
            } else {
                resolve14(value);
            }
        }, {
            signal,
            end
        });
    });
}
function finished(stream, opts) {
    return new Promise((resolve15, reject)=>{
        eos(stream, opts, (err)=>{
            if (err) {
                reject(err);
            } else {
                resolve15();
            }
        });
    });
}
const __default4 = {
    finished,
    pipeline: pipeline1
};
const { custom: customPromisify  } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose;
Object.defineProperty(Stream, "promises", {
    configurable: true,
    enumerable: true,
    get () {
        return __default4;
    }
});
Object.defineProperty(pipeline, customPromisify, {
    enumerable: true,
    get () {
        return __default4.pipeline;
    }
});
Object.defineProperty(eos, customPromisify, {
    enumerable: true,
    get () {
        return __default4.finished;
    }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
function createWritableStdioStream(writer, name47) {
    const stream = new Writable({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name47} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer.from(buf, enc));
            cb();
        },
        destroy (err, cb) {
            cb(err);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close"));
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close());
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : undefined
        }
    });
    return stream;
}
const stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
const stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
const stdin = stdio.stdin = new Readable({
    highWaterMark: 0,
    emitClose: false,
    read (size20) {
        const p = Buffer.alloc(size20 || 16 * 1024);
        if (!Deno.stdin) {
            this.destroy(new Error("Deno.stdin is not available in this environment"));
            return;
        }
        Deno.stdin.read(p).then((length)=>{
            this.push(length === null ? null : p.slice(0, length));
        }, (error9)=>{
            this.destroy(error9);
        });
    }
});
stdin.on("close", ()=>Deno.stdin?.close());
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable)=>{
    setRaw?.(Deno.stdin?.rid, enable);
    stdin._isRawMode = enable;
    return stdin;
};
Object.defineProperty(stdin, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin._isRawMode;
    }
});
function registerDestroyHook(_target, _asyncId, _prop) {}
var constants;
(function(constants5) {
    constants5[constants5["kInit"] = 0] = "kInit";
    constants5[constants5["kBefore"] = 1] = "kBefore";
    constants5[constants5["kAfter"] = 2] = "kAfter";
    constants5[constants5["kDestroy"] = 3] = "kDestroy";
    constants5[constants5["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants5[constants5["kTotals"] = 5] = "kTotals";
    constants5[constants5["kCheck"] = 6] = "kCheck";
    constants5[constants5["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants5[constants5["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants5[constants5["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants5[constants5["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants5[constants5["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants5[constants5["kStackLength"] = 12] = "kStackLength";
})(constants || (constants = {}));
const asyncHookFields = new Uint32Array(Object.keys(constants).length);
function newAsyncId() {
    return ++asyncIdFields[constants.kAsyncIdCounter];
}
var UidFields;
(function(UidFields1) {
    UidFields1[UidFields1["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields1[UidFields1["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields1[UidFields1["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields1[UidFields1["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields1[UidFields1["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
const asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType1) {
    providerType1[providerType1["NONE"] = 0] = "NONE";
    providerType1[providerType1["GETADDRINFOREQWRAP"] = 1] = "GETADDRINFOREQWRAP";
    providerType1[providerType1["PIPECONNECTWRAP"] = 2] = "PIPECONNECTWRAP";
    providerType1[providerType1["PIPESERVERWRAP"] = 3] = "PIPESERVERWRAP";
    providerType1[providerType1["PIPEWRAP"] = 4] = "PIPEWRAP";
    providerType1[providerType1["SHUTDOWNWRAP"] = 5] = "SHUTDOWNWRAP";
    providerType1[providerType1["TCPCONNECTWRAP"] = 6] = "TCPCONNECTWRAP";
    providerType1[providerType1["TCPSERVERWRAP"] = 7] = "TCPSERVERWRAP";
    providerType1[providerType1["TCPWRAP"] = 8] = "TCPWRAP";
    providerType1[providerType1["WRITEWRAP"] = 9] = "WRITEWRAP";
})(providerType || (providerType = {}));
const kInvalidAsyncId = -1;
class AsyncWrap {
    provider = providerType.NONE;
    asyncId = kInvalidAsyncId;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod8 = {
    async_hook_fields: asyncHookFields,
    asyncIdFields: asyncIdFields,
    registerDestroyHook: registerDestroyHook,
    constants: constants,
    newAsyncId: newAsyncId,
    UidFields: UidFields,
    providerType: providerType,
    AsyncWrap: AsyncWrap
};
const mod9 = {};
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
const IPv4Reg = new RegExp(`^${v4Str}$`);
const v6Seg = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv4(ip) {
    return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
    return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    }
    if (isIPv6(ip)) {
        return 6;
    }
    return 0;
}
Symbol("normalizedArgs");
const ARES_AI_CANONNAME = 1 << 0;
const ARES_AI_NUMERICHOST = 1 << 1;
const ARES_AI_PASSIVE = 1 << 2;
const ARES_AI_NUMERICSERV = 1 << 3;
const AI_V4MAPPED = 1 << 4;
const AI_ALL = 1 << 5;
const AI_ADDRCONFIG = 1 << 6;
const ARES_AI_NOSORT = 1 << 7;
const ARES_AI_ENVHOSTS = 1 << 8;
class GetAddrInfoReqWrap extends AsyncWrap {
    callback;
    family;
    hostname;
    oncomplete;
    constructor(){
        super(providerType.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo(req, hostname4, family, _hints, verbatim) {
    (async ()=>{
        const addresses = [];
        const recordTypes = [];
        if (family === 0 || family === 4) {
            recordTypes.push("A");
        }
        if (family === 0 || family === 6) {
            recordTypes.push("AAAA");
        }
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname4, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record));
            })));
        const error10 = addresses.length ? null : codeMap.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a, b23)=>{
                if (isIPv4(a)) {
                    return -1;
                } else if (isIPv4(b23)) {
                    return 1;
                }
                return 0;
            });
        }
        req.oncomplete(error10, addresses);
    })();
}
const mod10 = {
    ARES_AI_CANONNAME: ARES_AI_CANONNAME,
    ARES_AI_NUMERICHOST: ARES_AI_NUMERICHOST,
    ARES_AI_PASSIVE: ARES_AI_PASSIVE,
    ARES_AI_NUMERICSERV: ARES_AI_NUMERICSERV,
    AI_V4MAPPED: AI_V4MAPPED,
    AI_ALL: AI_ALL,
    AI_ADDRCONFIG: AI_ADDRCONFIG,
    ARES_AI_NOSORT: ARES_AI_NOSORT,
    ARES_AI_ENVHOSTS: ARES_AI_ENVHOSTS,
    GetAddrInfoReqWrap: GetAddrInfoReqWrap,
    getaddrinfo: getaddrinfo
};
const mod11 = {};
const mod12 = {};
const mod13 = {};
const mod14 = {};
const mod15 = {};
const mod16 = {};
const mod17 = {};
const mod18 = {};
const mod19 = {};
const mod20 = {};
const mod21 = {};
const mod22 = {};
const mod23 = {};
const mod24 = {};
const mod25 = {};
const mod26 = {};
const mod27 = {};
const mod28 = {};
class HandleWrap extends AsyncWrap {
    constructor(provider){
        super(provider);
    }
    async close(cb = ()=>{}) {
        await this._onClose();
        nextTick2(cb);
    }
    ref() {
        notImplemented();
    }
    unref() {
        notImplemented();
    }
    async _onClose() {}
}
var StreamBaseStateFields;
(function(StreamBaseStateFields1) {
    StreamBaseStateFields1[StreamBaseStateFields1["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields1[StreamBaseStateFields1["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields1[StreamBaseStateFields1["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields1[StreamBaseStateFields1["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields1[StreamBaseStateFields1["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
const kBytesWritten = StreamBaseStateFields.kBytesWritten;
const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
const kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
const streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
class WriteWrap extends AsyncWrap {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType.WRITEWRAP);
    }
}
class ShutdownWrap extends AsyncWrap {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType.SHUTDOWNWRAP);
    }
}
const kStreamBaseField = Symbol("kStreamBaseField");
const SUGGESTED_SIZE = 64 * 1024;
class LibuvStreamWrap extends HandleWrap {
    [kStreamBaseField];
    reading;
    #reading = false;
    #currentReads = new Set();
    #currentWrites = new Set();
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            const readPromise = this.#read();
            this.#currentReads.add(readPromise);
            readPromise.then(()=>this.#currentReads.delete(readPromise), ()=>this.#currentReads.delete(readPromise));
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        (async ()=>{
            const status = await this._onClose();
            try {
                req.oncomplete(status);
            } catch  {}
        })();
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented();
    }
    writeBuffer(req, data14) {
        const currentWrite = this.#write(req, data14);
        this.#currentWrites.add(currentWrite);
        currentWrite.then(()=>this.#currentWrites.delete(currentWrite), ()=>this.#currentWrites.delete(currentWrite));
        return 0;
    }
    writev(_req, _chunks, _allBuffers) {
        notImplemented();
    }
    writeAsciiString(req, data15) {
        const buffer23 = new TextEncoder().encode(data15);
        return this.writeBuffer(req, buffer23);
    }
    writeUtf8String(req, data16) {
        const buffer24 = new TextEncoder().encode(data16);
        return this.writeBuffer(req, buffer24);
    }
    writeUcs2String(_req, _data) {
        notImplemented();
    }
    writeLatin1String(req, data17) {
        const buffer25 = Buffer.from(data17, "latin1");
        return this.writeBuffer(req, buffer25);
    }
    async _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField]?.close();
        } catch  {
            status = codeMap.get("ENOTCONN");
        }
        await Promise.allSettled(this.#currentWrites);
        await Promise.allSettled(this.#currentReads);
        return status;
    }
     #attachToObject(stream) {
        this[kStreamBaseField] = stream;
    }
    async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
            nread = await this[kStreamBaseField].read(buf);
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = codeMap.get("EOF");
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
            this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
            this.onread(buf, nread);
        } catch  {}
        if (nread >= 0 && this.#reading) {
            const readPromise = this.#read();
            this.#currentReads.add(readPromise);
            readPromise.then(()=>this.#currentReads.delete(readPromise), ()=>this.#currentReads.delete(readPromise));
        }
    }
    async #write(req, data18) {
        const { byteLength  } = data18;
        try {
            await writeAll(this[kStreamBaseField], data18);
        } catch  {
            const status = codeMap.get("UNKNOWN");
            try {
                req.oncomplete(status);
            } catch  {}
            return;
        }
        streamBaseState[kBytesWritten] = byteLength;
        this.bytesWritten += byteLength;
        try {
            req.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod29 = {
    kReadBytesOrError: kReadBytesOrError,
    kArrayBufferOffset: kArrayBufferOffset,
    kBytesWritten: kBytesWritten,
    kLastWriteWasAsync: kLastWriteWasAsync,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields,
    streamBaseState: streamBaseState,
    WriteWrap: WriteWrap,
    ShutdownWrap: ShutdownWrap,
    kStreamBaseField: kStreamBaseField,
    LibuvStreamWrap: LibuvStreamWrap
};
class ConnectionWrap extends LibuvStreamWrap {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req1, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req1.oncomplete(status, this, req1, readable, writable);
        } catch  {}
        return;
    }
}
var socketType;
(function(socketType2) {
    socketType2[socketType2["SOCKET"] = 0] = "SOCKET";
    socketType2[socketType2["SERVER"] = 1] = "SERVER";
    socketType2[socketType2["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
class Pipe extends ConnectionWrap {
    reading = false;
    ipc;
    constructor(type37){
        let provider;
        let ipc;
        switch(type37){
            case socketType.SOCKET:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType.SERVER:
                {
                    provider = providerType.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType.IPC:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider);
        this.ipc = ipc;
    }
    bind() {
        notImplemented();
    }
    listen() {
        notImplemented();
    }
    connect(_req, _address, _afterConnect) {
        notImplemented();
    }
    open(_fd) {
        notImplemented();
    }
    setPendingInstances(_instances) {
        notImplemented();
    }
    fchmod() {
        notImplemented();
    }
}
class PipeConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    constructor(){
        super(providerType.PIPECONNECTWRAP);
    }
}
var constants1;
(function(constants6) {
    constants6[constants6["SOCKET"] = socketType.SOCKET] = "SOCKET";
    constants6[constants6["SERVER"] = socketType.SERVER] = "SERVER";
    constants6[constants6["IPC"] = socketType.IPC] = "IPC";
    constants6[constants6["UV_READABLE"] = 0] = "UV_READABLE";
    constants6[constants6["UV_WRITABLE"] = 1] = "UV_WRITABLE";
})(constants1 || (constants1 = {}));
const mod30 = {
    socketType: socketType,
    Pipe: Pipe,
    PipeConnectWrap: PipeConnectWrap,
    constants: constants1
};
const mod31 = {};
const mod32 = {};
const mod33 = {};
const mod34 = {};
const mod35 = {};
const mod36 = {};
const asyncIdSymbol = Symbol("asyncIdSymbol");
const ownerSymbol = Symbol("ownerSymbol");
const mod37 = {
    asyncIdSymbol: asyncIdSymbol,
    ownerSymbol: ownerSymbol
};
const mod38 = {};
var socketType1;
(function(socketType3) {
    socketType3[socketType3["SOCKET"] = 0] = "SOCKET";
    socketType3[socketType3["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
function _ceilPowOf2(n) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n);
    return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
class TCPConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType.TCPCONNECTWRAP);
    }
}
var constants2;
(function(constants7) {
    constants7[constants7["SOCKET"] = socketType1.SOCKET] = "SOCKET";
    constants7[constants7["SERVER"] = socketType1.SERVER] = "SERVER";
    constants7[constants7["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants2 || (constants2 = {}));
class TCP extends ConnectionWrap {
    [ownerSymbol] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type38, conn){
        let provider;
        switch(type38){
            case socketType1.SOCKET:
                {
                    provider = providerType.TCPWRAP;
                    break;
                }
            case socketType1.SERVER:
                {
                    provider = providerType.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4";
        }
    }
    open(_fd) {
        notImplemented();
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req2, address, port) {
        return this.#connect(req2, address, port);
    }
    connect6(req3, address, port) {
        return this.#connect(req3, address, port);
    }
    listen(backlog) {
        this.#backlog = _ceilPowOf2(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address) === 6 ? "IPv6" : "IPv4";
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented();
    }
     #bind(address, port, _flags) {
        this.#address = address;
        this.#port = port;
        return 0;
    }
     #connect(req4, address1, port1) {
        this.#remoteAddress = address1;
        this.#remotePort = port1;
        this.#remoteFamily = isIP(address1) === 6 ? "IPv6" : "IPv4";
        const connectOptions = {
            hostname: address1,
            port: port1,
            transport: "tcp"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req4.localAddress = localAddr.hostname;
            this.#port = req4.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req4, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req4, codeMap.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new TCP(socketType1.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    async _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return await LibuvStreamWrap.prototype._onClose.call(this);
    }
}
const mod39 = {
    TCPConnectWrap: TCPConnectWrap,
    constants: constants2,
    TCP: TCP
};
const mod40 = {};
const mod41 = {};
const mod42 = {};
const mod43 = {};
const mod44 = {};
const mod45 = {};
const mod46 = {};
const mod47 = {};
const mod48 = {};
const modules = {
    "async_wrap": mod8,
    buffer: mod5,
    "cares_wrap": mod10,
    config: mod9,
    constants: mod2,
    contextify: mod11,
    credentials: mod13,
    crypto: mod12,
    errors: mod14,
    fs: mod15,
    "fs_dir": mod16,
    "fs_event_wrap": mod17,
    "heap_utils": mod18,
    "http_parser": mod19,
    icu: mod20,
    inspector: mod21,
    "js_stream": mod22,
    messaging: mod23,
    "module_wrap": mod24,
    "native_module": mod25,
    natives: mod26,
    options: mod27,
    os: mod28,
    performance: mod31,
    "pipe_wrap": mod30,
    "process_methods": mod32,
    report: mod33,
    serdes: mod34,
    "signal_wrap": mod35,
    "spawn_sync": mod36,
    "stream_wrap": mod29,
    "string_decoder": mod4,
    symbols: mod37,
    "task_queue": mod38,
    "tcp_wrap": mod39,
    timers: mod40,
    "tls_wrap": mod41,
    "trace_events": mod42,
    "tty_wrap": mod43,
    types: mod,
    "udp_wrap": mod44,
    url: mod45,
    util: mod1,
    uv: mod3,
    v8: mod46,
    worker: mod47,
    zlib: mod48
};
function getBinding(name48) {
    const mod62 = modules[name48];
    if (!mod62) {
        throw new Error(`No such module: ${name48}`);
    }
    return mod62;
}
const kInternal = Symbol("internal properties");
const replaceUnderscoresRegex = /_/g;
const leadingDashesRegex = /^--?/;
const trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
    const allowedNodeEnvironmentFlags = [
        "--track-heap-objects",
        "--no-track-heap-objects",
        "--node-snapshot",
        "--no-node-snapshot",
        "--require",
        "--max-old-space-size",
        "--trace-exit",
        "--no-trace-exit",
        "--disallow-code-generation-from-strings",
        "--experimental-json-modules",
        "--no-experimental-json-modules",
        "--interpreted-frames-native-stack",
        "--inspect-brk",
        "--no-inspect-brk",
        "--trace-tls",
        "--no-trace-tls",
        "--stack-trace-limit",
        "--experimental-repl-await",
        "--no-experimental-repl-await",
        "--preserve-symlinks",
        "--no-preserve-symlinks",
        "--report-uncaught-exception",
        "--no-report-uncaught-exception",
        "--experimental-modules",
        "--no-experimental-modules",
        "--report-signal",
        "--jitless",
        "--inspect-port",
        "--heapsnapshot-near-heap-limit",
        "--tls-keylog",
        "--force-context-aware",
        "--no-force-context-aware",
        "--napi-modules",
        "--abort-on-uncaught-exception",
        "--diagnostic-dir",
        "--verify-base-objects",
        "--no-verify-base-objects",
        "--unhandled-rejections",
        "--perf-basic-prof",
        "--trace-atomics-wait",
        "--no-trace-atomics-wait",
        "--deprecation",
        "--no-deprecation",
        "--perf-basic-prof-only-functions",
        "--perf-prof",
        "--max-http-header-size",
        "--report-on-signal",
        "--no-report-on-signal",
        "--throw-deprecation",
        "--no-throw-deprecation",
        "--warnings",
        "--no-warnings",
        "--force-fips",
        "--no-force-fips",
        "--pending-deprecation",
        "--no-pending-deprecation",
        "--input-type",
        "--tls-max-v1.3",
        "--no-tls-max-v1.3",
        "--tls-min-v1.2",
        "--no-tls-min-v1.2",
        "--inspect",
        "--no-inspect",
        "--heapsnapshot-signal",
        "--trace-warnings",
        "--no-trace-warnings",
        "--trace-event-categories",
        "--experimental-worker",
        "--tls-max-v1.2",
        "--no-tls-max-v1.2",
        "--perf-prof-unwinding-info",
        "--preserve-symlinks-main",
        "--no-preserve-symlinks-main",
        "--policy-integrity",
        "--experimental-wasm-modules",
        "--no-experimental-wasm-modules",
        "--node-memory-debug",
        "--inspect-publish-uid",
        "--tls-min-v1.3",
        "--no-tls-min-v1.3",
        "--experimental-specifier-resolution",
        "--secure-heap",
        "--tls-min-v1.0",
        "--no-tls-min-v1.0",
        "--redirect-warnings",
        "--experimental-report",
        "--trace-event-file-pattern",
        "--trace-uncaught",
        "--no-trace-uncaught",
        "--experimental-loader",
        "--http-parser",
        "--dns-result-order",
        "--trace-sigint",
        "--no-trace-sigint",
        "--secure-heap-min",
        "--enable-fips",
        "--no-enable-fips",
        "--enable-source-maps",
        "--no-enable-source-maps",
        "--insecure-http-parser",
        "--no-insecure-http-parser",
        "--use-openssl-ca",
        "--no-use-openssl-ca",
        "--tls-cipher-list",
        "--experimental-top-level-await",
        "--no-experimental-top-level-await",
        "--openssl-config",
        "--icu-data-dir",
        "--v8-pool-size",
        "--report-on-fatalerror",
        "--no-report-on-fatalerror",
        "--title",
        "--tls-min-v1.1",
        "--no-tls-min-v1.1",
        "--report-filename",
        "--trace-deprecation",
        "--no-trace-deprecation",
        "--report-compact",
        "--no-report-compact",
        "--experimental-policy",
        "--experimental-import-meta-resolve",
        "--no-experimental-import-meta-resolve",
        "--zero-fill-buffers",
        "--no-zero-fill-buffers",
        "--report-dir",
        "--use-bundled-ca",
        "--no-use-bundled-ca",
        "--experimental-vm-modules",
        "--no-experimental-vm-modules",
        "--force-async-hooks-checks",
        "--no-force-async-hooks-checks",
        "--frozen-intrinsics",
        "--no-frozen-intrinsics",
        "--huge-max-old-generation-size",
        "--disable-proto",
        "--debug-arraybuffer-allocations",
        "--no-debug-arraybuffer-allocations",
        "--conditions",
        "--experimental-wasi-unstable-preview1",
        "--no-experimental-wasi-unstable-preview1",
        "--trace-sync-io",
        "--no-trace-sync-io",
        "--use-largepages",
        "--experimental-abortcontroller",
        "--debug-port",
        "--es-module-specifier-resolution",
        "--prof-process",
        "-C",
        "--loader",
        "--report-directory",
        "-r",
        "--trace-events-enabled", 
    ];
    const trimLeadingDashes = (flag)=>flag.replace(leadingDashesRegex, "");
    const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
    class NodeEnvironmentFlagsSet extends Set {
        constructor(array){
            super();
            this[kInternal] = {
                array
            };
        }
        add() {
            return this;
        }
        delete() {
            return false;
        }
        clear() {}
        has(key) {
            if (typeof key === "string") {
                key = key.replace(replaceUnderscoresRegex, "-");
                if (leadingDashesRegex.test(key)) {
                    key = key.replace(trailingValuesRegex, "");
                    return this[kInternal].array.includes(key);
                }
                return nodeFlags.includes(key);
            }
            return false;
        }
        entries() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.entries();
        }
        forEach(callback, thisArg = undefined) {
            this[kInternal].array.forEach((v)=>Reflect.apply(callback, thisArg, [
                    v,
                    v,
                    this
                ]));
        }
        get size() {
            return this[kInternal].array.length;
        }
        values() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.values();
        }
    }
    NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
    Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
    Object.freeze(NodeEnvironmentFlagsSet.prototype);
    return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
const notImplementedEvents = [
    "beforeExit",
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "uncaughtException",
    "uncaughtExceptionMonitor",
    "unhandledRejection",
    "worker", 
];
const argv = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv, "1", {
    get: ()=>fromFileUrl2(Deno.mainModule)
});
const exit = (code36)=>{
    if (code36 || code36 === 0) {
        if (typeof code36 === "string") {
            const parsedCode = parseInt(code36);
            process1.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process1.exitCode = code36;
        }
    }
    if (!process1._exiting) {
        process1._exiting = true;
        process1.emit("exit", process1.exitCode || 0);
    }
    Deno.exit(process1.exitCode || 0);
};
function addReadOnlyProcessAlias(name49, option, enumerable = true) {
    const value = getOptionValue(option);
    if (value) {
        Object.defineProperty(process1, name49, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject(warning, type39, code37, ctor, detail) {
    assert1(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type39 || "Warning");
    if (code37 !== undefined) {
        warningErr.code = code37;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process1.emitWarning);
    return warningErr;
}
function doEmitWarning(warning) {
    process1.emit("warning", warning);
}
function emitWarning(warning, type40, code38, ctor) {
    let detail;
    if (type40 !== null && typeof type40 === "object" && !Array.isArray(type40)) {
        ctor = type40.ctor;
        code38 = type40.code;
        if (typeof type40.detail === "string") {
            detail = type40.detail;
        }
        type40 = type40.type || "Warning";
    } else if (typeof type40 === "function") {
        ctor = type40;
        code38 = undefined;
        type40 = "Warning";
    }
    if (type40 !== undefined) {
        validateString(type40, "type");
    }
    if (typeof code38 === "function") {
        ctor = code38;
        code38 = undefined;
    } else if (code38 !== undefined) {
        validateString(code38, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject(warning, type40, code38, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process1.noDeprecation) {
            return;
        }
        if (process1.throwDeprecation) {
            return process1.nextTick(()=>{
                throw warning;
            });
        }
    }
    process1.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1_000_000 - sec * 1_000_000_000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime.bigint = function() {
    const [sec, nano] = hrtime();
    return BigInt(sec) * 1_000_000_000n + BigInt(nano);
};
function memoryUsage() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage.rss = function() {
    return memoryUsage().rss;
};
function kill(pid1, sig = "SIGTERM") {
    if (pid1 != (pid1 | 0)) {
        throw new ERR_INVALID_ARG_TYPE("pid", "number", pid1);
    }
    if (typeof sig === "string") {
        try {
            Deno.kill(pid1, sig);
        } catch (e) {
            if (e instanceof TypeError) {
                throw new ERR_UNKNOWN_SIGNAL(sig);
            }
            throw e;
        }
    } else {
        throw new ERR_UNKNOWN_SIGNAL(sig.toString());
    }
    return true;
}
class Process extends EventEmitter {
    constructor(){
        super();
        globalThis.addEventListener("unload", ()=>{
            if (!process1._exiting) {
                process1._exiting = true;
                super.emit("exit", process1.exitCode || 0);
            }
        });
    }
    arch = arch;
    argv = argv;
    chdir = chdir;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd;
    env = env;
    execArgv = [];
    exit = exit;
    _exiting = _exiting;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick2;
    on(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.on("${event}")`);
            super.on(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener(event, listener);
            }
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.off("${event}")`);
            super.off(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                removeSignalListener(event, listener);
            }
        } else {
            super.off(event, listener);
        }
        return this;
    }
    emit(event, ...args) {
        if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.kill(Deno.pid, event);
            }
        } else {
            return super.emit(event, ...args);
        }
        return true;
    }
    prependListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.prependListener("${event}")`);
            super.prependListener(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener(event, listener);
            }
        } else {
            super.prependListener(event, listener);
        }
        return this;
    }
    pid = pid;
    platform = platform;
    addListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.addListener("${event}")`);
        }
        return this.on(event, listener);
    }
    removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.removeListener("${event}")`);
        }
        return this.off(event, listener);
    }
    hrtime = hrtime;
    kill = kill;
    memoryUsage = memoryUsage;
    stderr = stderr;
    stdin = stdin;
    stdout = stdout;
    version = version;
    versions = versions;
    emitWarning = emitWarning;
    binding(name50) {
        return getBinding(name50);
    }
    umask() {
        return 0o22;
    }
    getuid() {
        return NaN;
    }
    getgid() {
        return NaN;
    }
    _eval = undefined;
    get execPath() {
        return argv[0];
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
    #allowedFlags = buildAllowedFlags();
    get allowedNodeEnvironmentFlags() {
        return this.#allowedFlags;
    }
    features = {
        inspector: false
    };
}
const process1 = new Process();
Object.defineProperty(process1, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process1.removeListener;
process1.removeAllListeners;
var EOL;
(function(EOL2) {
    EOL2["LF"] = "\n";
    EOL2["CRLF"] = "\r\n";
})(EOL || (EOL = {}));
const SEE_GITHUB_ISSUE = "See https://github.com/denoland/deno_std/issues/1436";
function arch1() {
    return process1.arch;
}
arch1[Symbol.toPrimitive] = ()=>process1.arch;
endianness[Symbol.toPrimitive] = ()=>endianness();
freemem[Symbol.toPrimitive] = ()=>freemem();
homedir[Symbol.toPrimitive] = ()=>homedir();
hostname1[Symbol.toPrimitive] = ()=>hostname1();
platform1[Symbol.toPrimitive] = ()=>platform1();
release[Symbol.toPrimitive] = ()=>release();
totalmem[Symbol.toPrimitive] = ()=>totalmem();
type[Symbol.toPrimitive] = ()=>type();
uptime[Symbol.toPrimitive] = ()=>uptime();
function cpus() {
    return Array.from(Array(navigator.hardwareConcurrency)).map(()=>{
        return {
            model: "",
            speed: 0,
            times: {
                user: 0,
                nice: 0,
                sys: 0,
                idle: 0,
                irq: 0
            }
        };
    });
}
function endianness() {
    const buffer26 = new ArrayBuffer(2);
    new DataView(buffer26).setInt16(0, 256, true);
    return new Int16Array(buffer26)[0] === 256 ? "LE" : "BE";
}
function freemem() {
    return systemMemoryInfo().free;
}
function getPriority(pid2 = 0) {
    validateIntegerRange(pid2, "pid");
    notImplemented(SEE_GITHUB_ISSUE);
}
function homedir() {
    switch(osType){
        case "windows":
            return Deno.env.get("USERPROFILE") || null;
        case "linux":
        case "darwin":
            return Deno.env.get("HOME") || null;
        default:
            throw Error("unreachable");
    }
}
function hostname1() {
    return hostname();
}
function loadavg1() {
    if (isWindows) {
        return [
            0,
            0,
            0
        ];
    }
    return loadavg();
}
function networkInterfaces1() {
    const interfaces = {};
    for (const { name: name51 , address: address2 , netmask , family , mac , scopeid , cidr  } of networkInterfaces()){
        const addresses = interfaces[name51] ||= [];
        const networkAddress = {
            address: address2,
            netmask,
            family,
            mac,
            internal: family === "IPv4" && isIPv4LoopbackAddr(address2) || family === "IPv6" && isIPv6LoopbackAddr(address2),
            cidr
        };
        if (family === "IPv6") {
            networkAddress.scopeid = scopeid;
        }
        addresses.push(networkAddress);
    }
    return interfaces;
}
function isIPv4LoopbackAddr(addr) {
    return addr.startsWith("127");
}
function isIPv6LoopbackAddr(addr) {
    return addr === "::1" || addr === "fe80::1";
}
function platform1() {
    return process1.platform;
}
function release() {
    return osRelease();
}
function setPriority(pid3, priority) {
    if (priority === undefined) {
        priority = pid3;
        pid3 = 0;
    }
    validateIntegerRange(pid3, "pid");
    validateIntegerRange(priority, "priority", -20, 19);
    notImplemented(SEE_GITHUB_ISSUE);
}
function tmpdir() {
    if (isWindows) {
        const temp = Deno.env.get("TEMP") || Deno.env.get("TMP");
        if (temp) {
            return temp.replace(/(?<!:)[/\\]*$/, "");
        }
        const base9 = Deno.env.get("SYSTEMROOT") || Deno.env.get("WINDIR");
        if (base9) {
            return base9 + "\\temp";
        }
        return null;
    } else {
        const temp = Deno.env.get("TMPDIR") || Deno.env.get("TMP") || Deno.env.get("TEMP") || "/tmp";
        return temp.replace(/(?<!^)\/*$/, "");
    }
}
function totalmem() {
    return systemMemoryInfo().total;
}
function type() {
    switch(Deno.build.os){
        case "windows":
            return "Windows_NT";
        case "linux":
            return "Linux";
        case "darwin":
            return "Darwin";
        default:
            throw Error("unreachable");
    }
}
function uptime() {
    notImplemented(SEE_GITHUB_ISSUE);
}
function userInfo(options = {
    encoding: "utf-8"
}) {
    notImplemented(SEE_GITHUB_ISSUE);
}
const constants3 = {
    dlopen: {},
    errno: {},
    signals: {
        "SIGABRT": "SIGABRT",
        "SIGALRM": "SIGALRM",
        "SIGBUS": "SIGBUS",
        "SIGCHLD": "SIGCHLD",
        "SIGCONT": "SIGCONT",
        "SIGEMT": "SIGEMT",
        "SIGFPE": "SIGFPE",
        "SIGHUP": "SIGHUP",
        "SIGILL": "SIGILL",
        "SIGINFO": "SIGINFO",
        "SIGINT": "SIGINT",
        "SIGIO": "SIGIO",
        "SIGKILL": "SIGKILL",
        "SIGPIPE": "SIGPIPE",
        "SIGPROF": "SIGPROF",
        "SIGPWR": "SIGPWR",
        "SIGQUIT": "SIGQUIT",
        "SIGSEGV": "SIGSEGV",
        "SIGSTKFLT": "SIGSTKFLT",
        "SIGSTOP": "SIGSTOP",
        "SIGSYS": "SIGSYS",
        "SIGTERM": "SIGTERM",
        "SIGTRAP": "SIGTRAP",
        "SIGTSTP": "SIGTSTP",
        "SIGTTIN": "SIGTTIN",
        "SIGTTOU": "SIGTTOU",
        "SIGURG": "SIGURG",
        "SIGUSR1": "SIGUSR1",
        "SIGUSR2": "SIGUSR2",
        "SIGVTALRM": "SIGVTALRM",
        "SIGWINCH": "SIGWINCH",
        "SIGXCPU": "SIGXCPU",
        "SIGXFSZ": "SIGXFSZ"
    },
    priority: {}
};
const EOL1 = isWindows ? EOL.CRLF : EOL.LF;
const devNull = isWindows ? "\\\\.\\nul" : "/dev/null";
const __default5 = {
    arch: arch1,
    cpus,
    endianness,
    freemem,
    getPriority,
    homedir,
    hostname: hostname1,
    loadavg: loadavg1,
    networkInterfaces: networkInterfaces1,
    platform: platform1,
    release,
    setPriority,
    tmpdir,
    totalmem,
    type,
    uptime,
    userInfo,
    constants: constants3,
    EOL: EOL1,
    devNull
};
function isFileOptions(fileOptions) {
    if (!fileOptions) return false;
    return fileOptions.encoding != undefined || fileOptions.flag != undefined || fileOptions.signal != undefined || fileOptions.mode != undefined;
}
function getEncoding(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    }
    const encoding = typeof optOrCallback === "string" ? optOrCallback : optOrCallback.encoding;
    if (!encoding) return null;
    return encoding;
}
function checkEncoding(encoding) {
    if (!encoding) return null;
    encoding = encoding.toLowerCase();
    if ([
        "utf8",
        "hex",
        "base64"
    ].includes(encoding)) return encoding;
    if (encoding === "utf-8") {
        return "utf8";
    }
    if (encoding === "binary") {
        return "binary";
    }
    const notImplementedEncodings = [
        "utf16le",
        "latin1",
        "ascii",
        "ucs2"
    ];
    if (notImplementedEncodings.includes(encoding)) {
        notImplemented(`"${encoding}" encoding`);
    }
    throw new Error(`The value "${encoding}" is invalid for option "encoding"`);
}
function getOpenOptions(flag) {
    if (!flag) {
        return {
            create: true,
            append: true
        };
    }
    let openOptions;
    switch(flag){
        case "a":
            {
                openOptions = {
                    create: true,
                    append: true
                };
                break;
            }
        case "ax":
            {
                openOptions = {
                    createNew: true,
                    write: true,
                    append: true
                };
                break;
            }
        case "a+":
            {
                openOptions = {
                    read: true,
                    create: true,
                    append: true
                };
                break;
            }
        case "ax+":
            {
                openOptions = {
                    read: true,
                    createNew: true,
                    append: true
                };
                break;
            }
        case "r":
            {
                openOptions = {
                    read: true
                };
                break;
            }
        case "r+":
            {
                openOptions = {
                    read: true,
                    write: true
                };
                break;
            }
        case "w":
            {
                openOptions = {
                    create: true,
                    write: true,
                    truncate: true
                };
                break;
            }
        case "wx":
            {
                openOptions = {
                    createNew: true,
                    write: true
                };
                break;
            }
        case "w+":
            {
                openOptions = {
                    create: true,
                    write: true,
                    truncate: true,
                    read: true
                };
                break;
            }
        case "wx+":
            {
                openOptions = {
                    createNew: true,
                    write: true,
                    read: true
                };
                break;
            }
        case "as":
            {
                openOptions = {
                    create: true,
                    append: true
                };
                break;
            }
        case "as+":
            {
                openOptions = {
                    create: true,
                    read: true,
                    append: true
                };
                break;
            }
        case "rs+":
            {
                openOptions = {
                    create: true,
                    read: true,
                    write: true
                };
                break;
            }
        default:
            {
                throw new Error(`Unrecognized file system flag: ${flag}`);
            }
    }
    return openOptions;
}
function maybeCallback(cb) {
    validateCallback(cb);
    return cb;
}
function makeCallback(cb) {
    validateCallback(cb);
    return (...args)=>Reflect.apply(cb, this, args);
}
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path31) {
    if (typeof path31 !== "string") {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string"
        ], path31);
    }
}
function isPosixPathSeparator1(code39) {
    return code39 === 47;
}
function isPathSeparator1(code40) {
    return isPosixPathSeparator1(code40) || code40 === 92;
}
function isWindowsDeviceRoot1(code41) {
    return code41 >= 97 && code41 <= 122 || code41 >= 65 && code41 <= 90;
}
function normalizeString1(path32, allowAboveRoot, separator, isPathSeparator11) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code42;
    for(let i111 = 0, len = path32.length; i111 <= len; ++i111){
        if (i111 < len) code42 = path32.charCodeAt(i111);
        else if (isPathSeparator11(code42)) break;
        else code42 = CHAR_FORWARD_SLASH1;
        if (isPathSeparator11(code42)) {
            if (lastSlash === i111 - 1 || dots === 1) {} else if (lastSlash !== i111 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i111;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i111;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path32.slice(lastSlash + 1, i111);
                else res = path32.slice(lastSlash + 1, i111);
                lastSegmentLength = i111 - lastSlash - 1;
            }
            lastSlash = i111;
            dots = 0;
        } else if (code42 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep7, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base10 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base10;
    if (dir === pathObject.root) return dir + base10;
    return dir + sep7 + base10;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
const sep3 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i112 = pathSegments.length - 1; i112 >= -1; i112--){
        let path33;
        const { Deno  } = globalThis;
        if (i112 >= 0) {
            path33 = pathSegments[i112];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path33 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path33 = Deno.cwd();
            if (path33 === undefined || path33.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path33 = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path33);
        const len = path33.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute11 = false;
        const code43 = path33.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code43)) {
                isAbsolute11 = true;
                if (isPathSeparator1(path33.charCodeAt(1))) {
                    let j = 2;
                    let last39 = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path33.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last39) {
                        const firstPart = path33.slice(last39, j);
                        last39 = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path33.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last39) {
                            last39 = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path33.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path33.slice(last39)}`;
                                rootEnd = j;
                            } else if (j !== last39) {
                                device = `\\\\${firstPart}\\${path33.slice(last39, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code43)) {
                if (path33.charCodeAt(1) === 58) {
                    device = path33.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path33.charCodeAt(2))) {
                            isAbsolute11 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code43)) {
            rootEnd = 1;
            isAbsolute11 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path33.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute11;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path34) {
    assertPath1(path34);
    const len = path34.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute21 = false;
    const code44 = path34.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code44)) {
            isAbsolute21 = true;
            if (isPathSeparator1(path34.charCodeAt(1))) {
                let j = 2;
                let last40 = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path34.charCodeAt(j))) break;
                }
                if (j < len && j !== last40) {
                    const firstPart = path34.slice(last40, j);
                    last40 = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path34.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last40) {
                        last40 = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path34.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path34.slice(last40)}\\`;
                        } else if (j !== last40) {
                            device = `\\\\${firstPart}\\${path34.slice(last40, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code44)) {
            if (path34.charCodeAt(1) === 58) {
                device = path34.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path34.charCodeAt(2))) {
                        isAbsolute21 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code44)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path34.slice(rootEnd), !isAbsolute21, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute21) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path34.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute21) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute21) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path35) {
    assertPath1(path35);
    const len = path35.length;
    if (len === 0) return false;
    const code45 = path35.charCodeAt(0);
    if (isPathSeparator1(code45)) {
        return true;
    } else if (isWindowsDeviceRoot1(code45)) {
        if (len > 2 && path35.charCodeAt(1) === 58) {
            if (isPathSeparator1(path35.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join6(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i113 = 0; i113 < pathsCount; ++i113){
        const path36 = paths[i113];
        assertPath1(path36);
        if (path36.length > 0) {
            if (joined === undefined) joined = firstPart = path36;
            else joined += `\\${path36}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i114 = 0;
    for(; i114 <= length; ++i114){
        if (i114 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i114) === 92) {
                    return toOrig.slice(toStart + i114 + 1);
                } else if (i114 === 2) {
                    return toOrig.slice(toStart + i114);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i114) === 92) {
                    lastCommonSep = i114;
                } else if (i114 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i114);
        const toCode = to.charCodeAt(toStart + i114);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i114;
    }
    if (i114 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i114 = fromStart + lastCommonSep + 1; i114 <= fromEnd; ++i114){
        if (i114 === fromEnd || from.charCodeAt(i114) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path37) {
    if (typeof path37 !== "string") return path37;
    if (path37.length === 0) return "";
    const resolvedPath = resolve3(path37);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code46 = resolvedPath.charCodeAt(2);
                if (code46 !== 63 && code46 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path37;
}
function dirname3(path38) {
    assertPath1(path38);
    const len = path38.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code47 = path38.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code47)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path38.charCodeAt(1))) {
                let j = 2;
                let last41 = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path38.charCodeAt(j))) break;
                }
                if (j < len && j !== last41) {
                    last41 = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path38.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last41) {
                        last41 = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path38.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path38;
                        }
                        if (j !== last41) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code47)) {
            if (path38.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path38.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code47)) {
        return path38;
    }
    for(let i115 = len - 1; i115 >= offset; --i115){
        if (isPathSeparator1(path38.charCodeAt(i115))) {
            if (!matchedSlash) {
                end = i115;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path38.slice(0, end);
}
function basename3(path39, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath1(path39);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i116;
    if (path39.length >= 2) {
        const drive = path39.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path39.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path39.length) {
        if (ext.length === path39.length && ext === path39) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i116 = path39.length - 1; i116 >= start; --i116){
            const code48 = path39.charCodeAt(i116);
            if (isPathSeparator1(code48)) {
                if (!matchedSlash) {
                    start = i116 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i116 + 1;
                }
                if (extIdx >= 0) {
                    if (code48 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i116;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path39.length;
        return path39.slice(start, end);
    } else {
        for(i116 = path39.length - 1; i116 >= start; --i116){
            if (isPathSeparator1(path39.charCodeAt(i116))) {
                if (!matchedSlash) {
                    start = i116 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i116 + 1;
            }
        }
        if (end === -1) return "";
        return path39.slice(start, end);
    }
}
function extname3(path40) {
    assertPath1(path40);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path40.length >= 2 && path40.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path40.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i117 = path40.length - 1; i117 >= start; --i117){
        const code49 = path40.charCodeAt(i117);
        if (isPathSeparator1(code49)) {
            if (!matchedSlash) {
                startPart = i117 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i117 + 1;
        }
        if (code49 === 46) {
            if (startDot === -1) startDot = i117;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path40.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format2("\\", pathObject);
}
function parse4(path41) {
    assertPath1(path41);
    const ret33 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path41.length;
    if (len === 0) return ret33;
    let rootEnd = 0;
    let code50 = path41.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code50)) {
            rootEnd = 1;
            if (isPathSeparator1(path41.charCodeAt(1))) {
                let j = 2;
                let last42 = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path41.charCodeAt(j))) break;
                }
                if (j < len && j !== last42) {
                    last42 = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path41.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last42) {
                        last42 = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path41.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last42) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code50)) {
            if (path41.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path41.charCodeAt(2))) {
                        if (len === 3) {
                            ret33.root = ret33.dir = path41;
                            return ret33;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret33.root = ret33.dir = path41;
                    return ret33;
                }
            }
        }
    } else if (isPathSeparator1(code50)) {
        ret33.root = ret33.dir = path41;
        return ret33;
    }
    if (rootEnd > 0) ret33.root = path41.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i118 = path41.length - 1;
    let preDotState = 0;
    for(; i118 >= rootEnd; --i118){
        code50 = path41.charCodeAt(i118);
        if (isPathSeparator1(code50)) {
            if (!matchedSlash) {
                startPart = i118 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i118 + 1;
        }
        if (code50 === 46) {
            if (startDot === -1) startDot = i118;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret33.base = ret33.name = path41.slice(startPart, end);
        }
    } else {
        ret33.name = path41.slice(startPart, startDot);
        ret33.base = path41.slice(startPart, end);
        ret33.ext = path41.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret33.dir = path41.slice(0, startPart - 1);
    } else ret33.dir = ret33.root;
    return ret33;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path42 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path42 = `\\\\${url.hostname}${path42}`;
    }
    return path42;
}
function toFileUrl3(path43) {
    if (!isAbsolute3(path43)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname5, pathname] = path43.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname5 != null && hostname5 != "localhost") {
        url.hostname = hostname5;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const __default6 = {
    basename: basename3,
    delimiter: delimiter3,
    dirname: dirname3,
    extname: extname3,
    format: format3,
    fromFileUrl: fromFileUrl3,
    isAbsolute: isAbsolute3,
    join: join6,
    normalize: normalize4,
    parse: parse4,
    relative: relative3,
    resolve: resolve3,
    sep: sep3,
    toFileUrl: toFileUrl3,
    toNamespacedPath: toNamespacedPath3
};
const mod49 = {
    sep: sep3,
    delimiter: delimiter3,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join6,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format3,
    parse: parse4,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3,
    default: __default6
};
const sep4 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i119 = pathSegments.length - 1; i119 >= -1 && !resolvedAbsolute; i119--){
        let path44;
        if (i119 >= 0) path44 = pathSegments[i119];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path44 = Deno.cwd();
        }
        assertPath1(path44);
        if (path44.length === 0) {
            continue;
        }
        resolvedPath = `${path44}/${resolvedPath}`;
        resolvedAbsolute = path44.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path45) {
    assertPath1(path45);
    if (path45.length === 0) return ".";
    const isAbsolute12 = path45.charCodeAt(0) === 47;
    const trailingSeparator = path45.charCodeAt(path45.length - 1) === 47;
    path45 = normalizeString1(path45, !isAbsolute12, "/", isPosixPathSeparator1);
    if (path45.length === 0 && !isAbsolute12) path45 = ".";
    if (path45.length > 0 && trailingSeparator) path45 += "/";
    if (isAbsolute12) return `/${path45}`;
    return path45;
}
function isAbsolute4(path46) {
    assertPath1(path46);
    return path46.length > 0 && path46.charCodeAt(0) === 47;
}
function join7(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i120 = 0, len = paths.length; i120 < len; ++i120){
        const path47 = paths[i120];
        assertPath1(path47);
        if (path47.length > 0) {
            if (!joined) joined = path47;
            else joined += `/${path47}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i121 = 0;
    for(; i121 <= length; ++i121){
        if (i121 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i121) === 47) {
                    return to.slice(toStart + i121 + 1);
                } else if (i121 === 0) {
                    return to.slice(toStart + i121);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i121) === 47) {
                    lastCommonSep = i121;
                } else if (i121 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i121);
        const toCode = to.charCodeAt(toStart + i121);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i121;
    }
    let out = "";
    for(i121 = fromStart + lastCommonSep + 1; i121 <= fromEnd; ++i121){
        if (i121 === fromEnd || from.charCodeAt(i121) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path48) {
    return path48;
}
function dirname4(path49) {
    assertPath1(path49);
    if (path49.length === 0) return ".";
    const hasRoot = path49.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i122 = path49.length - 1; i122 >= 1; --i122){
        if (path49.charCodeAt(i122) === 47) {
            if (!matchedSlash) {
                end = i122;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path49.slice(0, end);
}
function basename4(path50, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath1(path50);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i123;
    if (ext !== undefined && ext.length > 0 && ext.length <= path50.length) {
        if (ext.length === path50.length && ext === path50) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i123 = path50.length - 1; i123 >= 0; --i123){
            const code51 = path50.charCodeAt(i123);
            if (code51 === 47) {
                if (!matchedSlash) {
                    start = i123 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i123 + 1;
                }
                if (extIdx >= 0) {
                    if (code51 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i123;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path50.length;
        return path50.slice(start, end);
    } else {
        for(i123 = path50.length - 1; i123 >= 0; --i123){
            if (path50.charCodeAt(i123) === 47) {
                if (!matchedSlash) {
                    start = i123 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i123 + 1;
            }
        }
        if (end === -1) return "";
        return path50.slice(start, end);
    }
}
function extname4(path51) {
    assertPath1(path51);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i124 = path51.length - 1; i124 >= 0; --i124){
        const code52 = path51.charCodeAt(i124);
        if (code52 === 47) {
            if (!matchedSlash) {
                startPart = i124 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i124 + 1;
        }
        if (code52 === 46) {
            if (startDot === -1) startDot = i124;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path51.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format2("/", pathObject);
}
function parse5(path52) {
    assertPath1(path52);
    const ret34 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path52.length === 0) return ret34;
    const isAbsolute22 = path52.charCodeAt(0) === 47;
    let start;
    if (isAbsolute22) {
        ret34.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i125 = path52.length - 1;
    let preDotState = 0;
    for(; i125 >= start; --i125){
        const code53 = path52.charCodeAt(i125);
        if (code53 === 47) {
            if (!matchedSlash) {
                startPart = i125 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i125 + 1;
        }
        if (code53 === 46) {
            if (startDot === -1) startDot = i125;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute22) {
                ret34.base = ret34.name = path52.slice(1, end);
            } else {
                ret34.base = ret34.name = path52.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute22) {
            ret34.name = path52.slice(1, startDot);
            ret34.base = path52.slice(1, end);
        } else {
            ret34.name = path52.slice(startPart, startDot);
            ret34.base = path52.slice(startPart, end);
        }
        ret34.ext = path52.slice(startDot, end);
    }
    if (startPart > 0) ret34.dir = path52.slice(0, startPart - 1);
    else if (isAbsolute22) ret34.dir = "/";
    return ret34;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path53) {
    if (!isAbsolute4(path53)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path53.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const __default7 = {
    basename: basename4,
    delimiter: delimiter4,
    dirname: dirname4,
    extname: extname4,
    format: format4,
    fromFileUrl: fromFileUrl4,
    isAbsolute: isAbsolute4,
    join: join7,
    normalize: normalize5,
    parse: parse5,
    relative: relative4,
    resolve: resolve4,
    sep: sep4,
    toFileUrl: toFileUrl4,
    toNamespacedPath: toNamespacedPath4
};
const mod50 = {
    sep: sep4,
    delimiter: delimiter4,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join7,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format4,
    parse: parse5,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4,
    default: __default7
};
const SEP = isWindows ? "\\" : "/";
const SEP_PATTERN = isWindows ? /[\\/]+/ : /\/+/;
function common(paths, sep8 = SEP) {
    const [first = "", ...remaining] = paths;
    if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep8) + 1);
    }
    const parts = first.split(sep8);
    let endOfPrefix = parts.length;
    for (const path54 of remaining){
        const compare2 = path54.split(sep8);
        for(let i126 = 0; i126 < endOfPrefix; i126++){
            if (compare2[i126] !== parts[i126]) {
                endOfPrefix = i126;
            }
        }
        if (endOfPrefix === 0) {
            return "";
        }
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep8);
    return prefix.endsWith(sep8) ? prefix : `${prefix}${sep8}`;
}
const path2 = isWindows ? mod49 : mod50;
const { join: join8 , normalize: normalize6  } = path2;
const regExpEscapeChars = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|", 
];
const rangeEscapeChars = [
    "-",
    "\\",
    "]"
];
function globToRegExp(glob, { extended =true , globstar: globstarOption = true , os: os1 = osType , caseInsensitive =false  } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep9 = os1 == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os1 == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os1 == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os1 == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os1 == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os1 == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j = 0; j < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i127 = j;
        for(; i127 < glob.length && !seps.includes(glob[i127]); i127++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                segment += escapeChars.includes(glob[i127]) ? `\\${glob[i127]}` : glob[i127];
                continue;
            }
            if (glob[i127] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i127] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i127 + 1] == "!") {
                        i127++;
                        segment += "^";
                    } else if (glob[i127 + 1] == "^") {
                        i127++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i127 + 1] == ":") {
                    let k22 = i127 + 1;
                    let value = "";
                    while(glob[k22 + 1] != null && glob[k22 + 1] != ":"){
                        value += glob[k22 + 1];
                        k22++;
                    }
                    if (glob[k22 + 1] == ":" && glob[k22 + 2] == "]") {
                        i127 = k22 + 2;
                        if (value == "alnum") segment += "\\dA-Za-z";
                        else if (value == "alpha") segment += "A-Za-z";
                        else if (value == "ascii") segment += "\x00-\x7F";
                        else if (value == "blank") segment += "\t ";
                        else if (value == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value == "digit") segment += "\\d";
                        else if (value == "graph") segment += "\x21-\x7E";
                        else if (value == "lower") segment += "a-z";
                        else if (value == "print") segment += "\x20-\x7E";
                        else if (value == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~";
                        } else if (value == "space") segment += "\\s\v";
                        else if (value == "upper") segment += "A-Z";
                        else if (value == "word") segment += "\\w";
                        else if (value == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i127] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i127] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i127];
                }
                continue;
            }
            if (glob[i127] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type41 = groupStack.pop();
                if (type41 == "!") {
                    segment += wildcard;
                } else if (type41 != "@") {
                    segment += type41;
                }
                continue;
            }
            if (glob[i127] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i127] == "+" && extended && glob[i127 + 1] == "(") {
                i127++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i127] == "@" && extended && glob[i127 + 1] == "(") {
                i127++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i127] == "?") {
                if (extended && glob[i127 + 1] == "(") {
                    i127++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i127] == "!" && extended && glob[i127 + 1] == "(") {
                i127++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i127] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i127] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i127] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i127] == "*") {
                if (extended && glob[i127 + 1] == "(") {
                    i127++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i127 - 1];
                    let numStars = 1;
                    while(glob[i127 + 1] == "*"){
                        i127++;
                        numStars++;
                    }
                    const nextChar = glob[i127 + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars.includes(glob[i127]) ? `\\${glob[i127]}` : glob[i127];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c of glob.slice(j, i127)){
                segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i127 < glob.length ? sep9 : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i127]))i127++;
        if (!(i127 > j)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j = i127;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str === "") {
        return false;
    }
    let match;
    while(match = regex.exec(str)){
        if (match[2]) return true;
        let idx = match.index + match[0].length;
        const open2 = match[1];
        const close3 = open2 ? chars[open2] : null;
        if (open2 && close3) {
            const n = str.indexOf(close3, idx);
            if (n !== -1) {
                idx = n + 1;
            }
        }
        str = str.slice(idx);
    }
    return false;
}
function normalizeGlob(glob, { globstar =false  } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize6(glob);
    }
    const s = SEP_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
    return normalize6(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended =true , globstar =false  } = {}) {
    if (!globstar || globs.length == 0) {
        return join8(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path110 = glob;
        if (path110.length > 0) {
            if (!joined) joined = path110;
            else joined += `${SEP}${path110}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
        extended,
        globstar
    });
}
const path3 = isWindows ? __default6 : __default7;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format5 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join9 , normalize: normalize7 , parse: parse6 , relative: relative5 , resolve: resolve5 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5 ,  } = path3;
const mod51 = {
    SEP: SEP,
    SEP_PATTERN: SEP_PATTERN,
    win32: __default6,
    posix: __default7,
    basename: basename5,
    delimiter: delimiter5,
    dirname: dirname5,
    extname: extname5,
    format: format5,
    fromFileUrl: fromFileUrl5,
    isAbsolute: isAbsolute5,
    join: join9,
    normalize: normalize7,
    parse: parse6,
    relative: relative5,
    resolve: resolve5,
    sep: sep5,
    toFileUrl: toFileUrl5,
    toNamespacedPath: toNamespacedPath5,
    common,
    globToRegExp,
    isGlob,
    normalizeGlob,
    joinGlobs
};
const __default8 = {
    ...mod51
};
"use strict";
const base = 36;
const damp = 700;
const delimiter6 = "-";
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
};
const baseMinusTMin = 36 - 1;
function error(type42) {
    throw new RangeError(errors[type42]);
}
function mapDomain(str, fn) {
    const parts = str.split("@");
    let result = "";
    if (parts.length > 1) {
        result = parts[0] + "@";
        str = parts[1];
    }
    str = str.replace(regexSeparators, "\x2E");
    const labels = str.split(".");
    const encoded = labels.map(fn).join(".");
    return result + encoded;
}
function ucs2decode(str) {
    const output = [];
    let counter = 0;
    const length = str.length;
    while(counter < length){
        const value = str.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            const extra = str.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
function digitToBasic(digit, flag) {
    return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
    let k23 = 0;
    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
    delta += Math.floor(delta / numPoints);
    for(; delta > baseMinusTMin * 26 >> 1; k23 += base){
        delta = Math.floor(delta / baseMinusTMin);
    }
    return Math.floor(k23 + (baseMinusTMin + 1) * delta / (delta + 38));
}
function encode2(str) {
    const output = [];
    const input = ucs2decode(str);
    const inputLength = input.length;
    let n = 128;
    let delta = 0;
    let bias = 72;
    for (const currentValue of input){
        if (currentValue < 0x80) {
            output.push(String.fromCharCode(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter6);
    }
    while(handledCPCount < inputLength){
        let m = 2147483647;
        for (const currentValue of input){
            if (currentValue >= n && currentValue < m) {
                m = currentValue;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > Math.floor((2147483647 - delta) / handledCPCountPlusOne)) {
            error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue1 of input){
            if (currentValue1 < n && ++delta > 2147483647) {
                error("overflow");
            }
            if (currentValue1 == n) {
                let q = delta;
                for(let k24 = 36;; k24 += base){
                    const t = k24 <= bias ? 1 : k24 >= bias + 26 ? 26 : k24 - bias;
                    if (q < t) {
                        break;
                    }
                    const qMinusT = q - t;
                    const baseMinusT = 36 - t;
                    output.push(String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = Math.floor(qMinusT / baseMinusT);
                }
                output.push(String.fromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join("");
}
function toASCII(input) {
    return mapDomain(input, function(str) {
        return regexNonASCII.test(str) ? "xn--" + encode2(str) : str;
    });
}
const hexTable = new Array(256);
for(let i1 = 0; i1 < 256; ++i1){
    hexTable[i1] = "%" + ((i1 < 16 ? "0" : "") + i1.toString(16)).toUpperCase();
}
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function encodeStr(str, noEscapeTable, hexTable1) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    for(let i128 = 0; i128 < len; i128++){
        let c = str.charCodeAt(i128);
        if (c < 0x80) {
            if (noEscapeTable[c] === 1) continue;
            if (lastPos < i128) out += str.slice(lastPos, i128);
            lastPos = i128 + 1;
            out += hexTable1[c];
            continue;
        }
        if (lastPos < i128) out += str.slice(lastPos, i128);
        if (c < 0x800) {
            lastPos = i128 + 1;
            out += hexTable1[0xc0 | c >> 6] + hexTable1[0x80 | c & 0x3f];
            continue;
        }
        if (c < 0xd800 || c >= 0xe000) {
            lastPos = i128 + 1;
            out += hexTable1[0xe0 | c >> 12] + hexTable1[0x80 | c >> 6 & 0x3f] + hexTable1[0x80 | c & 0x3f];
            continue;
        }
        ++i128;
        if (i128 >= len) throw new ERR_INVALID_URI();
        const c2 = str.charCodeAt(i128) & 0x3ff;
        lastPos = i128 + 1;
        c = 0x10000 + ((c & 0x3ff) << 10 | c2);
        out += hexTable1[0xf0 | c >> 18] + hexTable1[0x80 | c >> 12 & 0x3f] + hexTable1[0x80 | c >> 6 & 0x3f] + hexTable1[0x80 | c & 0x3f];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
}
const decode2 = parse7;
const encode3 = stringify;
function qsEscape(str) {
    if (typeof str !== "string") {
        if (typeof str === "object") {
            str = String(str);
        } else {
            str += "";
        }
    }
    return encodeStr(str, noEscape, hexTable);
}
const escape = qsEscape;
const isHexTable = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function charCodes(str) {
    const ret35 = new Array(str.length);
    for(let i129 = 0; i129 < str.length; ++i129){
        ret35[i129] = str.charCodeAt(i129);
    }
    return ret35;
}
function addKeyVal(obj, key, value, keyEncoded, valEncoded, decode11) {
    if (key.length > 0 && keyEncoded) {
        key = decode11(key);
    }
    if (value.length > 0 && valEncoded) {
        value = decode11(value);
    }
    if (obj[key] === undefined) {
        obj[key] = value;
    } else {
        const curValue = obj[key];
        if (curValue.pop) {
            curValue[curValue.length] = value;
        } else {
            obj[key] = [
                curValue,
                value
            ];
        }
    }
}
function parse7(str, sep10 = "&", eq = "=", { decodeURIComponent =unescape , maxKeys =1000  } = {}) {
    const obj = Object.create(null);
    if (typeof str !== "string" || str.length === 0) {
        return obj;
    }
    const sepCodes = !sep10 ? [
        38
    ] : charCodes(String(sep10));
    const eqCodes = !eq ? [
        61
    ] : charCodes(String(eq));
    const sepLen = sepCodes.length;
    const eqLen = eqCodes.length;
    let pairs = 1000;
    if (typeof maxKeys === "number") {
        pairs = maxKeys > 0 ? maxKeys : -1;
    }
    let decode21 = unescape;
    if (decodeURIComponent) {
        decode21 = decodeURIComponent;
    }
    const customDecode = decode21 !== unescape;
    let lastPos = 0;
    let sepIdx = 0;
    let eqIdx = 0;
    let key = "";
    let value = "";
    let keyEncoded = customDecode;
    let valEncoded = customDecode;
    const plusChar = customDecode ? "%20" : " ";
    let encodeCheck = 0;
    for(let i130 = 0; i130 < str.length; ++i130){
        const code54 = str.charCodeAt(i130);
        if (code54 === sepCodes[sepIdx]) {
            if (++sepIdx === sepLen) {
                const end = i130 - sepIdx + 1;
                if (eqIdx < eqLen) {
                    if (lastPos < end) {
                        key += str.slice(lastPos, end);
                    } else if (key.length === 0) {
                        if (--pairs === 0) {
                            return obj;
                        }
                        lastPos = i130 + 1;
                        sepIdx = eqIdx = 0;
                        continue;
                    }
                } else if (lastPos < end) {
                    value += str.slice(lastPos, end);
                }
                addKeyVal(obj, key, value, keyEncoded, valEncoded, decode21);
                if (--pairs === 0) {
                    return obj;
                }
                key = value = "";
                encodeCheck = 0;
                lastPos = i130 + 1;
                sepIdx = eqIdx = 0;
            }
        } else {
            sepIdx = 0;
            if (eqIdx < eqLen) {
                if (code54 === eqCodes[eqIdx]) {
                    if (++eqIdx === eqLen) {
                        const end = i130 - eqIdx + 1;
                        if (lastPos < end) {
                            key += str.slice(lastPos, end);
                        }
                        encodeCheck = 0;
                        lastPos = i130 + 1;
                    }
                    continue;
                } else {
                    eqIdx = 0;
                    if (!keyEncoded) {
                        if (code54 === 37) {
                            encodeCheck = 1;
                            continue;
                        } else if (encodeCheck > 0) {
                            if (isHexTable[code54] === 1) {
                                if (++encodeCheck === 3) {
                                    keyEncoded = true;
                                }
                                continue;
                            } else {
                                encodeCheck = 0;
                            }
                        }
                    }
                }
                if (code54 === 43) {
                    if (lastPos < i130) {
                        key += str.slice(lastPos, i130);
                    }
                    key += plusChar;
                    lastPos = i130 + 1;
                    continue;
                }
            }
            if (code54 === 43) {
                if (lastPos < i130) {
                    value += str.slice(lastPos, i130);
                }
                value += plusChar;
                lastPos = i130 + 1;
            } else if (!valEncoded) {
                if (code54 === 37) {
                    encodeCheck = 1;
                } else if (encodeCheck > 0) {
                    if (isHexTable[code54] === 1) {
                        if (++encodeCheck === 3) {
                            valEncoded = true;
                        }
                    } else {
                        encodeCheck = 0;
                    }
                }
            }
        }
    }
    if (lastPos < str.length) {
        if (eqIdx < eqLen) {
            key += str.slice(lastPos);
        } else if (sepIdx < sepLen) {
            value += str.slice(lastPos);
        }
    } else if (eqIdx === 0 && key.length === 0) {
        return obj;
    }
    addKeyVal(obj, key, value, keyEncoded, valEncoded, decode21);
    return obj;
}
const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
function stringifyPrimitive(v) {
    if (typeof v === "string") {
        return v;
    }
    if (typeof v === "number" && isFinite(v)) {
        return "" + v;
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function encodeStringifiedCustom(v, encode11) {
    return encode11(stringifyPrimitive(v));
}
function encodeStringified(v, encode21) {
    if (typeof v === "string") {
        return v.length ? encode21(v) : "";
    }
    if (typeof v === "number" && isFinite(v)) {
        return Math.abs(v) < 1e21 ? "" + v : encode21("" + v);
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function stringify(obj, sep11, eq, options) {
    sep11 ||= "&";
    eq ||= "=";
    const encode31 = options ? options.encodeURIComponent : qsEscape;
    const convert = options ? encodeStringifiedCustom : encodeStringified;
    if (obj !== null && typeof obj === "object") {
        const keys = Object.keys(obj);
        const len = keys.length;
        let fields = "";
        for(let i131 = 0; i131 < len; ++i131){
            const k25 = keys[i131];
            const v = obj[k25];
            let ks = convert(k25, encode31);
            ks += eq;
            if (Array.isArray(v)) {
                const vlen = v.length;
                if (vlen === 0) continue;
                if (fields) {
                    fields += sep11;
                }
                for(let j = 0; j < vlen; ++j){
                    if (j) {
                        fields += sep11;
                    }
                    fields += ks;
                    fields += convert(v[j], encode31);
                }
            } else {
                if (fields) {
                    fields += sep11;
                }
                fields += ks;
                fields += convert(v, encode31);
            }
        }
        return fields;
    }
    return "";
}
const unhexTable = new Int8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    +0,
    +1,
    +2,
    +3,
    +4,
    +5,
    +6,
    +7,
    +8,
    +9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
function unescapeBuffer(s, decodeSpaces = false) {
    const out = new Buffer(s.length);
    let index = 0;
    let outIndex = 0;
    let currentChar;
    let nextChar;
    let hexHigh;
    let hexLow;
    const maxLength = s.length - 2;
    let hasHex = false;
    while(index < s.length){
        currentChar = s.charCodeAt(index);
        if (currentChar === 43 && decodeSpaces) {
            out[outIndex++] = 32;
            index++;
            continue;
        }
        if (currentChar === 37 && index < maxLength) {
            currentChar = s.charCodeAt(++index);
            hexHigh = unhexTable[currentChar];
            if (!(hexHigh >= 0)) {
                out[outIndex++] = 37;
                continue;
            } else {
                nextChar = s.charCodeAt(++index);
                hexLow = unhexTable[nextChar];
                if (!(hexLow >= 0)) {
                    out[outIndex++] = 37;
                    index--;
                } else {
                    hasHex = true;
                    currentChar = hexHigh * 16 + hexLow;
                }
            }
        }
        out[outIndex++] = currentChar;
        index++;
    }
    return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s) {
    try {
        return decodeURIComponent(s);
    } catch  {
        return unescapeBuffer(s).toString();
    }
}
const unescape = qsUnescape;
const __default9 = {
    parse: parse7,
    stringify,
    decode: decode2,
    encode: encode3,
    unescape,
    escape,
    unescapeBuffer
};
const forwardSlashRegEx = /\//g;
const protocolPattern = /^[a-z0-9.+-]+:/i;
const portPattern = /:[0-9]*$/;
const hostPattern = /^\/\/[^@/]+@[^@/]+/;
const simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
const unsafeProtocol = new Set([
    "javascript",
    "javascript:"
]);
const hostlessProtocol = new Set([
    "javascript",
    "javascript:"
]);
const slashedProtocol = new Set([
    "http",
    "http:",
    "https",
    "https:",
    "ftp",
    "ftp:",
    "gopher",
    "gopher:",
    "file",
    "file:",
    "ws",
    "ws:",
    "wss",
    "wss:", 
]);
const noEscapeAuth = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
URL;
class Url {
    protocol;
    slashes;
    auth;
    host;
    port;
    hostname;
    hash;
    search;
    query;
    pathname;
    path;
    href;
    constructor(){
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
    parseHost() {
        let host = this.host || "";
        let port2 = portPattern.exec(host);
        if (port2) {
            port2 = port2[0];
            if (port2 !== ":") {
                this.port = port2.slice(1);
            }
            host = host.slice(0, host.length - port2.length);
        }
        if (host) this.hostname = host;
    }
    resolve(relative6) {
        return this.resolveObject(parse8(relative6, false, true)).format();
    }
    resolveObject(relative7) {
        if (typeof relative7 === "string") {
            const rel = new Url();
            rel.urlParse(relative7, false, true);
            relative7 = rel;
        }
        const result = new Url();
        const tkeys = Object.keys(this);
        for(let tk = 0; tk < tkeys.length; tk++){
            const tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        result.hash = relative7.hash;
        if (relative7.href === "") {
            result.href = result.format();
            return result;
        }
        if (relative7.slashes && !relative7.protocol) {
            const rkeys = Object.keys(relative7);
            for(let rk = 0; rk < rkeys.length; rk++){
                const rkey = rkeys[rk];
                if (rkey !== "protocol") result[rkey] = relative7[rkey];
            }
            if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
        }
        if (relative7.protocol && relative7.protocol !== result.protocol) {
            if (!slashedProtocol.has(relative7.protocol)) {
                const keys = Object.keys(relative7);
                for(let v = 0; v < keys.length; v++){
                    const k26 = keys[v];
                    result[k26] = relative7[k26];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative7.protocol;
            if (!relative7.host && !/^file:?$/.test(relative7.protocol) && !hostlessProtocol.has(relative7.protocol)) {
                const relPath = (relative7.pathname || "").split("/");
                while(relPath.length && !(relative7.host = relPath.shift() || null));
                if (!relative7.host) relative7.host = "";
                if (!relative7.hostname) relative7.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
            } else {
                result.pathname = relative7.pathname;
            }
            result.search = relative7.search;
            result.query = relative7.query;
            result.host = relative7.host || "";
            result.auth = relative7.auth;
            result.hostname = relative7.hostname || relative7.host;
            result.port = relative7.port;
            if (result.pathname || result.search) {
                const p = result.pathname || "";
                const s = result.search || "";
                result.path = p + s;
            }
            result.slashes = result.slashes || relative7.slashes;
            result.href = result.format();
            return result;
        }
        const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
        const isRelAbs = relative7.host || relative7.pathname && relative7.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative7.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath = relative7.pathname && relative7.pathname.split("/") || [];
        const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative7.protocol) {
                relative7.hostname = null;
                relative7.port = null;
                result.auth = null;
                if (relative7.host) {
                    if (relPath[0] === "") relPath[0] = relative7.host;
                    else relPath.unshift(relative7.host);
                }
                relative7.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
            if (relative7.host || relative7.host === "") {
                if (result.host !== relative7.host) result.auth = null;
                result.host = relative7.host;
                result.port = relative7.port;
            }
            if (relative7.hostname || relative7.hostname === "") {
                if (result.hostname !== relative7.hostname) result.auth = null;
                result.hostname = relative7.hostname;
            }
            result.search = relative7.search;
            result.query = relative7.query;
            srcPath = relPath;
        } else if (relPath.length) {
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative7.search;
            result.query = relative7.query;
        } else if (relative7.search !== null && relative7.search !== undefined) {
            if (noLeadingSlashes) {
                result.hostname = result.host = srcPath.shift() || null;
                const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
                if (authInHost) {
                    result.auth = authInHost.shift() || null;
                    result.host = result.hostname = authInHost.shift() || null;
                }
            }
            result.search = relative7.search;
            result.query = relative7.query;
            if (result.pathname !== null || result.search !== null) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
                result.path = "/" + result.search;
            } else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        let last43 = srcPath.slice(-1)[0];
        const hasTrailingSlash = (result.host || relative7.host || srcPath.length > 1) && (last43 === "." || last43 === "..") || last43 === "";
        let up = 0;
        for(let i132 = srcPath.length - 1; i132 >= 0; i132--){
            last43 = srcPath[i132];
            if (last43 === ".") {
                srcPath.splice(i132, 1);
            } else if (last43 === "..") {
                srcPath.splice(i132, 1);
                up++;
            } else if (up) {
                srcPath.splice(i132, 1);
                up--;
            }
        }
        if (!mustEndAbs && !removeAllDots) {
            while(up--){
                srcPath.unshift("..");
            }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
        }
        const isAbsolute6 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
            result.hostname = result.host = isAbsolute6 ? "" : srcPath.length ? srcPath.shift() || null : "";
            const authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift() || null;
                result.host = result.hostname = authInHost.shift() || null;
            }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute6) {
            srcPath.unshift("");
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        } else {
            result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative7.auth || result.auth;
        result.slashes = result.slashes || relative7.slashes;
        result.href = result.format();
        return result;
    }
    format() {
        let auth = this.auth || "";
        if (auth) {
            auth = encodeStr(auth, noEscapeAuth, hexTable);
            auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
            host = auth + this.host;
        } else if (this.hostname) {
            host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
            if (this.port) {
                host += ":" + this.port;
            }
        }
        if (this.query !== null && typeof this.query === "object") {
            query = __default9.stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
            protocol += ":";
        }
        let newPathname = "";
        let lastPos = 0;
        for(let i133 = 0; i133 < pathname.length; ++i133){
            switch(pathname.charCodeAt(i133)){
                case 35:
                    if (i133 - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i133);
                    }
                    newPathname += "%23";
                    lastPos = i133 + 1;
                    break;
                case 63:
                    if (i133 - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i133);
                    }
                    newPathname += "%3F";
                    lastPos = i133 + 1;
                    break;
            }
        }
        if (lastPos > 0) {
            if (lastPos !== pathname.length) {
                pathname = newPathname + pathname.slice(lastPos);
            } else pathname = newPathname;
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
            if (this.slashes || host) {
                if (pathname && pathname.charCodeAt(0) !== 47) {
                    pathname = "/" + pathname;
                }
                host = "//" + host;
            } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
                host = "//";
            }
        }
        search = search.replace(/#/g, "%23");
        if (hash && hash.charCodeAt(0) !== 35) {
            hash = "#" + hash;
        }
        if (search && search.charCodeAt(0) !== 63) {
            search = "?" + search;
        }
        return protocol + host + pathname + search + hash;
    }
    urlParse(url, parseQueryString, slashesDenoteHost) {
        let hasHash = false;
        let start = -1;
        let end = -1;
        let rest = "";
        let lastPos = 0;
        for(let i134 = 0, inWs = false, split = false; i134 < url.length; ++i134){
            const code55 = url.charCodeAt(i134);
            const isWs = code55 === 32 || code55 === 9 || code55 === 13 || code55 === 10 || code55 === 12 || code55 === 160 || code55 === 65279;
            if (start === -1) {
                if (isWs) continue;
                lastPos = start = i134;
            } else if (inWs) {
                if (!isWs) {
                    end = -1;
                    inWs = false;
                }
            } else if (isWs) {
                end = i134;
                inWs = true;
            }
            if (!split) {
                switch(code55){
                    case 35:
                        hasHash = true;
                    case 63:
                        split = true;
                        break;
                    case 92:
                        if (i134 - lastPos > 0) rest += url.slice(lastPos, i134);
                        rest += "/";
                        lastPos = i134 + 1;
                        break;
                }
            } else if (!hasHash && code55 === 35) {
                hasHash = true;
            }
        }
        if (start !== -1) {
            if (lastPos === start) {
                if (end === -1) {
                    if (start === 0) rest = url;
                    else rest = url.slice(start);
                } else {
                    rest = url.slice(start, end);
                }
            } else if (end === -1 && lastPos < url.length) {
                rest += url.slice(lastPos);
            } else if (end !== -1 && lastPos < end) {
                rest += url.slice(lastPos, end);
            }
        }
        if (!slashesDenoteHost && !hasHash) {
            const simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = __default9.parse(this.search.slice(1));
                    } else {
                        this.query = this.search.slice(1);
                    }
                } else if (parseQueryString) {
                    this.search = null;
                    this.query = Object.create(null);
                }
                return this;
            }
        }
        let proto3 = protocolPattern.exec(rest);
        let lowerProto = "";
        if (proto3) {
            proto3 = proto3[0];
            lowerProto = proto3.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.slice(proto3.length);
        }
        let slashes;
        if (slashesDenoteHost || proto3 || hostPattern.test(rest)) {
            slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH && rest.charCodeAt(1) === CHAR_FORWARD_SLASH;
            if (slashes && !(proto3 && hostlessProtocol.has(lowerProto))) {
                rest = rest.slice(2);
                this.slashes = true;
            }
        }
        if (!hostlessProtocol.has(lowerProto) && (slashes || proto3 && !slashedProtocol.has(proto3))) {
            let hostEnd = -1;
            let atSign = -1;
            let nonHost = -1;
            for(let i135 = 0; i135 < rest.length; ++i135){
                switch(rest.charCodeAt(i135)){
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                    case 34:
                    case 37:
                    case 39:
                    case 59:
                    case 60:
                    case 62:
                    case 92:
                    case 94:
                    case 96:
                    case 123:
                    case 124:
                    case 125:
                        if (nonHost === -1) nonHost = i135;
                        break;
                    case 35:
                    case 47:
                    case 63:
                        if (nonHost === -1) nonHost = i135;
                        hostEnd = i135;
                        break;
                    case 64:
                        atSign = i135;
                        nonHost = -1;
                        break;
                }
                if (hostEnd !== -1) break;
            }
            start = 0;
            if (atSign !== -1) {
                this.auth = decodeURIComponent(rest.slice(0, atSign));
                start = atSign + 1;
            }
            if (nonHost === -1) {
                this.host = rest.slice(start);
                rest = "";
            } else {
                this.host = rest.slice(start, nonHost);
                rest = rest.slice(nonHost);
            }
            this.parseHost();
            if (typeof this.hostname !== "string") this.hostname = "";
            const hostname6 = this.hostname;
            const ipv6Hostname = isIpv6Hostname(hostname6);
            if (!ipv6Hostname) {
                rest = getHostname(this, rest, hostname6);
            }
            if (this.hostname.length > 255) {
                this.hostname = "";
            } else {
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                this.hostname = toASCII(this.hostname);
            }
            const p = this.port ? ":" + this.port : "";
            const h = this.hostname || "";
            this.host = h + p;
            if (ipv6Hostname) {
                this.hostname = this.hostname.slice(1, -1);
                if (rest[0] !== "/") {
                    rest = "/" + rest;
                }
            }
        }
        if (!unsafeProtocol.has(lowerProto)) {
            rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for(let i136 = 0; i136 < rest.length; ++i136){
            const code56 = rest.charCodeAt(i136);
            if (code56 === 35) {
                this.hash = rest.slice(i136);
                hashIdx = i136;
                break;
            } else if (code56 === 63 && questionIdx === -1) {
                questionIdx = i136;
            }
        }
        if (questionIdx !== -1) {
            if (hashIdx === -1) {
                this.search = rest.slice(questionIdx);
                this.query = rest.slice(questionIdx + 1);
            } else {
                this.search = rest.slice(questionIdx, hashIdx);
                this.query = rest.slice(questionIdx + 1, hashIdx);
            }
            if (parseQueryString) {
                this.query = __default9.parse(this.query);
            }
        } else if (parseQueryString) {
            this.search = null;
            this.query = Object.create(null);
        }
        const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
            if (rest.length > 0) this.pathname = rest;
        } else if (firstIdx > 0) {
            this.pathname = rest.slice(0, firstIdx);
        }
        if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
            this.pathname = "/";
        }
        if (this.pathname || this.search) {
            const p = this.pathname || "";
            const s = this.search || "";
            this.path = p + s;
        }
        this.href = this.format();
        return this;
    }
}
function isIpv6Hostname(hostname7) {
    return hostname7.charCodeAt(0) === 91 && hostname7.charCodeAt(hostname7.length - 1) === 93;
}
function getHostname(self, rest, hostname8) {
    for(let i137 = 0; i137 < hostname8.length; ++i137){
        const code57 = hostname8.charCodeAt(i137);
        const isValid = code57 >= 97 && code57 <= 122 || code57 === 46 || code57 >= 65 && code57 <= 90 || code57 >= 48 && code57 <= 57 || code57 === 45 || code57 === 43 || code57 === 95 || code57 > 127;
        if (!isValid) {
            self.hostname = hostname8.slice(0, i137);
            return `/${hostname8.slice(i137)}${rest}`;
        }
    }
    return rest;
}
const escapedCodes = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%09",
    "%0A",
    "",
    "",
    "%0D",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%20",
    "",
    "%22",
    "",
    "",
    "",
    "",
    "%27",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%3C",
    "",
    "%3E",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%5C",
    "",
    "%5E",
    "",
    "%60",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%7B",
    "%7C",
    "%7D"
];
function autoEscapeStr(rest) {
    let escaped = "";
    let lastEscapedPos = 0;
    for(let i138 = 0; i138 < rest.length; ++i138){
        const escapedChar = escapedCodes[rest.charCodeAt(i138)];
        if (escapedChar) {
            if (i138 > lastEscapedPos) {
                escaped += rest.slice(lastEscapedPos, i138);
            }
            escaped += escapedChar;
            lastEscapedPos = i138 + 1;
        }
    }
    if (lastEscapedPos === 0) {
        return rest;
    }
    if (lastEscapedPos < rest.length) {
        escaped += rest.slice(lastEscapedPos);
    }
    return escaped;
}
function parse8(url, parseQueryString, slashesDenoteHost) {
    if (url instanceof Url) return url;
    const urlObject = new Url();
    urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
    return urlObject;
}
function fileURLToPath(path111) {
    if (typeof path111 === "string") path111 = new URL(path111);
    else if (!(path111 instanceof URL)) {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string",
            "URL"
        ], path111);
    }
    if (path111.protocol !== "file:") {
        throw new ERR_INVALID_URL_SCHEME("file");
    }
    return isWindows ? getPathFromURLWin(path111) : getPathFromURLPosix(path111);
}
function getPathFromURLWin(url) {
    const hostname9 = url.hostname;
    let pathname = url.pathname;
    for(let n = 0; n < pathname.length; n++){
        if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === "2" && third === 102 || pathname[n + 1] === "5" && third === 99) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded \\ or / characters");
            }
        }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname9 !== "") {
        return `\\\\${hostname9}${pathname}`;
    } else {
        const letter = pathname.codePointAt(1) | 0x20;
        const sep12 = pathname[2];
        if (letter < 97 || letter > 122 || sep12 !== ":") {
            throw new ERR_INVALID_FILE_URL_PATH("must be absolute");
        }
        return pathname.slice(1);
    }
}
function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
        throw new ERR_INVALID_FILE_URL_HOST(osType);
    }
    const pathname = url.pathname;
    for(let n = 0; n < pathname.length; n++){
        if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === "2" && third === 102) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded / characters");
            }
        }
    }
    return decodeURIComponent(pathname);
}
Symbol("query");
function toPathIfFileURL(fileURLOrPath) {
    if (!(fileURLOrPath instanceof URL)) {
        return fileURLOrPath;
    }
    return fileURLToPath(fileURLOrPath);
}
function assert2(value, message) {
    if (!value) {
        throw new ERR_INTERNAL_ASSERTION(message);
    }
}
function fail(message) {
    throw new ERR_INTERNAL_ASSERTION(message);
}
assert2.fail = fail;
function convertFileInfoToStats(origin) {
    return {
        dev: origin.dev,
        ino: origin.ino,
        mode: origin.mode,
        nlink: origin.nlink,
        uid: origin.uid,
        gid: origin.gid,
        rdev: origin.rdev,
        size: origin.size,
        blksize: origin.blksize,
        blocks: origin.blocks,
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime?.getTime() || null,
        atimeMs: origin.atime?.getTime() || null,
        birthtimeMs: origin.birthtime?.getTime() || null,
        isFile: ()=>origin.isFile,
        isDirectory: ()=>origin.isDirectory,
        isSymbolicLink: ()=>origin.isSymlink,
        isBlockDevice: ()=>false,
        isFIFO: ()=>false,
        isCharacterDevice: ()=>false,
        isSocket: ()=>false,
        ctime: origin.mtime,
        ctimeMs: origin.mtime?.getTime() || null
    };
}
function toBigInt(number) {
    if (number === null || number === undefined) return null;
    return BigInt(number);
}
function convertFileInfoToBigIntStats(origin) {
    return {
        dev: toBigInt(origin.dev),
        ino: toBigInt(origin.ino),
        mode: toBigInt(origin.mode),
        nlink: toBigInt(origin.nlink),
        uid: toBigInt(origin.uid),
        gid: toBigInt(origin.gid),
        rdev: toBigInt(origin.rdev),
        size: toBigInt(origin.size) || 0n,
        blksize: toBigInt(origin.blksize),
        blocks: toBigInt(origin.blocks),
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        atimeMs: origin.atime ? BigInt(origin.atime.getTime()) : null,
        birthtimeMs: origin.birthtime ? BigInt(origin.birthtime.getTime()) : null,
        mtimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null,
        atimeNs: origin.atime ? BigInt(origin.atime.getTime()) * 1000000n : null,
        birthtimeNs: origin.birthtime ? BigInt(origin.birthtime.getTime()) * 1000000n : null,
        isFile: ()=>origin.isFile,
        isDirectory: ()=>origin.isDirectory,
        isSymbolicLink: ()=>origin.isSymlink,
        isBlockDevice: ()=>false,
        isFIFO: ()=>false,
        isCharacterDevice: ()=>false,
        isSocket: ()=>false,
        ctime: origin.mtime,
        ctimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        ctimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null
    };
}
function CFISBIS(fileInfo, bigInt) {
    if (bigInt) return convertFileInfoToBigIntStats(fileInfo);
    return convertFileInfoToStats(fileInfo);
}
function stat(path55, optionsOrCallback, maybeCallback1) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback1;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.stat(path55).then((stat1)=>callback(null, CFISBIS(stat1, options.bigint)), (err)=>callback(denoErrorToNodeError(err, {
            syscall: "stat"
        })));
}
function statSync(path56, options = {
    bigint: false,
    throwIfNoEntry: true
}) {
    try {
        const origin = Deno.statSync(path56);
        return CFISBIS(origin, options.bigint);
    } catch (err) {
        if (options?.throwIfNoEntry === false && err instanceof Deno.errors.NotFound) {
            return;
        }
        if (err instanceof Error) {
            throw denoErrorToNodeError(err, {
                syscall: "stat"
            });
        } else {
            throw err;
        }
    }
}
function lstat(path57, optionsOrCallback, maybeCallback2) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback2;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.lstat(path57).then((stat2)=>callback(null, CFISBIS(stat2, options.bigint)), (err)=>callback(err));
}
function lstatSync(path58, options) {
    const origin = Deno.lstatSync(path58);
    return CFISBIS(origin, options?.bigint || false);
}
"use strict";
const kType = Symbol("type");
const kStats = Symbol("stats");
const { F_OK =0 , W_OK =0 , R_OK =0 , X_OK =0 , COPYFILE_EXCL , COPYFILE_FICLONE , COPYFILE_FICLONE_FORCE , O_APPEND , O_CREAT , O_EXCL , O_RDONLY , O_RDWR , O_SYNC , O_TRUNC , O_WRONLY , S_IFBLK , S_IFCHR , S_IFDIR , S_IFIFO , S_IFLNK , S_IFMT , S_IFREG , S_IFSOCK , UV_FS_SYMLINK_DIR , UV_FS_SYMLINK_JUNCTION , UV_DIRENT_UNKNOWN , UV_DIRENT_FILE , UV_DIRENT_DIR , UV_DIRENT_LINK , UV_DIRENT_FIFO , UV_DIRENT_SOCKET , UV_DIRENT_CHAR , UV_DIRENT_BLOCK ,  } = fs;
const { errno: { EISDIR ,  } ,  } = os;
const kMinimumAccessMode = Math.min(F_OK, W_OK, R_OK, X_OK);
const kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;
const kDefaultCopyMode = 0;
const kMinimumCopyMode = Math.min(0, COPYFILE_EXCL, COPYFILE_FICLONE, COPYFILE_FICLONE_FORCE);
const kMaximumCopyMode = COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE;
const kIoMaxLength = 2 ** 31 - 1;
const kReadFileUnknownBufferLength = 64 * 1024;
const kReadFileBufferLength = 512 * 1024;
const kWriteFileMaxChunkSize = 512 * 1024;
const kMaxUserId = 2 ** 32 - 1;
function assertEncoding(encoding) {
    if (encoding && !Buffer.isEncoding(encoding)) {
        const reason = "is invalid encoding";
        throw new ERR_INVALID_ARG_VALUE(encoding, "encoding", reason);
    }
}
class Dirent {
    constructor(name1, type43){
        this.name = name1;
        this[kType] = type43;
    }
    isDirectory() {
        return this[kType] === UV_DIRENT_DIR;
    }
    isFile() {
        return this[kType] === UV_DIRENT_FILE;
    }
    isBlockDevice() {
        return this[kType] === UV_DIRENT_BLOCK;
    }
    isCharacterDevice() {
        return this[kType] === UV_DIRENT_CHAR;
    }
    isSymbolicLink() {
        return this[kType] === UV_DIRENT_LINK;
    }
    isFIFO() {
        return this[kType] === UV_DIRENT_FIFO;
    }
    isSocket() {
        return this[kType] === UV_DIRENT_SOCKET;
    }
}
class DirentFromStats extends Dirent {
    constructor(name2, stats){
        super(name2, null);
        this[kStats] = stats;
    }
}
for (const name1 of Reflect.ownKeys(Dirent.prototype)){
    if (name1 === "constructor") {
        continue;
    }
    DirentFromStats.prototype[name1] = function() {
        return this[kStats][name1]();
    };
}
function copyObject(source) {
    const target = {};
    for(const key in source){
        target[key] = source[key];
    }
    return target;
}
const bufferSep = Buffer.from(__default8.sep);
function join10(path59, name3) {
    if ((typeof path59 === "string" || isUint8Array(path59)) && name3 === undefined) {
        return path59;
    }
    if (typeof path59 === "string" && isUint8Array(name3)) {
        const pathBuffer = Buffer.from(__default8.join(path59, __default8.sep));
        return Buffer.concat([
            pathBuffer,
            name3
        ]);
    }
    if (typeof path59 === "string" && typeof name3 === "string") {
        return __default8.join(path59, name3);
    }
    if (isUint8Array(path59) && isUint8Array(name3)) {
        return Buffer.concat([
            path59,
            bufferSep,
            name3
        ]);
    }
    throw new ERR_INVALID_ARG_TYPE("path", [
        "string",
        "Buffer"
    ], path59);
}
function getDirents(path60, { 0: names , 1: types3  }, callback) {
    let i139;
    if (typeof callback === "function") {
        const len = names.length;
        let toFinish = 0;
        callback = once(callback);
        for(i139 = 0; i139 < len; i139++){
            const type44 = types3[i139];
            if (type44 === UV_DIRENT_UNKNOWN) {
                const name4 = names[i139];
                const idx = i139;
                toFinish++;
                let filepath;
                try {
                    filepath = join10(path60, name4);
                } catch (err1) {
                    callback(err1);
                    return;
                }
                lstat(filepath, (err, stats)=>{
                    if (err) {
                        callback(err);
                        return;
                    }
                    names[idx] = new DirentFromStats(name4, stats);
                    if (--toFinish === 0) {
                        callback(null, names);
                    }
                });
            } else {
                names[i139] = new Dirent(names[i139], types3[i139]);
            }
        }
        if (toFinish === 0) {
            callback(null, names);
        }
    } else {
        const len = names.length;
        for(i139 = 0; i139 < len; i139++){
            names[i139] = getDirent(path60, names[i139], types3[i139]);
        }
        return names;
    }
}
function getDirent(path61, name5, type45, callback) {
    if (typeof callback === "function") {
        if (type45 === UV_DIRENT_UNKNOWN) {
            let filepath;
            try {
                filepath = join10(path61, name5);
            } catch (err5) {
                callback(err5);
                return;
            }
            lstat(filepath, (err, stats)=>{
                if (err) {
                    callback(err);
                    return;
                }
                callback(null, new DirentFromStats(name5, stats));
            });
        } else {
            callback(null, new Dirent(name5, type45));
        }
    } else if (type45 === UV_DIRENT_UNKNOWN) {
        const stats = lstatSync(join10(path61, name5));
        return new DirentFromStats(name5, stats);
    } else {
        return new Dirent(name5, type45);
    }
}
function getOptions1(options, defaultOptions) {
    if (options === null || options === undefined || typeof options === "function") {
        return defaultOptions;
    }
    if (typeof options === "string") {
        defaultOptions = {
            ...defaultOptions
        };
        defaultOptions.encoding = options;
        options = defaultOptions;
    } else if (typeof options !== "object") {
        throw new ERR_INVALID_ARG_TYPE("options", [
            "string",
            "Object"
        ], options);
    }
    if (options.encoding !== "buffer") {
        assertEncoding(options.encoding);
    }
    if (options.signal !== undefined) {
        validateAbortSignal(options.signal, "options.signal");
    }
    return options;
}
function handleErrorFromBinding(ctx) {
    if (ctx.errno !== undefined) {
        const err = uvException(ctx);
        Error.captureStackTrace(err, handleErrorFromBinding);
        throw err;
    }
    if (ctx.error !== undefined) {
        Error.captureStackTrace(ctx.error, handleErrorFromBinding);
        throw ctx.error;
    }
}
const nullCheck = hideStackFrames((path62, propName, throwError = true)=>{
    const pathIsString = typeof path62 === "string";
    const pathIsUint8Array = isUint8Array(path62);
    if (!pathIsString && !pathIsUint8Array || pathIsString && !path62.includes("\u0000") || pathIsUint8Array && !path62.includes(0)) {
        return;
    }
    const err = new ERR_INVALID_ARG_VALUE(propName, path62, "must be a string or Uint8Array without null bytes");
    if (throwError) {
        throw err;
    }
    return err;
});
function preprocessSymlinkDestination(path63, type46, linkPath) {
    if (!isWindows) {
        return path63;
    }
    path63 = "" + path63;
    if (type46 === "junction") {
        path63 = __default8.resolve(linkPath, "..", path63);
        return __default8.toNamespacedPath(path63);
    }
    if (__default8.isAbsolute(path63)) {
        return __default8.toNamespacedPath(path63);
    }
    return path63.replace(/\//g, "\\");
}
function StatsBase(dev, mode1, nlink, uid1, gid, rdev, blksize, ino, size21, blocks1) {
    this.dev = dev;
    this.mode = mode1;
    this.nlink = nlink;
    this.uid = uid1;
    this.gid = gid;
    this.rdev = rdev;
    this.blksize = blksize;
    this.ino = ino;
    this.size = size21;
    this.blocks = blocks1;
}
StatsBase.prototype.isDirectory = function() {
    return this._checkModeProperty(S_IFDIR);
};
StatsBase.prototype.isFile = function() {
    return this._checkModeProperty(S_IFREG);
};
StatsBase.prototype.isBlockDevice = function() {
    return this._checkModeProperty(S_IFBLK);
};
StatsBase.prototype.isCharacterDevice = function() {
    return this._checkModeProperty(S_IFCHR);
};
StatsBase.prototype.isSymbolicLink = function() {
    return this._checkModeProperty(S_IFLNK);
};
StatsBase.prototype.isFIFO = function() {
    return this._checkModeProperty(S_IFIFO);
};
StatsBase.prototype.isSocket = function() {
    return this._checkModeProperty(S_IFSOCK);
};
const kNsPerMsBigInt = 10n ** 6n;
const kNsPerSecBigInt = 10n ** 9n;
const kMsPerSec = 10 ** 3;
const kNsPerMs = 10 ** 6;
function msFromTimeSpec(sec, nsec) {
    return sec * kMsPerSec + nsec / kNsPerMs;
}
function nsFromTimeSpecBigInt(sec, nsec) {
    return sec * kNsPerSecBigInt + nsec;
}
function dateFromMs(ms) {
    return new Date(Number(ms) + 0.5);
}
function BigIntStats(dev, mode2, nlink, uid2, gid, rdev, blksize, ino, size22, blocks2, atimeNs, mtimeNs, ctimeNs, birthtimeNs) {
    Reflect.apply(StatsBase, this, [
        dev,
        mode2,
        nlink,
        uid2,
        gid,
        rdev,
        blksize,
        ino,
        size22,
        blocks2, 
    ]);
    this.atimeMs = atimeNs / kNsPerMsBigInt;
    this.mtimeMs = mtimeNs / kNsPerMsBigInt;
    this.ctimeMs = ctimeNs / kNsPerMsBigInt;
    this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
    this.atimeNs = atimeNs;
    this.mtimeNs = mtimeNs;
    this.ctimeNs = ctimeNs;
    this.birthtimeNs = birthtimeNs;
    this.atime = dateFromMs(this.atimeMs);
    this.mtime = dateFromMs(this.mtimeMs);
    this.ctime = dateFromMs(this.ctimeMs);
    this.birthtime = dateFromMs(this.birthtimeMs);
}
Object.setPrototypeOf(BigIntStats.prototype, StatsBase.prototype);
Object.setPrototypeOf(BigIntStats, StatsBase);
BigIntStats.prototype._checkModeProperty = function(property) {
    if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & BigInt(S_IFMT)) === BigInt(property);
};
function Stats(dev, mode3, nlink, uid3, gid, rdev, blksize, ino, size23, blocks3, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
    StatsBase.call(this, dev, mode3, nlink, uid3, gid, rdev, blksize, ino, size23, blocks3);
    this.atimeMs = atimeMs;
    this.mtimeMs = mtimeMs;
    this.ctimeMs = ctimeMs;
    this.birthtimeMs = birthtimeMs;
    this.atime = dateFromMs(atimeMs);
    this.mtime = dateFromMs(mtimeMs);
    this.ctime = dateFromMs(ctimeMs);
    this.birthtime = dateFromMs(birthtimeMs);
}
Object.setPrototypeOf(Stats.prototype, StatsBase.prototype);
Object.setPrototypeOf(Stats, StatsBase);
Stats.prototype.isFile = StatsBase.prototype.isFile;
Stats.prototype._checkModeProperty = function(property) {
    if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & S_IFMT) === property;
};
function getStatsFromBinding(stats, offset = 0) {
    if (isBigUint64Array(stats)) {
        return new BigIntStats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]), nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]), nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]), nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset]));
    }
    return new Stats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], msFromTimeSpec(stats[10 + offset], stats[11 + offset]), msFromTimeSpec(stats[12 + offset], stats[13 + offset]), msFromTimeSpec(stats[14 + offset], stats[15 + offset]), msFromTimeSpec(stats[16 + offset], stats[17 + offset]));
}
function stringToFlags(flags, name6 = "flags") {
    if (typeof flags === "number") {
        validateInt32(flags, name6);
        return flags;
    }
    if (flags == null) {
        return O_RDONLY;
    }
    switch(flags){
        case "r":
            return O_RDONLY;
        case "rs":
        case "sr":
            return O_RDONLY | O_SYNC;
        case "r+":
            return O_RDWR;
        case "rs+":
        case "sr+":
            return O_RDWR | O_SYNC;
        case "w":
            return O_TRUNC | O_CREAT | O_WRONLY;
        case "wx":
        case "xw":
            return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
        case "w+":
            return O_TRUNC | O_CREAT | O_RDWR;
        case "wx+":
        case "xw+":
            return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
        case "a":
            return O_APPEND | O_CREAT | O_WRONLY;
        case "ax":
        case "xa":
            return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
        case "as":
        case "sa":
            return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;
        case "a+":
            return O_APPEND | O_CREAT | O_RDWR;
        case "ax+":
        case "xa+":
            return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
        case "as+":
        case "sa+":
            return O_APPEND | O_CREAT | O_RDWR | O_SYNC;
    }
    throw new ERR_INVALID_ARG_VALUE("flags", flags);
}
const stringToSymlinkType = hideStackFrames((type47)=>{
    let flags = 0;
    if (typeof type47 === "string") {
        switch(type47){
            case "dir":
                flags |= UV_FS_SYMLINK_DIR;
                break;
            case "junction":
                flags |= UV_FS_SYMLINK_JUNCTION;
                break;
            case "file":
                break;
            default:
                throw new ERR_FS_INVALID_SYMLINK_TYPE(type47);
        }
    }
    return flags;
});
function toUnixTimestamp(time, name7 = "time") {
    if (typeof time === "string" && +time == time) {
        return +time;
    }
    if (Number.isFinite(time)) {
        if (time < 0) {
            return Date.now() / 1000;
        }
        return time;
    }
    if (isDate1(time)) {
        return Date.getTime(time) / 1000;
    }
    throw new ERR_INVALID_ARG_TYPE(name7, [
        "Date",
        "Time in seconds"
    ], time);
}
const validateOffsetLengthRead = hideStackFrames((offset, length, bufferLength)=>{
    if (offset < 0) {
        throw new ERR_OUT_OF_RANGE("offset", ">= 0", offset);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    if (offset + length > bufferLength) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${bufferLength - offset}`, length);
    }
});
const validateOffsetLengthWrite = hideStackFrames((offset, length, byteLength9)=>{
    if (offset > byteLength9) {
        throw new ERR_OUT_OF_RANGE("offset", `<= ${byteLength9}`, offset);
    }
    if (length > byteLength9 - offset) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${byteLength9 - offset}`, length);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    validateInt32(length, "length", 0);
});
const validatePath = hideStackFrames((path64, propName = "path")=>{
    if (typeof path64 !== "string" && !isUint8Array(path64)) {
        throw new ERR_INVALID_ARG_TYPE(propName, [
            "string",
            "Buffer",
            "URL"
        ], path64);
    }
    const err = nullCheck(path64, propName, false);
    if (err !== undefined) {
        throw err;
    }
});
const getValidatedPath = hideStackFrames((fileURLOrPath, propName = "path")=>{
    const path65 = toPathIfFileURL(fileURLOrPath);
    validatePath(path65, propName);
    return path65;
});
const getValidatedFd = hideStackFrames((fd, propName = "fd")=>{
    if (Object.is(fd, -0)) {
        return 0;
    }
    validateInt32(fd, propName, 0);
    return fd;
});
const validateBufferArray = hideStackFrames((buffers, propName = "buffers")=>{
    if (!Array.isArray(buffers)) {
        throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
    }
    for(let i140 = 0; i140 < buffers.length; i140++){
        if (!isArrayBufferView(buffers[i140])) {
            throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
        }
    }
    return buffers;
});
let nonPortableTemplateWarn = true;
function warnOnNonPortableTemplate(template) {
    if (nonPortableTemplateWarn && template.endsWith("X")) {
        process1.emitWarning("mkdtemp() templates ending with X are not portable. " + "For details see: https://nodejs.org/api/fs.html");
        nonPortableTemplateWarn = false;
    }
}
const defaultCpOptions = {
    dereference: false,
    errorOnExist: false,
    filter: undefined,
    force: true,
    preserveTimestamps: false,
    recursive: false
};
const defaultRmOptions = {
    recursive: false,
    force: false,
    retryDelay: 100,
    maxRetries: 0
};
const defaultRmdirOptions = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false
};
const validateCpOptions = hideStackFrames((options)=>{
    if (options === undefined) {
        return {
            ...defaultCpOptions
        };
    }
    validateObject(options, "options");
    options = {
        ...defaultCpOptions,
        ...options
    };
    validateBoolean(options.dereference, "options.dereference");
    validateBoolean(options.errorOnExist, "options.errorOnExist");
    validateBoolean(options.force, "options.force");
    validateBoolean(options.preserveTimestamps, "options.preserveTimestamps");
    validateBoolean(options.recursive, "options.recursive");
    if (options.filter !== undefined) {
        validateFunction(options.filter, "options.filter");
    }
    return options;
});
const validateRmOptions = hideStackFrames((path66, options, expectDir, cb)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    stat(path66, (err, stats)=>{
        if (err) {
            if (options.force && err.code === "ENOENT") {
                return cb(null, options);
            }
            return cb(err, options);
        }
        if (expectDir && !stats.isDirectory()) {
            return cb(false);
        }
        if (stats.isDirectory() && !options.recursive) {
            return cb(new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path: path66,
                syscall: "rm",
                errno: EISDIR
            }));
        }
        return cb(null, options);
    });
});
const validateRmOptionsSync = hideStackFrames((path67, options, expectDir)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    if (!options.force || expectDir || !options.recursive) {
        const isDirectory = statSync(path67, {
            throwIfNoEntry: !options.force
        })?.isDirectory();
        if (expectDir && !isDirectory) {
            return false;
        }
        if (isDirectory && !options.recursive) {
            throw new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path: path67,
                syscall: "rm",
                errno: EISDIR
            });
        }
    }
    return options;
});
let recursiveRmdirWarned = process1.noDeprecation;
function emitRecursiveRmdirWarning() {
    if (!recursiveRmdirWarned) {
        process1.emitWarning("In future versions of Node.js, fs.rmdir(path, { recursive: true }) " + "will be removed. Use fs.rm(path, { recursive: true }) instead", "DeprecationWarning", "DEP0147");
        recursiveRmdirWarned = true;
    }
}
const validateRmdirOptions = hideStackFrames((options, defaults = defaultRmdirOptions)=>{
    if (options === undefined) {
        return defaults;
    }
    validateObject(options, "options");
    options = {
        ...defaults,
        ...options
    };
    validateBoolean(options.recursive, "options.recursive");
    validateInt32(options.retryDelay, "options.retryDelay", 0);
    validateUint32(options.maxRetries, "options.maxRetries");
    return options;
});
const getValidMode = hideStackFrames((mode4, type48)=>{
    let min23 = kMinimumAccessMode;
    let max = kMaximumAccessMode;
    let def = F_OK;
    if (type48 === "copyFile") {
        min23 = kMinimumCopyMode;
        max = kMaximumCopyMode;
        def = mode4 || kDefaultCopyMode;
    } else {
        assert2(type48 === "access");
    }
    if (mode4 == null) {
        return def;
    }
    if (Number.isInteger(mode4) && mode4 >= min23 && mode4 <= max) {
        return mode4;
    }
    if (typeof mode4 !== "number") {
        throw new ERR_INVALID_ARG_TYPE("mode", "integer", mode4);
    }
    throw new ERR_OUT_OF_RANGE("mode", `an integer >= ${min23} && <= ${max}`, mode4);
});
const validateStringAfterArrayBufferView = hideStackFrames((buffer27, name8)=>{
    if (typeof buffer27 === "string") {
        return;
    }
    if (typeof buffer27 === "object" && buffer27 !== null && typeof buffer27.toString === "function" && Object.prototype.hasOwnProperty.call(buffer27, "toString")) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name8, [
        "string",
        "Buffer",
        "TypedArray",
        "DataView"
    ], buffer27);
});
const validatePosition = hideStackFrames((position)=>{
    if (typeof position === "number") {
        validateInteger(position, "position");
    } else if (typeof position === "bigint") {
        if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
            throw new ERR_OUT_OF_RANGE("position", `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`, position);
        }
    } else {
        throw new ERR_INVALID_ARG_TYPE("position", [
            "integer",
            "bigint"
        ], position);
    }
});
({
    constants: {
        kIoMaxLength,
        kMaxUserId,
        kReadFileBufferLength,
        kReadFileUnknownBufferLength,
        kWriteFileMaxChunkSize
    },
    assertEncoding,
    BigIntStats,
    copyObject,
    Dirent,
    emitRecursiveRmdirWarning,
    getDirent,
    getDirents,
    getOptions: getOptions1,
    getValidatedFd,
    getValidatedPath,
    getValidMode,
    handleErrorFromBinding,
    nullCheck,
    preprocessSymlinkDestination,
    realpathCacheKey: Symbol("realpathCacheKey"),
    getStatsFromBinding,
    stringToFlags,
    stringToSymlinkType,
    Stats,
    toUnixTimestamp,
    validateBufferArray,
    validateCpOptions,
    validateOffsetLengthRead,
    validateOffsetLengthWrite,
    validatePath,
    validatePosition,
    validateRmOptions,
    validateRmOptionsSync,
    validateRmdirOptions,
    validateStringAfterArrayBufferView,
    warnOnNonPortableTemplate
});
function access(path68, mode5, callback) {
    if (typeof mode5 === "function") {
        callback = mode5;
        mode5 = fs.F_OK;
    }
    path68 = getValidatedPath(path68).toString();
    mode5 = getValidMode(mode5, "access");
    const cb = makeCallback(callback);
    Deno.lstat(path68).then((info)=>{
        const m = +mode5 || 0;
        let fileMode = +info.mode || 0;
        if (Deno.build.os !== "windows" && info.uid === getUid()) {
            fileMode >>= 6;
        }
        if ((m & fileMode) === m) {
            cb(null);
        } else {
            const e = new Error(`EACCES: permission denied, access '${path68}'`);
            e.path = path68;
            e.syscall = "access";
            e.errno = os.errno.EACCES;
            e.code = "EACCES";
            cb(e);
        }
    }, (err)=>{
        if (err instanceof Deno.errors.NotFound) {
            const e = new Error(`ENOENT: no such file or directory, access '${path68}'`);
            e.path = path68;
            e.syscall = "access";
            e.errno = os.errno.ENOENT;
            e.code = "ENOENT";
            cb(e);
        } else {
            cb(err);
        }
    });
}
function accessSync(path69, mode6) {
    path69 = getValidatedPath(path69).toString();
    mode6 = getValidMode(mode6, "access");
    try {
        const info = Deno.lstatSync(path69.toString());
        const m = +mode6 || 0;
        const fileMode = +info.mode || 0;
        if ((m & fileMode) === m) {} else {
            const e = new Error(`EACCES: permission denied, access '${path69}'`);
            e.path = path69;
            e.syscall = "access";
            e.errno = os.errno.EACCES;
            e.code = "EACCES";
            throw e;
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            const e = new Error(`ENOENT: no such file or directory, access '${path69}'`);
            e.path = path69;
            e.syscall = "access";
            e.errno = os.errno.ENOENT;
            e.code = "ENOENT";
            throw e;
        } else {
            throw err;
        }
    }
}
function writeFile(pathOrRid, data19, optOrCallback, callback) {
    const callbackFn = optOrCallback instanceof Function ? optOrCallback : callback;
    const options = optOrCallback instanceof Function ? undefined : optOrCallback;
    if (!callbackFn) {
        throw new TypeError("Callback must be a function.");
    }
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl5(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode7 = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data19)) {
        validateStringAfterArrayBufferView(data19, "data");
        data19 = Buffer.from(String(data19), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error11 = null;
    (async ()=>{
        try {
            file = isRid ? new Deno.FsFile(pathOrRid) : await Deno.open(pathOrRid, openOptions);
            if (!isRid && mode7 && !isWindows) {
                await Deno.chmod(pathOrRid, mode7);
            }
            const signal = isFileOptions(options) ? options.signal : undefined;
            await writeAll1(file, data19, {
                signal
            });
        } catch (e) {
            error11 = e instanceof Error ? denoErrorToNodeError(e, {
                syscall: "write"
            }) : new Error("[non-error thrown]");
        } finally{
            if (!isRid && file) file.close();
            callbackFn(error11);
        }
    })();
}
function writeFileSync(pathOrRid, data20, options) {
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl5(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode8 = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data20)) {
        validateStringAfterArrayBufferView(data20, "data");
        data20 = Buffer.from(String(data20), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error12 = null;
    try {
        file = isRid ? new Deno.FsFile(pathOrRid) : Deno.openSync(pathOrRid, openOptions);
        if (!isRid && mode8 && !isWindows) {
            Deno.chmodSync(pathOrRid, mode8);
        }
        writeAllSync(file, data20);
    } catch (e) {
        error12 = e instanceof Error ? denoErrorToNodeError(e, {
            syscall: "write"
        }) : new Error("[non-error thrown]");
    } finally{
        if (!isRid && file) file.close();
    }
    if (error12) throw error12;
}
async function writeAll1(w, arr, options = {}) {
    const { offset =0 , length =arr.byteLength , signal  } = options;
    checkAborted(signal);
    const written = await w.write(arr.subarray(offset, offset + length));
    if (written === length) {
        return;
    }
    await writeAll1(w, arr, {
        offset: offset + written,
        length: length - written,
        signal
    });
}
function checkAborted(signal) {
    if (signal?.aborted) {
        throw new AbortError();
    }
}
function appendFile(path70, data21, options, callback) {
    callback = maybeCallback(callback || options);
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 0o666,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path70)) {
        options.flag = "a";
    }
    writeFile(path70, data21, options, callback);
}
function appendFileSync(path71, data22, options) {
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 0o666,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path71)) {
        options.flag = "a";
    }
    writeFileSync(path71, data22, options);
}
function chmod(path72, mode9, callback) {
    path72 = getValidatedPath(path72).toString();
    mode9 = parseFileMode(mode9, "mode");
    Deno.chmod(toNamespacedPath2(path72), mode9).then(()=>callback(null), callback);
}
function chmodSync(path73, mode10) {
    path73 = getValidatedPath(path73).toString();
    mode10 = parseFileMode(mode10, "mode");
    Deno.chmodSync(toNamespacedPath2(path73), mode10);
}
function chown(path74, uid4, gid, callback) {
    callback = makeCallback(callback);
    path74 = getValidatedPath(path74).toString();
    validateInteger(uid4, "uid", -1, kMaxUserId);
    validateInteger(gid, "gid", -1, kMaxUserId);
    Deno.chown(toNamespacedPath2(path74), uid4, gid).then(()=>callback(null), callback);
}
function chownSync(path75, uid5, gid) {
    path75 = getValidatedPath(path75).toString();
    validateInteger(uid5, "uid", -1, kMaxUserId);
    validateInteger(gid, "gid", -1, kMaxUserId);
    Deno.chownSync(toNamespacedPath2(path75), uid5, gid);
}
function close(fd, callback) {
    setTimeout(()=>{
        let error13 = null;
        try {
            Deno.close(fd);
        } catch (err) {
            error13 = err instanceof Error ? err : new Error("[non-error thrown]");
        }
        callback(error13);
    }, 0);
}
function closeSync(fd) {
    Deno.close(fd);
}
class ReadStream extends Readable {
    path;
    constructor(path76, opts){
        path76 = path76 instanceof URL ? fromFileUrl5(path76) : path76;
        const hasBadOptions = opts && (opts.fd || opts.start || opts.end || opts.fs);
        if (hasBadOptions) {
            notImplemented();
        }
        const file = Deno.openSync(path76, {
            read: true
        });
        const buffer28 = new Uint8Array(16 * 1024);
        super({
            autoDestroy: true,
            emitClose: true,
            objectMode: false,
            read: async function(_size) {
                try {
                    const n = await file.read(buffer28);
                    this.push(n ? Buffer.from(buffer28.slice(0, n)) : null);
                } catch (err) {
                    this.destroy(err);
                }
            },
            destroy: (err, cb)=>{
                try {
                    file.close();
                } catch  {}
                cb(err);
            }
        });
        this.path = path76;
    }
}
function createReadStream(path77, options) {
    return new ReadStream(path77, options);
}
const { F_OK: F_OK1 , R_OK: R_OK1 , W_OK: W_OK1 , X_OK: X_OK1 , S_IRUSR , S_IWUSR , S_IXUSR , S_IRGRP , S_IWGRP , S_IXGRP , S_IROTH , S_IWOTH , S_IXOTH , COPYFILE_EXCL: COPYFILE_EXCL1 , COPYFILE_FICLONE: COPYFILE_FICLONE1 , COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1 , UV_FS_COPYFILE_EXCL , UV_FS_COPYFILE_FICLONE , UV_FS_COPYFILE_FICLONE_FORCE ,  } = fs;
const mod52 = {
    F_OK: F_OK1,
    R_OK: R_OK1,
    W_OK: W_OK1,
    X_OK: X_OK1,
    S_IRUSR: S_IRUSR,
    S_IWUSR: S_IWUSR,
    S_IXUSR: S_IXUSR,
    S_IRGRP: S_IRGRP,
    S_IWGRP: S_IWGRP,
    S_IXGRP: S_IXGRP,
    S_IROTH: S_IROTH,
    S_IWOTH: S_IWOTH,
    S_IXOTH: S_IXOTH,
    COPYFILE_EXCL: COPYFILE_EXCL1,
    COPYFILE_FICLONE: COPYFILE_FICLONE1,
    COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1,
    UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL,
    UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE,
    UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE
};
function copyFile(src, dest, mode11, callback) {
    if (typeof mode11 === "function") {
        callback = mode11;
        mode11 = 0;
    }
    const srcStr = getValidatedPath(src, "src").toString();
    const destStr = getValidatedPath(dest, "dest").toString();
    const modeNum = getValidMode(mode11, "copyFile");
    const cb = makeCallback(callback);
    if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        Deno.lstat(destStr).then(()=>{
            const e = new Error(`EEXIST: file already exists, copyfile '${srcStr}' -> '${destStr}'`);
            e.syscall = "copyfile";
            e.errno = os.errno.EEXIST;
            e.code = "EEXIST";
            cb(e);
        }, (e)=>{
            if (e instanceof Deno.errors.NotFound) {
                Deno.copyFile(srcStr, destStr).then(()=>cb(null), cb);
            }
            cb(e);
        });
    } else {
        Deno.copyFile(srcStr, destStr).then(()=>cb(null), cb);
    }
}
function copyFileSync(src, dest, mode12) {
    const srcStr = getValidatedPath(src, "src").toString();
    const destStr = getValidatedPath(dest, "dest").toString();
    const modeNum = getValidMode(mode12, "copyFile");
    if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        try {
            Deno.lstatSync(destStr);
            throw new Error(`A file exists at the destination: ${destStr}`);
        } catch (e) {
            if (e instanceof Deno.errors.NotFound) {
                Deno.copyFileSync(srcStr, destStr);
            }
            throw e;
        }
    } else {
        Deno.copyFileSync(srcStr, destStr);
    }
}
class Dirent1 {
    constructor(entry){
        this.entry = entry;
    }
    isBlockDevice() {
        notImplemented("Deno does not yet support identification of block devices");
        return false;
    }
    isCharacterDevice() {
        notImplemented("Deno does not yet support identification of character devices");
        return false;
    }
    isDirectory() {
        return this.entry.isDirectory;
    }
    isFIFO() {
        notImplemented("Deno does not yet support identification of FIFO named pipes");
        return false;
    }
    isFile() {
        return this.entry.isFile;
    }
    isSocket() {
        notImplemented("Deno does not yet support identification of sockets");
        return false;
    }
    isSymbolicLink() {
        return this.entry.isSymlink;
    }
    get name() {
        return this.entry.name;
    }
    entry;
}
class Dir {
    dirPath;
    syncIterator;
    asyncIterator;
    constructor(path78){
        this.dirPath = path78;
    }
    get path() {
        if (this.dirPath instanceof Uint8Array) {
            return new TextDecoder().decode(this.dirPath);
        }
        return this.dirPath;
    }
    read(callback) {
        return new Promise((resolve16, reject)=>{
            if (!this.asyncIterator) {
                this.asyncIterator = Deno.readDir(this.path)[Symbol.asyncIterator]();
            }
            assert1(this.asyncIterator);
            this.asyncIterator.next().then(({ value  })=>{
                resolve16(value ? value : null);
                if (callback) {
                    callback(null, value ? value : null);
                }
            }, (err)=>{
                if (callback) {
                    callback(err);
                }
                reject(err);
            });
        });
    }
    readSync() {
        if (!this.syncIterator) {
            this.syncIterator = Deno.readDirSync(this.path)[Symbol.iterator]();
        }
        const file = this.syncIterator.next().value;
        return file ? new Dirent1(file) : null;
    }
    close(callback) {
        return new Promise((resolve17)=>{
            if (callback) {
                callback(null);
            }
            resolve17();
        });
    }
    closeSync() {}
    async *[Symbol.asyncIterator]() {
        try {
            while(true){
                const dirent = await this.read();
                if (dirent === null) {
                    break;
                }
                yield dirent;
            }
        } finally{
            await this.close();
        }
    }
}
function exists(path79, callback) {
    path79 = path79 instanceof URL ? fromFileUrl5(path79) : path79;
    Deno.lstat(path79).then(()=>callback(true), ()=>callback(false));
}
function existsSync(path80) {
    path80 = path80 instanceof URL ? fromFileUrl5(path80) : path80;
    try {
        Deno.lstatSync(path80);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
function fdatasync(fd, callback) {
    Deno.fdatasync(fd).then(()=>callback(null), callback);
}
function fdatasyncSync(fd) {
    Deno.fdatasyncSync(fd);
}
function fstat(fd, optionsOrCallback, maybeCallback3) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback3;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.fstat(fd).then((stat3)=>callback(null, CFISBIS(stat3, options.bigint)), (err)=>callback(err));
}
function fstatSync(fd, options) {
    const origin = Deno.fstatSync(fd);
    return CFISBIS(origin, options?.bigint || false);
}
function fsync(fd, callback) {
    Deno.fsync(fd).then(()=>callback(null), callback);
}
function fsyncSync(fd) {
    Deno.fsyncSync(fd);
}
function ftruncate(fd, lenOrCallback, maybeCallback4) {
    const len = typeof lenOrCallback === "number" ? lenOrCallback : undefined;
    const callback = typeof lenOrCallback === "function" ? lenOrCallback : maybeCallback4;
    if (!callback) throw new Error("No callback function supplied");
    Deno.ftruncate(fd, len).then(()=>callback(null), callback);
}
function ftruncateSync(fd, len) {
    Deno.ftruncateSync(fd, len);
}
function getValidTime(time, name52) {
    if (typeof time === "string") {
        time = Number(time);
    }
    if (typeof time === "number" && (Number.isNaN(time) || !Number.isFinite(time))) {
        throw new Deno.errors.InvalidData(`invalid ${name52}, must not be infinity or NaN`);
    }
    return time;
}
function futimes(fd, atime, mtime, callback) {
    if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
    }
    atime = getValidTime(atime, "atime");
    mtime = getValidTime(mtime, "mtime");
    futime(fd, atime, mtime).then(()=>callback(null), callback);
}
function futimesSync(fd, atime, mtime) {
    atime = getValidTime(atime, "atime");
    mtime = getValidTime(mtime, "mtime");
    futimeSync(fd, atime, mtime);
}
function link(existingPath, newPath, callback) {
    existingPath = existingPath instanceof URL ? fromFileUrl5(existingPath) : existingPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.link(existingPath, newPath).then(()=>callback(null), callback);
}
function linkSync(existingPath, newPath) {
    existingPath = existingPath instanceof URL ? fromFileUrl5(existingPath) : existingPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.linkSync(existingPath, newPath);
}
function mkdir(path81, options, callback) {
    path81 = path81 instanceof URL ? fromFileUrl5(path81) : path81;
    let mode13 = 0o777;
    let recursive = false;
    if (typeof options == "function") {
        callback = options;
    } else if (typeof options === "number") {
        mode13 = options;
    } else if (typeof options === "boolean") {
        recursive = options;
    } else if (options) {
        if (options.recursive !== undefined) recursive = options.recursive;
        if (options.mode !== undefined) mode13 = options.mode;
    }
    if (typeof recursive !== "boolean") {
        throw new Deno.errors.InvalidData("invalid recursive option , must be a boolean");
    }
    Deno.mkdir(path81, {
        recursive,
        mode: mode13
    }).then(()=>{
        if (typeof callback === "function") {
            callback(null);
        }
    }, (err)=>{
        if (typeof callback === "function") {
            callback(err);
        }
    });
}
function mkdirSync(path82, options) {
    path82 = path82 instanceof URL ? fromFileUrl5(path82) : path82;
    let mode14 = 0o777;
    let recursive = false;
    if (typeof options === "number") {
        mode14 = options;
    } else if (typeof options === "boolean") {
        recursive = options;
    } else if (options) {
        if (options.recursive !== undefined) recursive = options.recursive;
        if (options.mode !== undefined) mode14 = options.mode;
    }
    if (typeof recursive !== "boolean") {
        throw new Deno.errors.InvalidData("invalid recursive option , must be a boolean");
    }
    Deno.mkdirSync(path82, {
        recursive,
        mode: mode14
    });
}
function mkdtemp(prefix, optionsOrCallback, maybeCallback5) {
    const callback = typeof optionsOrCallback == "function" ? optionsOrCallback : maybeCallback5;
    if (!callback) throw new ERR_INVALID_CALLBACK(callback);
    const encoding = parseEncoding(optionsOrCallback);
    const path83 = tempDirPath(prefix);
    mkdir(path83, {
        recursive: false,
        mode: 0o700
    }, (err)=>{
        if (err) callback(err);
        else callback(null, decode3(path83, encoding));
    });
}
function mkdtempSync(prefix, options) {
    const encoding = parseEncoding(options);
    const path84 = tempDirPath(prefix);
    mkdirSync(path84, {
        recursive: false,
        mode: 0o700
    });
    return decode3(path84, encoding);
}
function parseEncoding(optionsOrCallback) {
    let encoding;
    if (typeof optionsOrCallback == "function") encoding = undefined;
    else if (optionsOrCallback instanceof Object) {
        encoding = optionsOrCallback?.encoding;
    } else encoding = optionsOrCallback;
    if (encoding) {
        try {
            new TextDecoder(encoding);
        } catch  {
            throw new ERR_INVALID_OPT_VALUE_ENCODING(encoding);
        }
    }
    return encoding;
}
function decode3(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
const CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function randomName() {
    return [
        ...Array(6)
    ].map(()=>CHARS[Math.floor(Math.random() * CHARS.length)]).join("");
}
function tempDirPath(prefix) {
    let path85;
    do {
        path85 = prefix + randomName();
    }while (existsSync(path85))
    return path85;
}
function existsSync1(filePath) {
    try {
        Deno.lstatSync(filePath);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
function convertFlagAndModeToOptions(flag, mode15) {
    if (!flag && !mode15) return undefined;
    if (!flag && mode15) return {
        mode: mode15
    };
    return {
        ...getOpenOptions(flag),
        mode: mode15
    };
}
function open(path86, flagsOrCallback, callbackOrMode, maybeCallback6) {
    const flags = typeof flagsOrCallback === "string" ? flagsOrCallback : undefined;
    const callback = typeof flagsOrCallback === "function" ? flagsOrCallback : typeof callbackOrMode === "function" ? callbackOrMode : maybeCallback6;
    const mode16 = typeof callbackOrMode === "number" ? callbackOrMode : undefined;
    path86 = path86 instanceof URL ? fromFileUrl5(path86) : path86;
    if (!callback) throw new Error("No callback function supplied");
    if ([
        "ax",
        "ax+",
        "wx",
        "wx+"
    ].includes(flags || "") && existsSync1(path86)) {
        const err = new Error(`EEXIST: file already exists, open '${path86}'`);
        callback(err);
    } else {
        if (flags === "as" || flags === "as+") {
            let err = null, res;
            try {
                res = openSync(path86, flags, mode16);
            } catch (error14) {
                err = error14 instanceof Error ? error14 : new Error("[non-error thrown]");
            }
            if (err) {
                callback(err);
            } else {
                callback(null, res);
            }
            return;
        }
        Deno.open(path86, convertFlagAndModeToOptions(flags, mode16)).then((file)=>callback(null, file.rid), (err)=>callback(err));
    }
}
function openSync(path87, flagsOrMode, maybeMode) {
    const flags = typeof flagsOrMode === "string" ? flagsOrMode : undefined;
    const mode17 = typeof flagsOrMode === "number" ? flagsOrMode : maybeMode;
    path87 = path87 instanceof URL ? fromFileUrl5(path87) : path87;
    if ([
        "ax",
        "ax+",
        "wx",
        "wx+"
    ].includes(flags || "") && existsSync1(path87)) {
        throw new Error(`EEXIST: file already exists, open '${path87}'`);
    }
    return Deno.openSync(path87, convertFlagAndModeToOptions(flags, mode17)).rid;
}
function read(fd, optOrBuffer, offsetOrCallback, length, position, callback) {
    let cb;
    let offset = 0, buffer29;
    if (length == null) {
        length = 0;
    }
    if (typeof offsetOrCallback === "function") {
        cb = offsetOrCallback;
    } else if (typeof optOrBuffer === "function") {
        cb = optOrBuffer;
    } else {
        offset = offsetOrCallback;
        cb = callback;
    }
    if (!cb) throw new Error("No callback function supplied");
    if (optOrBuffer instanceof Buffer || optOrBuffer instanceof Uint8Array) {
        buffer29 = optOrBuffer;
    } else if (typeof optOrBuffer === "function") {
        offset = 0;
        buffer29 = Buffer.alloc(16384);
        length = buffer29.byteLength;
        position = null;
    } else {
        const opt = optOrBuffer;
        offset = opt.offset ?? 0;
        buffer29 = opt.buffer ?? Buffer.alloc(16384);
        length = opt.length ?? buffer29.byteLength;
        position = opt.position ?? null;
    }
    assert(offset >= 0, "offset should be greater or equal to 0");
    assert(offset + length <= buffer29.byteLength, `buffer doesn't have enough data: byteLength = ${buffer29.byteLength}, offset + length = ${offset + length}`);
    if (buffer29.byteLength == 0) {
        throw new ERR_INVALID_ARG_VALUE("buffer", buffer29, "is empty and cannot be written");
    }
    let err = null, numberOfBytesRead = null;
    if (position) {
        Deno.seekSync(fd, position, Deno.SeekMode.Current);
    }
    try {
        numberOfBytesRead = Deno.readSync(fd, buffer29);
    } catch (error15) {
        err = error15 instanceof Error ? error15 : new Error("[non-error thrown]");
    }
    if (err) {
        callback(err);
    } else {
        const data23 = Buffer.from(buffer29.buffer, offset, length);
        cb(null, numberOfBytesRead, data23);
    }
    return;
}
function readSync(fd, buffer30, offsetOrOpt, length, position) {
    let offset = 0;
    if (length == null) {
        length = 0;
    }
    if (buffer30.byteLength == 0) {
        throw new ERR_INVALID_ARG_VALUE("buffer", buffer30, "is empty and cannot be written");
    }
    if (typeof offsetOrOpt === "number") {
        offset = offsetOrOpt;
    } else {
        const opt = offsetOrOpt;
        offset = opt.offset ?? 0;
        length = opt.length ?? buffer30.byteLength;
        position = opt.position ?? null;
    }
    assert(offset >= 0, "offset should be greater or equal to 0");
    assert(offset + length <= buffer30.byteLength, `buffer doesn't have enough data: byteLength = ${buffer30.byteLength}, offset + length = ${offset + length}`);
    if (position) {
        Deno.seekSync(fd, position, Deno.SeekMode.Current);
    }
    const numberOfBytesRead = Deno.readSync(fd, buffer30);
    return numberOfBytesRead ?? 0;
}
function asyncIterableToCallback(iter, callback, errCallback) {
    const iterator = iter[Symbol.asyncIterator]();
    function next() {
        iterator.next().then((obj)=>{
            if (obj.done) {
                callback(obj.value, true);
                return;
            }
            callback(obj.value);
            next();
        }, errCallback);
    }
    next();
}
function watch(filename, optionsOrListener, optionsOrListener2) {
    const listener = typeof optionsOrListener === "function" ? optionsOrListener : typeof optionsOrListener2 === "function" ? optionsOrListener2 : undefined;
    const options = typeof optionsOrListener === "object" ? optionsOrListener : typeof optionsOrListener2 === "object" ? optionsOrListener2 : undefined;
    filename = filename instanceof URL ? fromFileUrl5(filename) : filename;
    const iterator = Deno.watchFs(filename, {
        recursive: options?.recursive || false
    });
    if (!listener) throw new Error("No callback function supplied");
    const fsWatcher = new FSWatcher(()=>{
        if (iterator.return) iterator.return();
    });
    fsWatcher.on("change", listener);
    asyncIterableToCallback(iterator, (val, done)=>{
        if (done) return;
        fsWatcher.emit("change", val.kind, val.paths[0]);
    }, (e)=>{
        fsWatcher.emit("error", e);
    });
    return fsWatcher;
}
class FSWatcher extends EventEmitter {
    close;
    constructor(closer){
        super();
        this.close = closer;
    }
    ref() {
        notImplemented("FSWatcher.ref() is not implemented");
    }
    unref() {
        notImplemented("FSWatcher.unref() is not implemented");
    }
}
function toDirent(val) {
    return new Dirent1(val);
}
function readdir(path88, optionsOrCallback, maybeCallback7) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback7;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : null;
    const result = [];
    path88 = getValidatedPath(path88);
    if (!callback) throw new Error("No callback function supplied");
    if (options?.encoding) {
        try {
            new TextDecoder(options.encoding);
        } catch  {
            throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`);
        }
    }
    try {
        asyncIterableToCallback(Deno.readDir(path88.toString()), (val, done)=>{
            if (typeof path88 !== "string") return;
            if (done) {
                callback(null, result);
                return;
            }
            if (options?.withFileTypes) {
                result.push(toDirent(val));
            } else result.push(decode4(val.name));
        }, (e)=>{
            callback(denoErrorToNodeError(e, {
                syscall: "readdir"
            }));
        });
    } catch (e) {
        callback(denoErrorToNodeError(e, {
            syscall: "readdir"
        }));
    }
}
function decode4(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
function readdirSync(path89, options) {
    const result = [];
    path89 = getValidatedPath(path89);
    if (options?.encoding) {
        try {
            new TextDecoder(options.encoding);
        } catch  {
            throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`);
        }
    }
    try {
        for (const file of Deno.readDirSync(path89.toString())){
            if (options?.withFileTypes) {
                result.push(toDirent(file));
            } else result.push(decode4(file.name));
        }
    } catch (e) {
        throw denoErrorToNodeError(e, {
            syscall: "readdir"
        });
    }
    return result;
}
function maybeDecode(data24, encoding) {
    const buffer31 = Buffer.from(data24.buffer, data24.byteOffset, data24.byteLength);
    if (encoding && encoding !== "binary") return buffer31.toString(encoding);
    return buffer31;
}
function readFile(path90, optOrCallback, callback) {
    path90 = path90 instanceof URL ? fromFileUrl5(path90) : path90;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding(optOrCallback);
    const p = Deno.readFile(path90);
    if (cb) {
        p.then((data25)=>{
            if (encoding && encoding !== "binary") {
                const text = maybeDecode(data25, encoding);
                return cb(null, text);
            }
            const buffer32 = maybeDecode(data25, encoding);
            cb(null, buffer32);
        }, (err)=>cb && cb(err));
    }
}
function readFileSync(path91, opt) {
    path91 = path91 instanceof URL ? fromFileUrl5(path91) : path91;
    const data26 = Deno.readFileSync(path91);
    const encoding = getEncoding(opt);
    if (encoding && encoding !== "binary") {
        const text = maybeDecode(data26, encoding);
        return text;
    }
    const buffer33 = maybeDecode(data26, encoding);
    return buffer33;
}
function maybeEncode(data27, encoding) {
    if (encoding === "buffer") {
        return new TextEncoder().encode(data27);
    }
    return data27;
}
function getEncoding1(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    } else {
        if (optOrCallback.encoding) {
            if (optOrCallback.encoding === "utf8" || optOrCallback.encoding === "utf-8") {
                return "utf8";
            } else if (optOrCallback.encoding === "buffer") {
                return "buffer";
            } else {
                notImplemented();
            }
        }
        return null;
    }
}
function readlink(path92, optOrCallback, callback) {
    path92 = path92 instanceof URL ? fromFileUrl5(path92) : path92;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding1(optOrCallback);
    intoCallbackAPIWithIntercept(Deno.readLink, (data28)=>maybeEncode(data28, encoding), cb, path92);
}
function readlinkSync(path93, opt) {
    path93 = path93 instanceof URL ? fromFileUrl5(path93) : path93;
    return maybeEncode(Deno.readLinkSync(path93), getEncoding1(opt));
}
function realpath(path112, options, callback) {
    if (typeof options === "function") {
        callback = options;
    }
    if (!callback) {
        throw new Error("No callback function supplied");
    }
    Deno.realPath(path112).then((path94)=>callback(null, path94), (err)=>callback(err));
}
realpath.native = realpath;
function realpathSync(path95) {
    return Deno.realPathSync(path95);
}
realpathSync.native = realpathSync;
function rename(oldPath, newPath, callback) {
    oldPath = oldPath instanceof URL ? fromFileUrl5(oldPath) : oldPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    if (!callback) throw new Error("No callback function supplied");
    Deno.rename(oldPath, newPath).then((_)=>callback(), callback);
}
function renameSync(oldPath, newPath) {
    oldPath = oldPath instanceof URL ? fromFileUrl5(oldPath) : oldPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.renameSync(oldPath, newPath);
}
function rmdir(path96, optionsOrCallback, maybeCallback8) {
    path96 = toNamespacedPath5(getValidatedPath(path96));
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback8;
    const options1 = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    if (options1?.recursive) {
        emitRecursiveRmdirWarning();
        validateRmOptions(path96, {
            ...options1,
            force: false
        }, true, (err, options)=>{
            if (err === false) {
                return callback(new ERR_FS_RMDIR_ENOTDIR(path96.toString()));
            }
            if (err) {
                return callback(err);
            }
            Deno.remove(path96, {
                recursive: options?.recursive
            }).then((_)=>callback(), callback);
        });
    } else {
        validateRmdirOptions(options1);
        Deno.remove(path96, {
            recursive: options1?.recursive
        }).then((_)=>callback(), (err)=>{
            callback(err instanceof Error ? denoErrorToNodeError(err, {
                syscall: "rmdir"
            }) : err);
        });
    }
}
function rmdirSync(path97, options) {
    path97 = getValidatedPath(path97);
    if (options?.recursive) {
        emitRecursiveRmdirWarning();
        options = validateRmOptionsSync(path97, {
            ...options,
            force: false
        }, true);
        if (options === false) {
            throw new ERR_FS_RMDIR_ENOTDIR(path97.toString());
        }
    } else {
        validateRmdirOptions(options);
    }
    try {
        Deno.removeSync(toNamespacedPath5(path97), {
            recursive: options?.recursive
        });
    } catch (err) {
        throw err instanceof Error ? denoErrorToNodeError(err, {
            syscall: "rmdir"
        }) : err;
    }
}
function rm(path98, optionsOrCallback, maybeCallback9) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback9;
    const options1 = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    validateRmOptions(path98, options1, false, (err1, options)=>{
        if (err1) {
            return callback(err1);
        }
        Deno.remove(path98, {
            recursive: options?.recursive
        }).then((_)=>callback(null), (err)=>{
            if (options?.force && err instanceof Deno.errors.NotFound) {
                callback(null);
            } else {
                callback(err instanceof Error ? denoErrorToNodeError(err, {
                    syscall: "rm"
                }) : err);
            }
        });
    });
}
function rmSync(path99, options) {
    options = validateRmOptionsSync(path99, options, false);
    try {
        Deno.removeSync(path99, {
            recursive: options?.recursive
        });
    } catch (err) {
        if (options?.force && err instanceof Deno.errors.NotFound) {
            return;
        }
        if (err instanceof Error) {
            throw denoErrorToNodeError(err, {
                syscall: "stat"
            });
        } else {
            throw err;
        }
    }
}
function symlink(target, path100, typeOrCallback, maybeCallback10) {
    target = target instanceof URL ? fromFileUrl5(target) : target;
    path100 = path100 instanceof URL ? fromFileUrl5(path100) : path100;
    const type49 = typeof typeOrCallback === "string" ? typeOrCallback : "file";
    const callback = typeof typeOrCallback === "function" ? typeOrCallback : maybeCallback10;
    if (!callback) throw new Error("No callback function supplied");
    Deno.symlink(target, path100, {
        type: type49
    }).then(()=>callback(null), callback);
}
function symlinkSync(target, path101, type50) {
    target = target instanceof URL ? fromFileUrl5(target) : target;
    path101 = path101 instanceof URL ? fromFileUrl5(path101) : path101;
    type50 = type50 || "file";
    Deno.symlinkSync(target, path101, {
        type: type50
    });
}
function truncate(path102, lenOrCallback, maybeCallback11) {
    path102 = path102 instanceof URL ? fromFileUrl5(path102) : path102;
    const len = typeof lenOrCallback === "number" ? lenOrCallback : undefined;
    const callback = typeof lenOrCallback === "function" ? lenOrCallback : maybeCallback11;
    if (!callback) throw new Error("No callback function supplied");
    Deno.truncate(path102, len).then(()=>callback(null), callback);
}
function truncateSync(path103, len) {
    path103 = path103 instanceof URL ? fromFileUrl5(path103) : path103;
    Deno.truncateSync(path103, len);
}
function unlink(path104, callback) {
    if (!callback) throw new Error("No callback function supplied");
    Deno.remove(path104).then((_)=>callback(), callback);
}
function unlinkSync(path105) {
    Deno.removeSync(path105);
}
function getValidTime1(time, name53) {
    if (typeof time === "string") {
        time = Number(time);
    }
    if (typeof time === "number" && (Number.isNaN(time) || !Number.isFinite(time))) {
        throw new Deno.errors.InvalidData(`invalid ${name53}, must not be infinity or NaN`);
    }
    return time;
}
function utimes(path106, atime, mtime, callback) {
    path106 = path106 instanceof URL ? fromFileUrl5(path106) : path106;
    if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
    }
    atime = getValidTime1(atime, "atime");
    mtime = getValidTime1(mtime, "mtime");
    utime(path106, atime, mtime).then(()=>callback(null), callback);
}
function utimesSync(path107, atime, mtime) {
    path107 = path107 instanceof URL ? fromFileUrl5(path107) : path107;
    atime = getValidTime1(atime, "atime");
    mtime = getValidTime1(mtime, "mtime");
    utimeSync(path107, atime, mtime);
}
function writeSync(fd1, buffer1, offset1, length1, position1) {
    fd1 = getValidatedFd(fd1);
    const innerWriteSync = (fd, buffer34, offset, length, position)=>{
        if (buffer34 instanceof DataView) {
            buffer34 = new Uint8Array(buffer34.buffer);
        }
        if (typeof position === "number") {
            Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        let currentOffset = offset;
        while(currentOffset - offset < length){
            currentOffset += Deno.writeSync(fd, buffer34.subarray(currentOffset));
        }
        return currentOffset - offset;
    };
    if (isArrayBufferView(buffer1)) {
        if (position1 === undefined) {
            position1 = null;
        }
        if (offset1 == null) {
            offset1 = 0;
        } else {
            validateInteger(offset1, "offset", 0);
        }
        if (typeof length1 !== "number") {
            length1 = buffer1.byteLength - offset1;
        }
        validateOffsetLengthWrite(offset1, length1, buffer1.byteLength);
        return innerWriteSync(fd1, buffer1, offset1, length1, position1);
    }
    validateStringAfterArrayBufferView(buffer1, "buffer");
    validateEncoding(buffer1, length1);
    if (offset1 === undefined) {
        offset1 = null;
    }
    buffer1 = Buffer.from(buffer1, length1);
    return innerWriteSync(fd1, buffer1, 0, buffer1.length, position1);
}
function write(fd2, buffer2, offset2, length2, position2, callback) {
    fd2 = getValidatedFd(fd2);
    const innerWrite = async (fd, buffer35, offset, length, position)=>{
        if (buffer35 instanceof DataView) {
            buffer35 = new Uint8Array(buffer35.buffer);
        }
        if (typeof position === "number") {
            await Deno.seek(fd, position, Deno.SeekMode.Start);
        }
        let currentOffset = offset;
        while(currentOffset - offset < length){
            currentOffset += await Deno.write(fd, buffer35.subarray(currentOffset));
        }
        return currentOffset - offset;
    };
    if (isArrayBufferView(buffer2)) {
        callback = maybeCallback(callback || position2 || length2 || offset2);
        if (offset2 == null || typeof offset2 === "function") {
            offset2 = 0;
        } else {
            validateInteger(offset2, "offset", 0);
        }
        if (typeof length2 !== "number") {
            length2 = buffer2.byteLength - offset2;
        }
        if (typeof position2 !== "number") {
            position2 = null;
        }
        validateOffsetLengthWrite(offset2, length2, buffer2.byteLength);
        innerWrite(fd2, buffer2, offset2, length2, position2).then((nwritten)=>{
            callback(null, nwritten, buffer2);
        }, (err)=>callback(err));
        return;
    }
    validateStringAfterArrayBufferView(buffer2, "buffer");
    if (typeof position2 !== "function") {
        if (typeof offset2 === "function") {
            position2 = offset2;
            offset2 = null;
        } else {
            position2 = length2;
        }
        length2 = "utf-8";
    }
    const str = String(buffer2);
    validateEncoding(str, length2);
    callback = maybeCallback(position2);
    buffer2 = Buffer.from(str, length2);
    innerWrite(fd2, buffer2, 0, buffer2.length, offset2, callback).then((nwritten)=>{
        callback(null, nwritten, buffer2);
    }, (err)=>callback(err));
}
function writev(fd1, buffers1, position1, callback) {
    const innerWritev = async (fd, buffers, position)=>{
        const chunks = [];
        for(let i141 = 0; i141 < buffers.length; i141++){
            if (Buffer.isBuffer(buffers[i141])) {
                chunks.push(buffers[i141]);
            } else {
                chunks.push(new Buffer(buffers[i141]));
            }
        }
        if (typeof position === "number") {
            await Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        const buffer36 = Buffer.concat(chunks);
        let currentOffset = 0;
        while(currentOffset < buffer36.byteLength){
            currentOffset += await Deno.writeSync(fd, buffer36.subarray(currentOffset));
        }
        return currentOffset - 0;
    };
    fd1 = getValidatedFd(fd1);
    validateBufferArray(buffers1);
    callback = maybeCallback(callback || position1);
    if (buffers1.length === 0) {
        process.nextTick(callback, null, 0, buffers1);
        return;
    }
    if (typeof position1 !== "number") position1 = null;
    innerWritev(fd1, buffers1, position1).then((nwritten)=>{
        callback(null, nwritten, buffers1);
    }, (err)=>callback(err));
}
function writevSync(fd2, buffers2, position2) {
    const innerWritev = (fd, buffers, position)=>{
        const chunks = [];
        for(let i142 = 0; i142 < buffers.length; i142++){
            if (Buffer.isBuffer(buffers[i142])) {
                chunks.push(buffers[i142]);
            } else {
                chunks.push(new Buffer(buffers[i142]));
            }
        }
        if (typeof position === "number") {
            Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        const buffer37 = Buffer.concat(chunks);
        let currentOffset = 0;
        while(currentOffset < buffer37.byteLength){
            currentOffset += Deno.writeSync(fd, buffer37.subarray(currentOffset));
        }
        return currentOffset - 0;
    };
    fd2 = getValidatedFd(fd2);
    validateBufferArray(buffers2);
    if (buffers2.length === 0) {
        return 0;
    }
    if (typeof position2 !== "number") position2 = null;
    return innerWritev(fd2, buffers2, position2);
}
const kFs = Symbol("kFs");
const kIsPerformingIO = Symbol("kIsPerformingIO");
const kIoDone = Symbol("kIoDone");
class WriteStreamClass extends Writable {
    fd = null;
    path;
    flags;
    mode;
    bytesWritten = 0;
    pos = 0;
    [kFs] = {
        open,
        write
    };
    [kIsPerformingIO] = false;
    constructor(path108, opts = {}){
        super(opts);
        this.path = toPathIfFileURL(path108);
        this.flags = opts.flags || "w";
        this.mode = opts.mode || 0o666;
        this[kFs] = opts.fs ?? {
            open,
            write,
            close
        };
        if (opts.encoding) {
            this.setDefaultEncoding(opts.encoding);
        }
    }
    _construct(callback) {
        this[kFs].open(this.path.toString(), this.flags, this.mode, (err, fd)=>{
            if (err) {
                callback(err);
                return;
            }
            this.fd = fd;
            callback();
            this.emit("open", this.fd);
            this.emit("ready");
        });
    }
    _write(data29, _encoding, cb) {
        this[kIsPerformingIO] = true;
        this[kFs].write(this.fd, data29, 0, data29.length, this.pos, (er, bytes)=>{
            this[kIsPerformingIO] = false;
            if (this.destroyed) {
                cb(er);
                return this.emit(kIoDone, er);
            }
            if (er) {
                return cb(er);
            }
            this.bytesWritten += bytes;
            cb();
        });
        if (this.pos !== undefined) {
            this.pos += data29.length;
        }
    }
    _destroy(err, cb) {
        if (this[kIsPerformingIO]) {
            this.once(kIoDone, (er)=>closeStream(this, err || er, cb));
        } else {
            closeStream(this, err, cb);
        }
    }
}
function closeStream(stream1, err, cb) {
    if (!stream1.fd) {
        cb(err);
    } else {
        stream1[kFs].close(stream1.fd, (er)=>{
            cb(er || err);
        });
        stream1.fd = null;
    }
}
function WriteStream(path109, opts) {
    return new WriteStreamClass(path109, opts);
}
WriteStream.prototype = WriteStreamClass.prototype;
function createWriteStream(path113, opts) {
    return new WriteStreamClass(path113, opts);
}
const { F_OK: F_OK2 , R_OK: R_OK2 , W_OK: W_OK2 , X_OK: X_OK2 ,  } = mod52;
const promises = {
    access: promisify(access),
    copyFile: promisify(copyFile),
    open: promisify(open),
    rename: promisify(rename),
    truncate: promisify(truncate),
    rm: promisify(rm),
    rmdir: promisify(rmdir),
    mkdir: promisify(mkdir),
    readdir: promisify(readdir),
    readlink: promisify(readlink),
    symlink: promisify(symlink),
    lstat: promisify(lstat),
    stat: promisify(stat),
    link: promisify(link),
    unlink: promisify(unlink),
    chmod: promisify(chmod),
    chown: promisify(chown),
    utimes: promisify(utimes),
    realpath: promisify(realpath),
    mkdtemp: promisify(mkdtemp),
    writeFile: promisify(writeFile),
    appendFile: promisify(appendFile),
    readFile: promisify(readFile),
    watch: promisify(watch)
};
const __default10 = {
    access,
    accessSync,
    appendFile,
    appendFileSync,
    chmod,
    chmodSync,
    chown,
    chownSync,
    close,
    closeSync,
    constants: mod52,
    copyFile,
    copyFileSync,
    createReadStream,
    createWriteStream,
    Dir,
    Dirent: Dirent1,
    exists,
    existsSync,
    F_OK: F_OK2,
    fdatasync,
    fdatasyncSync,
    fstat,
    fstatSync,
    fsync,
    fsyncSync,
    ftruncate,
    ftruncateSync,
    futimes,
    futimesSync,
    link,
    linkSync,
    lstat,
    lstatSync,
    mkdir,
    mkdirSync,
    mkdtemp,
    mkdtempSync,
    open,
    openSync,
    read,
    readSync,
    promises,
    R_OK: R_OK2,
    readdir,
    readdirSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    realpath,
    realpathSync,
    rename,
    renameSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    stat,
    Stats,
    statSync,
    symlink,
    symlinkSync,
    truncate,
    truncateSync,
    unlink,
    unlinkSync,
    utimes,
    utimesSync,
    W_OK: W_OK2,
    watch,
    watchFile: watch,
    write,
    writeFile,
    writev,
    writevSync,
    writeFileSync,
    WriteStream,
    writeSync,
    X_OK: X_OK2
};
const originCache = new Map(), originStackCache = new Map(), originError = Symbol('OriginError');
const CLOSE = {};
class Query extends Promise {
    constructor(strings, args, handler, canceller, options = {}){
        let resolve18, reject;
        super((a, b24)=>{
            resolve18 = a;
            reject = b24;
        });
        this.tagged = Array.isArray(strings.raw);
        this.strings = strings;
        this.args = args;
        this.handler = handler;
        this.canceller = canceller;
        this.options = options;
        this.state = null;
        this.statement = null;
        this.resolve = (x)=>(this.active = false, resolve18(x));
        this.reject = (x)=>(this.active = false, reject(x));
        this.active = false;
        this.cancelled = null;
        this.executed = false;
        this.signature = '';
        this[originError] = this.handler.debug ? new Error() : this.tagged && cachedError(this.strings);
    }
    get origin() {
        return this.handler.debug ? this[originError].stack : this.tagged ? originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings) : '';
    }
    static get [Symbol.species]() {
        return Promise;
    }
    cancel() {
        return this.canceller && (this.canceller(this), this.canceller = null);
    }
    async readable() {
        this.options.simple = true;
        this.options.prepare = false;
        this.streaming = true;
        return this;
    }
    async writable() {
        this.options.simple = true;
        this.options.prepare = false;
        this.streaming = true;
        return this;
    }
    cursor(rows = 1, fn) {
        this.options.simple = false;
        if (typeof rows === 'function') {
            fn = rows;
            rows = 1;
        }
        this.cursorRows = rows;
        if (typeof fn === 'function') return this.cursorFn = fn, this;
        let prev;
        return {
            [Symbol.asyncIterator]: ()=>({
                    next: ()=>{
                        if (this.executed && !this.active) return {
                            done: true
                        };
                        prev && prev();
                        const promise = new Promise((resolve19, reject)=>{
                            this.cursorFn = (value)=>{
                                resolve19({
                                    value,
                                    done: false
                                });
                                return new Promise((r)=>prev = r);
                            };
                            this.resolve = ()=>(this.active = false, resolve19({
                                    done: true
                                }));
                            this.reject = (x)=>(this.active = false, reject(x));
                        });
                        this.execute();
                        return promise;
                    },
                    return () {
                        prev && prev(CLOSE);
                        return {
                            done: true
                        };
                    }
                })
        };
    }
    describe() {
        this.onlyDescribe = true;
        return this;
    }
    stream() {
        throw new Error('.stream has been renamed to .forEach');
    }
    forEach(fn) {
        this.forEachFn = fn;
        this.handle();
        return this;
    }
    raw() {
        this.isRaw = true;
        return this;
    }
    values() {
        this.isRaw = 'values';
        return this;
    }
    async handle() {
        !this.executed && (this.executed = true) && await 1 && this.handler(this);
    }
    execute() {
        this.handle();
        return this;
    }
    then() {
        this.handle();
        return super.then.apply(this, arguments);
    }
    catch() {
        this.handle();
        return super.catch.apply(this, arguments);
    }
    finally() {
        this.handle();
        return super.finally.apply(this, arguments);
    }
}
function cachedError(xs) {
    if (originCache.has(xs)) return originCache.get(xs);
    const x = Error.stackTraceLimit;
    Error.stackTraceLimit = 4;
    originCache.set(xs, new Error());
    Error.stackTraceLimit = x;
    return originCache.get(xs);
}
class PostgresError extends Error {
    constructor(x){
        super(x.message);
        this.name = this.constructor.name;
        Object.assign(this, x);
    }
}
const Errors = {
    connection,
    postgres,
    generic,
    notSupported
};
function connection(x, options, socket) {
    const { host , port: port3  } = socket || options;
    const error16 = Object.assign(new Error('write ' + x + ' ' + (options.path || host + ':' + port3)), {
        code: x,
        errno: x,
        address: options.path || host
    }, options.path ? {} : {
        port: port3
    });
    Error.captureStackTrace(error16, connection);
    return error16;
}
function postgres(x) {
    const error17 = new PostgresError(x);
    Error.captureStackTrace(error17, postgres);
    return error17;
}
function generic(code58, message) {
    const error18 = Object.assign(new Error(code58 + ': ' + message), {
        code: code58
    });
    Error.captureStackTrace(error18, generic);
    return error18;
}
function notSupported(x) {
    const error19 = Object.assign(new Error(x + ' (B) is not supported'), {
        code: 'MESSAGE_NOT_SUPPORTED',
        name: x
    });
    Error.captureStackTrace(error19, notSupported);
    return error19;
}
const types = {
    string: {
        to: 25,
        from: null,
        serialize: (x)=>'' + x
    },
    number: {
        to: 0,
        from: [
            21,
            23,
            26,
            700,
            701
        ],
        serialize: (x)=>'' + x,
        parse: (x)=>+x
    },
    json: {
        to: 114,
        from: [
            114,
            3802
        ],
        serialize: (x)=>JSON.stringify(x),
        parse: (x)=>JSON.parse(x)
    },
    boolean: {
        to: 16,
        from: 16,
        serialize: (x)=>x === true ? 't' : 'f',
        parse: (x)=>x === 't'
    },
    date: {
        to: 1184,
        from: [
            1082,
            1114,
            1184
        ],
        serialize: (x)=>(x instanceof Date ? x : new Date(x)).toISOString(),
        parse: (x)=>new Date(x)
    },
    bytea: {
        to: 17,
        from: 17,
        serialize: (x)=>'\\x' + Buffer.from(x).toString('hex'),
        parse: (x)=>Buffer.from(x.slice(2), 'hex')
    }
};
class NotTagged {
    then() {
        notTagged();
    }
    catch() {
        notTagged();
    }
    finally() {
        notTagged();
    }
}
class Identifier extends NotTagged {
    constructor(value){
        super();
        this.value = escapeIdentifier(value);
    }
}
class Parameter extends NotTagged {
    constructor(value, type51, array){
        super();
        this.value = value;
        this.type = type51;
        this.array = array;
    }
}
class Builder extends NotTagged {
    constructor(first, rest){
        super();
        this.first = first;
        this.rest = rest;
    }
    build(before, parameters, types1, options) {
        const keyword = builders.map(([x, fn])=>({
                fn,
                i: before.search(x)
            })).sort((a, b25)=>a.i - b25.i).pop();
        if (keyword.i === -1) throw new Error('Could not infer helper mode');
        return keyword.fn(this.first, this.rest, parameters, types1, options);
    }
}
function handleValue(x, parameters, types2, options) {
    let value = x instanceof Parameter ? x.value : x;
    if (value === undefined) {
        x instanceof Parameter ? x.value = options.transform.undefined : value = x = options.transform.undefined;
        if (value === undefined) throw Errors.generic('UNDEFINED_VALUE', 'Undefined values are not allowed');
    }
    return '$' + types2.push(x instanceof Parameter ? (parameters.push(x.value), x.array ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value) : x.type) : (parameters.push(x), inferType(x)));
}
const defaultHandlers = typeHandlers(types);
function stringify1(q, string, value, parameters, types3, options) {
    for(let i143 = 1; i143 < q.strings.length; i143++){
        string += stringifyValue(string, value, parameters, types3, options) + q.strings[i143];
        value = q.args[i143];
    }
    return string;
}
function stringifyValue(string, value, parameters, types4, o) {
    return value instanceof Builder ? value.build(string, parameters, types4, o) : value instanceof Query ? fragment(value, parameters, types4, o) : value instanceof Identifier ? value.value : value && value[0] instanceof Query ? value.reduce((acc, x)=>acc + ' ' + fragment(x, parameters, types4, o), '') : handleValue(value, parameters, types4, o);
}
function fragment(q, parameters, types5, options) {
    q.fragment = true;
    return stringify1(q, q.strings[0], q.args[0], parameters, types5, options);
}
function valuesBuilder(first, parameters, types6, columns, options) {
    return first.map((row)=>'(' + columns.map((column)=>stringifyValue('values', row[column], parameters, types6, options)).join(',') + ')').join(',');
}
function values(first, rest, parameters, types7, options) {
    const multi = Array.isArray(first[0]);
    const columns = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first);
    return valuesBuilder(multi ? first : [
        first
    ], parameters, types7, columns, options);
}
function select(first, rest, parameters, types8, options) {
    typeof first === 'string' && (first = [
        first
    ].concat(rest));
    if (Array.isArray(first)) return first.map((x)=>escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x)).join(',');
    let value;
    const columns = rest.length ? rest.flat() : Object.keys(first);
    return columns.map((x)=>{
        value = first[x];
        return (value instanceof Query ? fragment(value, parameters, types8, options) : value instanceof Identifier ? value.value : handleValue(value, parameters, types8, options)) + ' as ' + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x);
    }).join(',');
}
const builders = Object.entries({
    values,
    in: values,
    select,
    as: select,
    returning: select,
    update (first, rest, parameters, types9, options) {
        return (rest.length ? rest.flat() : Object.keys(first)).map((x)=>escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x) + '=' + handleValue(first[x], parameters, types9, options));
    },
    insert (first, rest, parameters, types10, options) {
        const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
        return '(' + columns.map((x)=>escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x)).join(',') + ')values' + valuesBuilder(Array.isArray(first) ? first : [
            first
        ], parameters, types10, columns, options);
    }
}).map(([x, fn])=>[
        new RegExp('((?:^|[\\s(])' + x + '(?:$|[\\s(]))(?![\\s\\S]*\\1)', 'i'),
        fn
    ]);
function notTagged() {
    throw Errors.generic('NOT_TAGGED_CALL', 'Query not called as a tagged template literal');
}
const serializers = defaultHandlers.serializers;
const parsers = defaultHandlers.parsers;
function firstIsString(x) {
    if (Array.isArray(x)) return firstIsString(x[0]);
    return typeof x === 'string' ? 1009 : 0;
}
const mergeUserTypes = function(types11) {
    const user = typeHandlers(types11 || {});
    return {
        serializers: Object.assign({}, serializers, user.serializers),
        parsers: Object.assign({}, parsers, user.parsers)
    };
};
function typeHandlers(types12) {
    return Object.keys(types12).reduce((acc, k27)=>{
        types12[k27].from && [].concat(types12[k27].from).forEach((x)=>acc.parsers[x] = types12[k27].parse);
        acc.serializers[types12[k27].to] = types12[k27].serialize;
        types12[k27].from && [].concat(types12[k27].from).forEach((x)=>acc.serializers[x] = types12[k27].serialize);
        return acc;
    }, {
        parsers: {},
        serializers: {}
    });
}
const escapeIdentifier = function escape(str) {
    return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
};
const inferType = function inferType1(x) {
    return x instanceof Parameter ? x.type : x instanceof Date ? 1184 : x instanceof Uint8Array ? 17 : x === true || x === false ? 16 : typeof x === 'bigint' ? 20 : Array.isArray(x) ? inferType1(x[0]) : 0;
};
const escapeBackslash = /\\/g;
const escapeQuote = /"/g;
function arrayEscape(x) {
    return x.replace(escapeBackslash, '\\\\').replace(escapeQuote, '\\"');
}
const arraySerializer = function arraySerializer1(xs, serializer, options) {
    if (Array.isArray(xs) === false) return xs;
    if (!xs.length) return '{}';
    const first = xs[0];
    if (Array.isArray(first) && !first.type) return '{' + xs.map((x)=>arraySerializer1(x, serializer)).join(',') + '}';
    return '{' + xs.map((x)=>{
        if (x === undefined) {
            x = options.transform.undefined;
            if (x === undefined) throw Errors.generic('UNDEFINED_VALUE', 'Undefined values are not allowed');
        }
        return x === null ? 'null' : '"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : '' + x) + '"';
    }).join(',') + '}';
};
const arrayParserState = {
    i: 0,
    char: null,
    str: '',
    quoted: false,
    last: 0
};
const arrayParser = function arrayParser(x, parser) {
    arrayParserState.i = arrayParserState.last = 0;
    return arrayParserLoop(arrayParserState, x, parser);
};
function arrayParserLoop(s, x, parser) {
    const xs = [];
    for(; s.i < x.length; s.i++){
        s.char = x[s.i];
        if (s.quoted) {
            if (s.char === '\\') {
                s.str += x[++s.i];
            } else if (s.char === '"') {
                xs.push(parser ? parser(s.str) : s.str);
                s.str = '';
                s.quoted = x[s.i + 1] === '"';
                s.last = s.i + 2;
            } else {
                s.str += s.char;
            }
        } else if (s.char === '"') {
            s.quoted = true;
        } else if (s.char === '{') {
            s.last = ++s.i;
            xs.push(arrayParserLoop(s, x, parser));
        } else if (s.char === '}') {
            s.quoted = false;
            s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i));
            s.last = s.i + 1;
            break;
        } else if (s.char === ',' && s.p !== '}' && s.p !== '"') {
            xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i));
            s.last = s.i + 1;
        }
        s.p = s.char;
    }
    s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i + 1)) : x.slice(s.last, s.i + 1));
    return xs;
}
const toCamel = (x)=>{
    let str = x[0];
    for(let i144 = 1; i144 < x.length; i144++)str += x[i144] === '_' ? x[++i144].toUpperCase() : x[i144];
    return str;
};
const toPascal = (x)=>{
    let str = x[0].toUpperCase();
    for(let i145 = 1; i145 < x.length; i145++)str += x[i145] === '_' ? x[++i145].toUpperCase() : x[i145];
    return str;
};
const toKebab = (x)=>x.replace(/_/g, '-');
const fromCamel = (x)=>x.replace(/([A-Z])/g, '_$1').toLowerCase();
const fromPascal = (x)=>(x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, '_$1')).toLowerCase();
const fromKebab = (x)=>x.replace(/-/g, '_');
const HEX_CHARS = "0123456789abcdef".split("");
const EXTRA = [
    -2147483648,
    8388608,
    32768,
    128
];
const SHIFT = [
    24,
    16,
    8,
    0
];
const K = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2, 
];
const blocks = [];
class Sha256 {
    #block;
    #blocks;
    #bytes;
    #finalized;
    #first;
    #h0;
    #h1;
    #h2;
    #h3;
    #h4;
    #h5;
    #h6;
    #h7;
    #hashed;
    #hBytes;
    #is224;
    #lastByteIndex = 0;
    #start;
    constructor(is224 = false, sharedMemory = false){
        this.init(is224, sharedMemory);
    }
    init(is224, sharedMemory) {
        if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.#blocks = blocks;
        } else {
            this.#blocks = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
        }
        if (is224) {
            this.#h0 = 0xc1059ed8;
            this.#h1 = 0x367cd507;
            this.#h2 = 0x3070dd17;
            this.#h3 = 0xf70e5939;
            this.#h4 = 0xffc00b31;
            this.#h5 = 0x68581511;
            this.#h6 = 0x64f98fa7;
            this.#h7 = 0xbefa4fa4;
        } else {
            this.#h0 = 0x6a09e667;
            this.#h1 = 0xbb67ae85;
            this.#h2 = 0x3c6ef372;
            this.#h3 = 0xa54ff53a;
            this.#h4 = 0x510e527f;
            this.#h5 = 0x9b05688c;
            this.#h6 = 0x1f83d9ab;
            this.#h7 = 0x5be0cd19;
        }
        this.#block = this.#start = this.#bytes = this.#hBytes = 0;
        this.#finalized = this.#hashed = false;
        this.#first = true;
        this.#is224 = is224;
    }
    update(message) {
        if (this.#finalized) {
            return this;
        }
        let msg;
        if (message instanceof ArrayBuffer) {
            msg = new Uint8Array(message);
        } else {
            msg = message;
        }
        let index = 0;
        const length = msg.length;
        const blocks1 = this.#blocks;
        while(index < length){
            let i146;
            if (this.#hashed) {
                this.#hashed = false;
                blocks1[0] = this.#block;
                blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0;
            }
            if (typeof msg !== "string") {
                for(i146 = this.#start; index < length && i146 < 64; ++index){
                    blocks1[i146 >> 2] |= msg[index] << SHIFT[(i146++) & 3];
                }
            } else {
                for(i146 = this.#start; index < length && i146 < 64; ++index){
                    let code59 = msg.charCodeAt(index);
                    if (code59 < 0x80) {
                        blocks1[i146 >> 2] |= code59 << SHIFT[(i146++) & 3];
                    } else if (code59 < 0x800) {
                        blocks1[i146 >> 2] |= (0xc0 | code59 >> 6) << SHIFT[(i146++) & 3];
                        blocks1[i146 >> 2] |= (0x80 | code59 & 0x3f) << SHIFT[(i146++) & 3];
                    } else if (code59 < 0xd800 || code59 >= 0xe000) {
                        blocks1[i146 >> 2] |= (0xe0 | code59 >> 12) << SHIFT[(i146++) & 3];
                        blocks1[i146 >> 2] |= (0x80 | code59 >> 6 & 0x3f) << SHIFT[(i146++) & 3];
                        blocks1[i146 >> 2] |= (0x80 | code59 & 0x3f) << SHIFT[(i146++) & 3];
                    } else {
                        code59 = 0x10000 + ((code59 & 0x3ff) << 10 | msg.charCodeAt(++index) & 0x3ff);
                        blocks1[i146 >> 2] |= (0xf0 | code59 >> 18) << SHIFT[(i146++) & 3];
                        blocks1[i146 >> 2] |= (0x80 | code59 >> 12 & 0x3f) << SHIFT[(i146++) & 3];
                        blocks1[i146 >> 2] |= (0x80 | code59 >> 6 & 0x3f) << SHIFT[(i146++) & 3];
                        blocks1[i146 >> 2] |= (0x80 | code59 & 0x3f) << SHIFT[(i146++) & 3];
                    }
                }
            }
            this.#lastByteIndex = i146;
            this.#bytes += i146 - this.#start;
            if (i146 >= 64) {
                this.#block = blocks1[16];
                this.#start = i146 - 64;
                this.hash();
                this.#hashed = true;
            } else {
                this.#start = i146;
            }
        }
        if (this.#bytes > 4294967295) {
            this.#hBytes += this.#bytes / 4294967296 << 0;
            this.#bytes = this.#bytes % 4294967296;
        }
        return this;
    }
    finalize() {
        if (this.#finalized) {
            return;
        }
        this.#finalized = true;
        const blocks2 = this.#blocks;
        const i147 = this.#lastByteIndex;
        blocks2[16] = this.#block;
        blocks2[i147 >> 2] |= EXTRA[i147 & 3];
        this.#block = blocks2[16];
        if (i147 >= 56) {
            if (!this.#hashed) {
                this.hash();
            }
            blocks2[0] = this.#block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.#hBytes << 3 | this.#bytes >>> 29;
        blocks2[15] = this.#bytes << 3;
        this.hash();
    }
    hash() {
        let a = this.#h0;
        let b26 = this.#h1;
        let c = this.#h2;
        let d = this.#h3;
        let e = this.#h4;
        let f = this.#h5;
        let g = this.#h6;
        let h = this.#h7;
        const blocks3 = this.#blocks;
        let s0;
        let s1;
        let maj;
        let t1;
        let t2;
        let ch;
        let ab;
        let da;
        let cd;
        let bc;
        for(let j = 16; j < 64; ++j){
            t1 = blocks3[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks3[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks3[j] = blocks3[j - 16] + s0 + blocks3[j - 7] + s1 << 0;
        }
        bc = b26 & c;
        for(let j1 = 0; j1 < 64; j1 += 4){
            if (this.#first) {
                if (this.#is224) {
                    ab = 300032;
                    t1 = blocks3[0] - 1413257819;
                    h = t1 - 150054599 << 0;
                    d = t1 + 24177077 << 0;
                } else {
                    ab = 704751109;
                    t1 = blocks3[0] - 210244248;
                    h = t1 - 1521486534 << 0;
                    d = t1 + 143694565 << 0;
                }
                this.#first = false;
            } else {
                s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
                s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
                ab = a & b26;
                maj = ab ^ a & c ^ bc;
                ch = e & f ^ ~e & g;
                t1 = h + s1 + ch + K[j1] + blocks3[j1];
                t2 = s0 + maj;
                h = d + t1 << 0;
                d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b26 ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K[j1 + 1] + blocks3[j1 + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K[j1 + 2] + blocks3[j1 + 2];
            t2 = s0 + maj;
            f = b26 + t1 << 0;
            b26 = t1 + t2 << 0;
            s0 = (b26 >>> 2 | b26 << 30) ^ (b26 >>> 13 | b26 << 19) ^ (b26 >>> 22 | b26 << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b26 & c;
            maj = bc ^ b26 & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K[j1 + 3] + blocks3[j1 + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
        }
        this.#h0 = this.#h0 + a << 0;
        this.#h1 = this.#h1 + b26 << 0;
        this.#h2 = this.#h2 + c << 0;
        this.#h3 = this.#h3 + d << 0;
        this.#h4 = this.#h4 + e << 0;
        this.#h5 = this.#h5 + f << 0;
        this.#h6 = this.#h6 + g << 0;
        this.#h7 = this.#h7 + h << 0;
    }
    hex() {
        this.finalize();
        const h0 = this.#h0;
        const h1 = this.#h1;
        const h2 = this.#h2;
        const h3 = this.#h3;
        const h4 = this.#h4;
        const h5 = this.#h5;
        const h6 = this.#h6;
        const h7 = this.#h7;
        let hex = HEX_CHARS[h0 >> 28 & 0x0f] + HEX_CHARS[h0 >> 24 & 0x0f] + HEX_CHARS[h0 >> 20 & 0x0f] + HEX_CHARS[h0 >> 16 & 0x0f] + HEX_CHARS[h0 >> 12 & 0x0f] + HEX_CHARS[h0 >> 8 & 0x0f] + HEX_CHARS[h0 >> 4 & 0x0f] + HEX_CHARS[h0 & 0x0f] + HEX_CHARS[h1 >> 28 & 0x0f] + HEX_CHARS[h1 >> 24 & 0x0f] + HEX_CHARS[h1 >> 20 & 0x0f] + HEX_CHARS[h1 >> 16 & 0x0f] + HEX_CHARS[h1 >> 12 & 0x0f] + HEX_CHARS[h1 >> 8 & 0x0f] + HEX_CHARS[h1 >> 4 & 0x0f] + HEX_CHARS[h1 & 0x0f] + HEX_CHARS[h2 >> 28 & 0x0f] + HEX_CHARS[h2 >> 24 & 0x0f] + HEX_CHARS[h2 >> 20 & 0x0f] + HEX_CHARS[h2 >> 16 & 0x0f] + HEX_CHARS[h2 >> 12 & 0x0f] + HEX_CHARS[h2 >> 8 & 0x0f] + HEX_CHARS[h2 >> 4 & 0x0f] + HEX_CHARS[h2 & 0x0f] + HEX_CHARS[h3 >> 28 & 0x0f] + HEX_CHARS[h3 >> 24 & 0x0f] + HEX_CHARS[h3 >> 20 & 0x0f] + HEX_CHARS[h3 >> 16 & 0x0f] + HEX_CHARS[h3 >> 12 & 0x0f] + HEX_CHARS[h3 >> 8 & 0x0f] + HEX_CHARS[h3 >> 4 & 0x0f] + HEX_CHARS[h3 & 0x0f] + HEX_CHARS[h4 >> 28 & 0x0f] + HEX_CHARS[h4 >> 24 & 0x0f] + HEX_CHARS[h4 >> 20 & 0x0f] + HEX_CHARS[h4 >> 16 & 0x0f] + HEX_CHARS[h4 >> 12 & 0x0f] + HEX_CHARS[h4 >> 8 & 0x0f] + HEX_CHARS[h4 >> 4 & 0x0f] + HEX_CHARS[h4 & 0x0f] + HEX_CHARS[h5 >> 28 & 0x0f] + HEX_CHARS[h5 >> 24 & 0x0f] + HEX_CHARS[h5 >> 20 & 0x0f] + HEX_CHARS[h5 >> 16 & 0x0f] + HEX_CHARS[h5 >> 12 & 0x0f] + HEX_CHARS[h5 >> 8 & 0x0f] + HEX_CHARS[h5 >> 4 & 0x0f] + HEX_CHARS[h5 & 0x0f] + HEX_CHARS[h6 >> 28 & 0x0f] + HEX_CHARS[h6 >> 24 & 0x0f] + HEX_CHARS[h6 >> 20 & 0x0f] + HEX_CHARS[h6 >> 16 & 0x0f] + HEX_CHARS[h6 >> 12 & 0x0f] + HEX_CHARS[h6 >> 8 & 0x0f] + HEX_CHARS[h6 >> 4 & 0x0f] + HEX_CHARS[h6 & 0x0f];
        if (!this.#is224) {
            hex += HEX_CHARS[h7 >> 28 & 0x0f] + HEX_CHARS[h7 >> 24 & 0x0f] + HEX_CHARS[h7 >> 20 & 0x0f] + HEX_CHARS[h7 >> 16 & 0x0f] + HEX_CHARS[h7 >> 12 & 0x0f] + HEX_CHARS[h7 >> 8 & 0x0f] + HEX_CHARS[h7 >> 4 & 0x0f] + HEX_CHARS[h7 & 0x0f];
        }
        return hex;
    }
    toString() {
        return this.hex();
    }
    digest() {
        this.finalize();
        const h0 = this.#h0;
        const h1 = this.#h1;
        const h2 = this.#h2;
        const h3 = this.#h3;
        const h4 = this.#h4;
        const h5 = this.#h5;
        const h6 = this.#h6;
        const h7 = this.#h7;
        const arr = [
            h0 >> 24 & 0xff,
            h0 >> 16 & 0xff,
            h0 >> 8 & 0xff,
            h0 & 0xff,
            h1 >> 24 & 0xff,
            h1 >> 16 & 0xff,
            h1 >> 8 & 0xff,
            h1 & 0xff,
            h2 >> 24 & 0xff,
            h2 >> 16 & 0xff,
            h2 >> 8 & 0xff,
            h2 & 0xff,
            h3 >> 24 & 0xff,
            h3 >> 16 & 0xff,
            h3 >> 8 & 0xff,
            h3 & 0xff,
            h4 >> 24 & 0xff,
            h4 >> 16 & 0xff,
            h4 >> 8 & 0xff,
            h4 & 0xff,
            h5 >> 24 & 0xff,
            h5 >> 16 & 0xff,
            h5 >> 8 & 0xff,
            h5 & 0xff,
            h6 >> 24 & 0xff,
            h6 >> 16 & 0xff,
            h6 >> 8 & 0xff,
            h6 & 0xff, 
        ];
        if (!this.#is224) {
            arr.push(h7 >> 24 & 0xff, h7 >> 16 & 0xff, h7 >> 8 & 0xff, h7 & 0xff);
        }
        return arr;
    }
    array() {
        return this.digest();
    }
    arrayBuffer() {
        this.finalize();
        const buffer38 = new ArrayBuffer(this.#is224 ? 28 : 32);
        const dataView = new DataView(buffer38);
        dataView.setUint32(0, this.#h0);
        dataView.setUint32(4, this.#h1);
        dataView.setUint32(8, this.#h2);
        dataView.setUint32(12, this.#h3);
        dataView.setUint32(16, this.#h4);
        dataView.setUint32(20, this.#h5);
        dataView.setUint32(24, this.#h6);
        if (!this.#is224) {
            dataView.setUint32(28, this.#h7);
        }
        return buffer38;
    }
}
class HmacSha256 extends Sha256 {
    #inner;
    #is224;
    #oKeyPad;
    #sharedMemory;
    constructor(secretKey, is224 = false, sharedMemory = false){
        super(is224, sharedMemory);
        let key;
        if (typeof secretKey === "string") {
            const bytes = [];
            const length = secretKey.length;
            let index = 0;
            for(let i148 = 0; i148 < length; ++i148){
                let code60 = secretKey.charCodeAt(i148);
                if (code60 < 0x80) {
                    bytes[index++] = code60;
                } else if (code60 < 0x800) {
                    bytes[index++] = 0xc0 | code60 >> 6;
                    bytes[index++] = 0x80 | code60 & 0x3f;
                } else if (code60 < 0xd800 || code60 >= 0xe000) {
                    bytes[index++] = 0xe0 | code60 >> 12;
                    bytes[index++] = 0x80 | code60 >> 6 & 0x3f;
                    bytes[index++] = 0x80 | code60 & 0x3f;
                } else {
                    code60 = 0x10000 + ((code60 & 0x3ff) << 10 | secretKey.charCodeAt(++i148) & 0x3ff);
                    bytes[index++] = 0xf0 | code60 >> 18;
                    bytes[index++] = 0x80 | code60 >> 12 & 0x3f;
                    bytes[index++] = 0x80 | code60 >> 6 & 0x3f;
                    bytes[index++] = 0x80 | code60 & 0x3f;
                }
            }
            key = bytes;
        } else {
            if (secretKey instanceof ArrayBuffer) {
                key = new Uint8Array(secretKey);
            } else {
                key = secretKey;
            }
        }
        if (key.length > 64) {
            key = new Sha256(is224, true).update(key).array();
        }
        const oKeyPad = [];
        const iKeyPad = [];
        for(let i149 = 0; i149 < 64; ++i149){
            const b27 = key[i149] || 0;
            oKeyPad[i149] = 0x5c ^ b27;
            iKeyPad[i149] = 0x36 ^ b27;
        }
        this.update(iKeyPad);
        this.#oKeyPad = oKeyPad;
        this.#inner = true;
        this.#is224 = is224;
        this.#sharedMemory = sharedMemory;
    }
    finalize() {
        super.finalize();
        if (this.#inner) {
            this.#inner = false;
            const innerHash = this.array();
            super.init(this.#is224, this.#sharedMemory);
            this.update(this.#oKeyPad);
            this.update(innerHash);
            super.finalize();
        }
    }
}
const events = ()=>({
        data: [],
        error: [],
        drain: [],
        connect: [],
        secureConnect: [],
        close: []
    });
const net = {
    createServer () {
        const server = {
            address () {
                return {
                    port: 9876
                };
            },
            async listen () {
                server.raw = Deno.listen({
                    port: 9876,
                    transport: 'tcp'
                });
                for await (const conn of server.raw)setTimeout(()=>conn.close(), 500);
            },
            close () {
                server.raw.close();
            }
        };
        return server;
    },
    Socket () {
        let paused, resume2, keepAlive;
        const socket = {
            error: error20,
            success,
            readyState: 'open',
            setKeepAlive: (x)=>{
                keepAlive = x;
                socket.raw && socket.raw.setKeepAlive && socket.raw.setKeepAlive(x);
            },
            connect: (port4, hostname10)=>{
                socket.raw = null;
                socket.readyState = 'connecting';
                typeof port4 === 'string' ? Deno.connect({
                    transport: 'unix',
                    path: socket.path = port4
                }).then(success, error20) : Deno.connect({
                    transport: 'tcp',
                    port: socket.port = port4,
                    hostname: socket.hostname = hostname10 || 'localhost'
                }).then(success, error20);
                return socket;
            },
            pause: ()=>{
                paused = new Promise((r)=>resume2 = r);
            },
            resume: ()=>{
                resume2 && resume2();
                paused = null;
            },
            isPaused: ()=>!!paused,
            removeAllListeners: ()=>socket.events = events(),
            events: events(),
            raw: null,
            on: (x, fn)=>socket.events[x].push(fn),
            once: (x, fn)=>{
                if (x === 'data') socket.break = true;
                const e = socket.events[x];
                e.push(once2);
                once2.once = fn;
                function once2(...args) {
                    fn(...args);
                    e.indexOf(once2) > -1 && e.splice(e.indexOf(once2), 1);
                }
            },
            removeListener: (x1, fn)=>{
                socket.events[x1] = socket.events[x1].filter((x)=>x !== fn && x.once !== fn);
            },
            write: (x, cb)=>{
                socket.raw.write(x).then((l)=>{
                    l < x.length ? socket.write(x.slice(l), cb) : cb && cb(null);
                }).catch((err)=>{
                    cb && cb();
                    call(socket.events.error, err);
                });
                return false;
            },
            destroy: ()=>close4(),
            end: (x)=>{
                x && socket.write(x);
                close4();
            }
        };
        return socket;
        async function success(raw) {
            if (socket.readyState !== 'connecting') return raw.close();
            const encrypted = socket.encrypted;
            socket.raw = raw;
            keepAlive != null && raw.setKeepAlive && raw.setKeepAlive(keepAlive);
            socket.readyState = 'open';
            socket.encrypted ? call(socket.events.secureConnect) : call(socket.events.connect);
            const b28 = new Uint8Array(1024);
            let result;
            try {
                while(result = socket.readyState === 'open' && await raw.read(b28)){
                    call(socket.events.data, Buffer.from(b28.subarray(0, result)));
                    if (!encrypted && socket.break && (socket.break = false, b28[0] === 83)) return socket.break = false;
                    paused && await paused;
                }
            } catch (e) {
                if (e instanceof Deno.errors.BadResource === false) error20(e);
            }
            if (!socket.encrypted || encrypted) closed();
        }
        function close4() {
            try {
                socket.raw && socket.raw.close();
            } catch (e) {
                if (e instanceof Deno.errors.BadResource === false) call(socket.events.error, e);
            }
        }
        function closed() {
            if (socket.readyState === 'closed') return;
            socket.break = socket.encrypted = false;
            socket.readyState = 'closed';
            call(socket.events.close);
        }
        function error20(err) {
            call(socket.events.error, err);
            socket.raw ? close4() : closed();
        }
        function call(xs, x) {
            xs.slice().forEach((fn)=>fn(x));
        }
    }
};
const tls = {
    connect ({ socket , ...options }) {
        socket.encrypted = true;
        socket.readyState = 'connecting';
        Deno.startTls(socket.raw, {
            hostname: socket.hostname,
            ...options
        }).then(socket.success, socket.error);
        socket.raw = null;
        return socket;
    }
};
let ids = 1;
const tasks = new Set();
const setImmediate = (fn)=>{
    const id5 = ids++;
    tasks.add(id5);
    queueMicrotask(()=>{
        if (tasks.has(id5)) {
            fn();
            tasks.delete(id5);
        }
    });
    return id5;
};
const clearImmediate = (id6)=>tasks.delete(id6);
const MAX_RANDOM_VALUES = 65536;
function generateRandomBytes(size24) {
    if (size24 > 4294967295) {
        throw new RangeError(`The value of "size" is out of range. It must be >= 0 && <= ${4294967295}. Received ${size24}`);
    }
    const bytes = Buffer.allocUnsafe(size24);
    if (size24 > 65536) {
        for(let generated = 0; generated < size24; generated += MAX_RANDOM_VALUES){
            crypto.getRandomValues(bytes.slice(generated, generated + 65536));
        }
    } else {
        crypto.getRandomValues(bytes);
    }
    return bytes;
}
function randomBytes(size25, cb) {
    if (typeof cb === "function") {
        let err = null, bytes;
        try {
            bytes = generateRandomBytes(size25);
        } catch (e) {
            if (e instanceof RangeError && e.message.includes('The value of "size" is out of range')) {
                throw e;
            } else if (e instanceof Error) {
                err = e;
            } else {
                err = new Error("[non-error thrown]");
            }
        }
        setTimeout(()=>{
            if (err) {
                cb(err);
            } else {
                cb(null, bytes);
            }
        }, 0);
    } else {
        return generateRandomBytes(size25);
    }
}
function assertOffset(offset, length) {
    if (offset > 4294967295 || offset < 0) {
        throw new TypeError("offset must be a uint32");
    }
    if (offset > 0x7fffffff || offset > length) {
        throw new RangeError("offset out of range");
    }
}
function assertSize1(size26, offset, length) {
    if (size26 > 4294967295 || size26 < 0) {
        throw new TypeError("size must be a uint32");
    }
    if (size26 + offset > length || size26 > 0x7fffffff) {
        throw new RangeError("buffer too small");
    }
}
function randomFill(buf, offset, size27, cb) {
    if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size27 = buf.length;
    } else if (typeof size27 === "function") {
        cb = size27;
        size27 = buf.length - Number(offset);
    }
    assertOffset(offset, buf.length);
    assertSize1(size27, offset, buf.length);
    randomBytes(size27, (err, bytes)=>{
        if (err) return cb(err, buf);
        bytes?.copy(buf, offset);
        cb(null, buf);
    });
}
function randomFillSync(buf, offset = 0, size28) {
    assertOffset(offset, buf.length);
    if (size28 === undefined) size28 = buf.length - offset;
    assertSize1(size28, offset, buf.length);
    const bytes = randomBytes(size28);
    bytes.copy(buf, offset);
    return buf;
}
function randomInt(max, min24, cb) {
    if (typeof max === "number" && typeof min24 === "number") {
        [max, min24] = [
            min24,
            max
        ];
    }
    if (min24 === undefined) min24 = 0;
    else if (typeof min24 === "function") {
        cb = min24;
        min24 = 0;
    }
    if (!Number.isSafeInteger(min24) || typeof max === "number" && !Number.isSafeInteger(max)) {
        throw new Error("max or min is not a Safe Number");
    }
    if (max - min24 > Math.pow(2, 48)) {
        throw new RangeError("max - min should be less than 2^48!");
    }
    if (min24 >= max) {
        throw new Error("Min is bigger than Max!");
    }
    const randomBuffer = new Uint32Array(1);
    crypto.getRandomValues(randomBuffer);
    const randomNumber = randomBuffer[0] / (0xffffffff + 1);
    min24 = Math.ceil(min24);
    max = Math.floor(max);
    const result = Math.floor(randomNumber * (max - min24 + 1)) + min24;
    if (cb) {
        cb(null, result);
        return;
    }
    return result;
}
const data = decode("\
AGFzbQEAAAABo4GAgAAYYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fw\
F/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+\
fwBgB39/f35/f38Bf2ADf39+AGAFf399f38AYAV/f3x/fwBgAn9+AGAEf31/fwBgBH98f38AYAJ+fw\
F/AtKFgIAADRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2E0YjYxYTBmNTQ4MjRj\
ZmQABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAh\
hfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3\
AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDIwNGVjYjI0YTZlNW\
RmOQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfZmFjZjAzOThhMjgxYzg1\
YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbm\
d0aF80YjliOGM0ZTNmNWFkYmZmAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0\
aF8xZWI4ZmM2MDhhMGQ0Y2RiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbW\
Vtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5\
NGRkAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmAA\
MYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwAAcYX193\
YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABRhfX3diaW5kZ2VuX3BsYWNlaG\
9sZGVyX18SX193YmluZGdlbl9yZXRocm93AAID7YCAgABsCQcJBwcRBQcHBQMHBw8DBwUQAgUFAgcF\
AggGBwcUDAgOBwcHBwYHBwgXDQUFCAkIDQkFCQYJBgYFBQUFBQUHBwcHBwAFAggKBwUDAgUODAsMCw\
sSEwkFCAgDBgYCBQAABgMGAAAFBQIEAAUCBIWAgIAAAXABFRUFg4CAgAABABEGiYCAgAABfwFBgIDA\
AAsHtoKAgAAOBm1lbW9yeQIABmRpZ2VzdAA3GF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZQBSEWRpZ2\
VzdGNvbnRleHRfbmV3AEEUZGlnZXN0Y29udGV4dF91cGRhdGUAVhRkaWdlc3Rjb250ZXh0X2RpZ2Vz\
dAA+HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAQBtkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZE\
Ryb3AAOxNkaWdlc3Rjb250ZXh0X3Jlc2V0ACITZGlnZXN0Y29udGV4dF9jbG9uZQAbH19fd2JpbmRn\
ZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAbhFfX3diaW5kZ2VuX21hbGxvYwBXEl9fd2JpbmRnZW5fcm\
VhbGxvYwBkD19fd2JpbmRnZW5fZnJlZQBqCZqAgIAAAQBBAQsUZ2hvd21bPVxdWmViXl9gYXhDRHUK\
g8yIgABsoH4CEn8CfiMAQbAlayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCAA4YAAECAwQcGxoZGBcWFRQTEhEQDw4N\
DAsKAAsgASgCBCEBQdABEBciBUUNBCAEQZASakE4aiABQThqKQMANwMAIARBkBJqQTBqIAFBMGopAw\
A3AwAgBEGQEmpBKGogAUEoaikDADcDACAEQZASakEgaiABQSBqKQMANwMAIARBkBJqQRhqIAFBGGop\
AwA3AwAgBEGQEmpBEGogAUEQaikDADcDACAEQZASakEIaiABQQhqKQMANwMAIAQgASkDADcDkBIgAS\
kDQCEWIARBkBJqQcgAaiABQcgAahBFIAQgFjcD0BIgBSAEQZASakHQARA6GkEAIQZBACEBDB8LIAEo\
AgQhAUHQARAXIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkB\
JqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARB\
kBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZ\
ASakHIAGogAUHIAGoQRSAEIBY3A9ASIAUgBEGQEmpB0AEQOhpBASEBDBsLIAEoAgQhAUHQARAXIgVF\
DQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQShqIAFBKGopAw\
A3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGop\
AwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZASakHIAGogAUHIAG\
oQRSAEIBY3A9ASIAUgBEGQEmpB0AEQOhpBAiEBDBoLIAEoAgQhAUHwABAXIgVFDQQgBEGQEmpBIGog\
AUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBCABKQMINw\
OYEiABKQMAIRYgBEGQEmpBKGogAUEoahA5IAQgFjcDkBIgBSAEQZASakHwABA6GkEDIQEMGQsgASgC\
BCEBQfgOEBciBUUNBCAEQZASakGIAWogAUGIAWopAwA3AwAgBEGQEmpBgAFqIAFBgAFqKQMANwMAIA\
RBkBJqQfgAaiABQfgAaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQRhqIAFBGGopAwA3\
AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQThqIAFBOGopAw\
A3AwAgBEGQEmpBwABqIAFBwABqKQMANwMAIARBkBJqQcgAaiABQcgAaikDADcDACAEQZASakHQAGog\
AUHQAGopAwA3AwAgBEGQEmpB2ABqIAFB2ABqKQMANwMAIARBkBJqQeAAaiABQeAAaikDADcDACAEIA\
EpA3A3A4ATIAQgASkDCDcDmBIgBCABKQMoNwO4EiABKQMAIRYgAS0AaiEHIAEtAGkhCCABLQBoIQkC\
QCABKAKQAUEFdCIKDQBBACEKDBsLIARBGGoiCyABQZQBaiIGQRhqKQAANwMAIARBEGoiDCAGQRBqKQ\
AANwMAIARBCGoiDSAGQQhqKQAANwMAIAQgBikAADcDACABQdQBaiEGQQAgCkFgakEFdmshDiAEQcQT\
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\
GkEGIQEMAgtB2AJBCEEAKAL41EAiBEEEIAQbEQUAAAsgASgCBCEBQeACEBciBUUNASAEQZASaiABQc\
gBEDoaIARBkBJqQcgBaiABQcgBahBKIAUgBEGQEmpB4AIQOhpBBSEBC0EAIQYMAgtB4AJBCEEAKAL4\
1EAiBEEEIAQbEQUAAAsgBCAKNgKgEyAEIAc6APoSIAQgCDoA+RIgBCAJOgD4EiAEIBY3A5ASIAUgBE\
GQEmpB+A4QOhpBBCEBQQEhBgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDgIBABELQSAhAi\
ABDhgBDwIPEAMPBAUGBgcHCA8JCgsPDA0QEA4BCyABQQJ0QZTUwABqKAIAIQMMDwtBwAAhAgwNC0Ew\
IQIMDAtBHCECDAsLQTAhAgwKC0HAACECDAkLQRAhAgwIC0EUIQIMBwtBHCECDAYLQTAhAgwFC0HAAC\
ECDAQLQRwhAgwDC0EwIQIMAgtBwAAhAgwBC0EYIQILIAIgA0YNACAAQa2BwAA2AgQgAEEBNgIAIABB\
CGpBOTYCAAJAIAZFDQAgBSgCkAFFDQAgBUEANgKQAQsgBRAfDAELAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4YAAECAwQFBgcICQoLDA0ODxAR\
EhMUFRYaAAsgBCAFQdABEDoiAUH4DmpBDGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQRxqQgA3Ag\
AgAUH4DmpBJGpCADcCACABQfgOakEsakIANwIAIAFB+A5qQTRqQgA3AgAgAUH4DmpBPGpCADcCACAB\
QgA3AvwOIAFBwAA2AvgOIAFBkBJqIAFB+A5qQcQAEDoaIAFBuCJqQThqIgogAUGQEmpBPGopAgA3Aw\
AgAUG4ImpBMGoiAyABQZASakE0aikCADcDACABQbgiakEoaiIPIAFBkBJqQSxqKQIANwMAIAFBuCJq\
QSBqIgsgAUGQEmpBJGopAgA3AwAgAUG4ImpBGGoiDCABQZASakEcaikCADcDACABQbgiakEQaiINIA\
FBkBJqQRRqKQIANwMAIAFBuCJqQQhqIhAgAUGQEmpBDGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmog\
AUHQARA6GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohAgJAIAZBgAFGDQAgAiAGakEAQY\
ABIAZrEDwaCyABQQA6ANgTIAFBkBJqIAJCfxASIAFB+A5qQQhqIgYgAUGQEmpBCGopAwA3AwAgAUH4\
DmpBEGoiAiABQZASakEQaikDADcDACABQfgOakEYaiIOIAFBkBJqQRhqKQMANwMAIAFB+A5qQSBqIg\
cgASkDsBI3AwAgAUH4DmpBKGoiCCABQZASakEoaikDADcDACABQfgOakEwaiIJIAFBkBJqQTBqKQMA\
NwMAIAFB+A5qQThqIhEgAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gECAGKQMANwMAIA0gAikDAD\
cDACAMIA4pAwA3AwAgCyAHKQMANwMAIA8gCCkDADcDACADIAkpAwA3AwAgCiARKQMANwMAIAEgASkD\
+A43A7giQcAAEBciBkUNHCAGIAEpA7giNwAAIAZBOGogAUG4ImpBOGopAwA3AAAgBkEwaiABQbgiak\
EwaikDADcAACAGQShqIAFBuCJqQShqKQMANwAAIAZBIGogAUG4ImpBIGopAwA3AAAgBkEYaiABQbgi\
akEYaikDADcAACAGQRBqIAFBuCJqQRBqKQMANwAAIAZBCGogAUG4ImpBCGopAwA3AABBwAAhAwwaCy\
AEIAVB0AEQOiIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBDGpCADcCACABQgA3AvwO\
IAFBIDYC+A4gAUGQEmpBGGoiCyABQfgOakEYaiICKQMANwMAIAFBkBJqQRBqIgwgAUH4DmpBEGoiCi\
kDADcDACABQZASakEIaiINIAFB+A5qQQhqIgMpAwA3AwAgAUGQEmpBIGogAUH4DmpBIGoiECgCADYC\
ACABIAEpA/gONwOQEiABQbgiakEQaiIOIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhqIgcgAUGQEmpBDG\
opAgA3AwAgAUG4ImpBGGoiCCABQZASakEcaikCADcDACABIAEpApQSNwO4IiABQZASaiABQdABEDoa\
IAEgASkD0BIgAUHYE2otAAAiBq18NwPQEiABQdgSaiEPAkAgBkGAAUYNACAPIAZqQQBBgAEgBmsQPB\
oLIAFBADoA2BMgAUGQEmogD0J/EBIgAyANKQMANwMAIAogDCkDADcDACACIAspAwA3AwAgECABKQOw\
EjcDACABQfgOakEoaiABQZASakEoaikDADcDACABQfgOakEwaiABQZASakEwaikDADcDACABQfgOak\
E4aiABQZASakE4aikDADcDACABIAEpA5ASNwP4DiAHIAMpAwA3AwAgDiAKKQMANwMAIAggAikDADcD\
ACABIAEpA/gONwO4IkEgEBciBkUNHCAGIAEpA7giNwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQai\
ABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQSAhAwwZCyAEIAVB0AEQOiIBQfgOakEs\
akIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBHGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQQxqQg\
A3AgAgAUIANwL8DiABQTA2AvgOIAFBkBJqQShqIg0gAUH4DmpBKGoiAikDADcDACABQZASakEgaiAB\
QfgOakEgaiIKKQMANwMAIAFBkBJqQRhqIhAgAUH4DmpBGGoiAykDADcDACABQZASakEQaiIOIAFB+A\
5qQRBqIg8pAwA3AwAgAUGQEmpBCGoiByABQfgOakEIaiILKQMANwMAIAFBkBJqQTBqIgggAUH4DmpB\
MGoiCSgCADYCACABIAEpA/gONwOQEiABQbgiakEgaiIRIAFBkBJqQSRqKQIANwMAIAFBuCJqQRhqIh\
IgAUGQEmpBHGopAgA3AwAgAUG4ImpBEGoiEyABQZASakEUaikCADcDACABQbgiakEIaiIUIAFBkBJq\
QQxqKQIANwMAIAFBuCJqQShqIhUgAUGQEmpBLGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmogAUHQAR\
A6GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohDAJAIAZBgAFGDQAgDCAGakEAQYABIAZr\
EDwaCyABQQA6ANgTIAFBkBJqIAxCfxASIAsgBykDADcDACAPIA4pAwA3AwAgAyAQKQMANwMAIAogAS\
kDsBI3AwAgAiANKQMANwMAIAkgCCkDADcDACABQfgOakE4aiABQZASakE4aikDADcDACABIAEpA5AS\
NwP4DiAUIAspAwA3AwAgEyAPKQMANwMAIBIgAykDADcDACARIAopAwA3AwAgFSACKQMANwMAIAEgAS\
kD+A43A7giQTAQFyIGRQ0cIAYgASkDuCI3AAAgBkEoaiABQbgiakEoaikDADcAACAGQSBqIAFBuCJq\
QSBqKQMANwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuC\
JqQQhqKQMANwAAQTAhAwwYCyAEIAVB8AAQOiIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4\
DmpBDGpCADcCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCiABQfgOakEYaikDADcDACABQZASak\
EQaiIDIAFB+A5qQRBqKQMANwMAIAFBkBJqQQhqIAFB+A5qQQhqIg8pAwA3AwAgAUGQEmpBIGoiCyAB\
QfgOakEgaigCADYCACABIAEpA/gONwOQEiABQegjakEQaiIMIAFBkBJqQRRqKQIANwMAIAFB6CNqQQ\
hqIg0gAUGQEmpBDGopAgA3AwAgAUHoI2pBGGoiECABQZASakEcaikCADcDACABIAEpApQSNwPoIyAB\
QZASaiABQfAAEDoaIAEgASkDkBIgAUH4EmotAAAiBq18NwOQEiABQbgSaiECAkAgBkHAAEYNACACIA\
ZqQQBBwAAgBmsQPBoLIAFBADoA+BIgAUGQEmogAkF/EBQgDyADKQMAIhY3AwAgDSAWNwMAIAwgCikD\
ADcDACAQIAspAwA3AwAgASABKQOYEiIWNwP4DiABIBY3A+gjQSAQFyIGRQ0cIAYgASkD6CM3AAAgBk\
EYaiABQegjakEYaikDADcAACAGQRBqIAFB6CNqQRBqKQMANwAAIAZBCGogAUHoI2pBCGopAwA3AABB\
ICEDDBcLIAQgBUH4DhA6IQEgA0EASA0SAkACQCADDQBBASEGDAELIAMQFyIGRQ0dIAZBfGotAABBA3\
FFDQAgBkEAIAMQPBoLIAFBkBJqIAFB+A4QOhogAUH4DmogAUGQEmoQJCABQfgOaiAGIAMQGQwWCyAE\
IAVB4AIQOiIKQZASaiAKQeACEDoaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQ\
BBkAEgAWsQPBoLQQAhBiAKQQA6AOgUIAJBAToAACAKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmog\
BmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAA\
AgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJq\
ECUgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A\
5qQQhqIg8gCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BHCEDQRwQFyIGRQ0cIAYgCikD+A43AAAg\
BkEYaiABKAIANgAAIAZBEGogAikDADcAACAGQQhqIA8pAwA3AAAMFQsgBCAFQdgCEDoiCkGQEmogCk\
HYAhA6GiAKQZASaiAKQeAUai0AACIBakHIAWohAgJAIAFBiAFGDQAgAkEAQYgBIAFrEDwaC0EAIQYg\
CkEAOgDgFCACQQE6AAAgCkHfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai\
0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACAB\
QQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQYgBRw0ACyAKQZASahAlIApB+A5qQRhqIgEgCk\
GQEmpBGGopAwA3AwAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhq\
KQMANwMAIAogCikDkBI3A/gOQSAhA0EgEBciBkUNHCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQR\
BqIAIpAwA3AAAgBkEIaiAPKQMANwAADBQLIAQgBUG4AhA6IgpBkBJqIApBuAIQOhogCkGQEmogCkHA\
FGotAAAiAWpByAFqIQICQCABQegARg0AIAJBAEHoACABaxA8GgtBACEGIApBADoAwBQgAkEBOgAAIA\
pBvxRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiAC\
LQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAW\
otAABzOgAAIAZBBGoiBkHoAEcNAAsgCkGQEmoQJSAKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB\
+A5qQSBqIgIgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDyAKQZASakEYaikDADcDACAKQfgOakEQai\
ILIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIgwgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCED\
QTAQFyIGRQ0cIAYgCikD+A43AAAgBkEoaiABKQMANwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AA\
AgBkEQaiALKQMANwAAIAZBCGogDCkDADcAAAwTCyAEIAVBmAIQOiIKQZASaiAKQZgCEDoaIApBkBJq\
IApBoBRqLQAAIgFqQcgBaiECAkAgAUHIAEYNACACQQBByAAgAWsQPBoLQQAhBiAKQQA6AKAUIAJBAT\
oAACAKQZ8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFq\
IgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIA\
FBywFqLQAAczoAACAGQQRqIgZByABHDQALIApBkBJqECUgCkH4DmpBOGoiASAKQZASakE4aikDADcD\
ACAKQfgOakEwaiICIApBkBJqQTBqKQMANwMAIApB+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4Dm\
pBIGoiCyAKQZASakEgaikDADcDACAKQfgOakEYaiIMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0g\
CkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiECAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQc\
AAEBciBkUNHCAGIAopA/gONwAAIAZBOGogASkDADcAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAA\
IAZBIGogCykDADcAACAGQRhqIAwpAwA3AAAgBkEQaiANKQMANwAAIAZBCGogECkDADcAAAwSCyAEIA\
VB4AAQOiIBQfgOakEMakIANwIAIAFCADcC/A5BECEDIAFBEDYC+A4gAUGQEmpBEGogAUH4DmpBEGoo\
AgA2AgAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABIA\
EpA/gONwOQEiABIAEpApQSNwPoIyABQZASaiABQeAAEDoaIAFBkBJqIAFBqBJqIAFB6CNqEDBBEBAX\
IgZFDRwgBiABKQPoIzcAACAGQQhqIAIpAwA3AAAMEQsgBCAFQeAAEDoiAUH4DmpBDGpCADcCACABQg\
A3AvwOQRAhAyABQRA2AvgOIAFBkBJqQRBqIAFB+A5qQRBqKAIANgIAIAFBkBJqQQhqIAFB+A5qQQhq\
KQMANwMAIAFB6CNqQQhqIgIgAUGQEmpBDGopAgA3AwAgASABKQP4DjcDkBIgASABKQKUEjcD6CMgAU\
GQEmogAUHgABA6GiABQZASaiABQagSaiABQegjahAvQRAQFyIGRQ0cIAYgASkD6CM3AAAgBkEIaiAC\
KQMANwAADBALQRQhAyAEIAVB6AAQOiIBQfgOakEUakEANgIAIAFB+A5qQQxqQgA3AgAgAUEANgL4Di\
ABQgA3AvwOIAFBFDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCGogAUH4DmpBCGop\
AwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJqQRRqKAIANgIAIA\
EgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQOhogAUGQEmogAUGwEmogAUHoI2oQLkEU\
EBciBkUNHCAGIAEpA+gjNwAAIAZBEGogCigCADYAACAGQQhqIAIpAwA3AAAMDwtBFCEDIAQgBUHoAB\
A6IgFB+A5qQRRqQQA2AgAgAUH4DmpBDGpCADcCACABQQA2AvgOIAFCADcC/A4gAUEUNgL4DiABQZAS\
akEQaiABQfgOakEQaikDADcDACABQZASakEIaiABQfgOakEIaikDADcDACABQegjakEIaiICIAFBkB\
JqQQxqKQIANwMAIAFB6CNqQRBqIgogAUGQEmpBFGooAgA2AgAgASABKQP4DjcDkBIgASABKQKUEjcD\
6CMgAUGQEmogAUHoABA6GiABQZASaiABQbASaiABQegjahApQRQQFyIGRQ0cIAYgASkD6CM3AAAgBk\
EQaiAKKAIANgAAIAZBCGogAikDADcAAAwOCyAEIAVB4AIQOiIKQZASaiAKQeACEDoaIApBkBJqIApB\
6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQBBkAEgAWsQPBoLQQAhBiAKQQA6AOgUIAJBBjoAAC\
AKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIg\
Ai0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFByw\
FqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJqECUgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAK\
QfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIg8gCkGQEmpBCGopAwA3AwAgCiAKKQOQEj\
cD+A5BHCEDQRwQFyIGRQ0cIAYgCikD+A43AAAgBkEYaiABKAIANgAAIAZBEGogAikDADcAACAGQQhq\
IA8pAwA3AAAMDQsgBCAFQdgCEDoiCkGQEmogCkHYAhA6GiAKQZASaiAKQeAUai0AACIBakHIAWohAg\
JAIAFBiAFGDQAgAkEAQYgBIAFrEDwaC0EAIQYgCkEAOgDgFCACQQY6AAAgCkHfFGoiASABLQAAQYAB\
cjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOg\
AAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIG\
QYgBRw0ACyAKQZASahAlIApB+A5qQRhqIgEgCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiAiAKQZASak\
EQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQSAhA0EgEBciBkUN\
HCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADAwLIAQgBU\
G4AhA6IgpBkBJqIApBuAIQOhogCkGQEmogCkHAFGotAAAiAWpByAFqIQICQCABQegARg0AIAJBAEHo\
ACABaxA8GgtBACEGIApBADoAwBQgAkEGOgAAIApBvxRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGai\
IBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACAB\
QcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkHoAEcNAAsgCkGQEmoQJS\
AKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgIgCkGQEmpBIGopAwA3AwAgCkH4DmpB\
GGoiDyAKQZASakEYaikDADcDACAKQfgOakEQaiILIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIgwgCk\
GQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCEDQTAQFyIGRQ0cIAYgCikD+A43AAAgBkEoaiABKQMA\
NwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AAAgBkEQaiALKQMANwAAIAZBCGogDCkDADcAAAwLCy\
AEIAVBmAIQOiIKQZASaiAKQZgCEDoaIApBkBJqIApBoBRqLQAAIgFqQcgBaiECAkAgAUHIAEYNACAC\
QQBByAAgAWsQPBoLQQAhBiAKQQA6AKAUIAJBBjoAACAKQZ8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEm\
ogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAIt\
AAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZByABHDQALIApBkB\
JqECUgCkH4DmpBOGoiASAKQZASakE4aikDADcDACAKQfgOakEwaiICIApBkBJqQTBqKQMANwMAIApB\
+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4DmpBIGoiCyAKQZASakEgaikDADcDACAKQfgOakEYai\
IMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0gCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiECAKQZAS\
akEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQcAAEBciBkUNHCAGIAopA/gONwAAIAZBOGogASkDAD\
cAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAAIAZBIGogCykDADcAACAGQRhqIAwpAwA3AAAgBkEQ\
aiANKQMANwAAIAZBCGogECkDADcAAAwKCyAEIAVB8AAQOiIBQZASaiABQfAAEDoaQRwhAyABQegjak\
EcakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBDGpCADcCACABQgA3AuwjIAFBIDYC6CMgAUH4DmpB\
GGoiAiABQegjakEYaikDADcDACABQfgOakEQaiIKIAFB6CNqQRBqKQMANwMAIAFB+A5qQQhqIg8gAU\
HoI2pBCGopAwA3AwAgAUH4DmpBIGogAUHoI2pBIGooAgA2AgAgASABKQPoIzcD+A4gAUG4ImpBEGoi\
BiABQfgOakEUaikCADcDACABQbgiakEIaiILIAFB+A5qQQxqKQIANwMAIAFBuCJqQRhqIgwgAUH4Dm\
pBHGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUG4EmogAUG4ImoQKCACIAwoAgA2AgAgCiAGKQMA\
NwMAIA8gCykDADcDACABIAEpA7giNwP4DkEcEBciBkUNHCAGIAEpA/gONwAAIAZBGGogAigCADYAAC\
AGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAkLIAQgBUHwABA6IgFBkBJqIAFB8AAQOhogAUHoI2pB\
HGpCADcCACABQegjakEUakIANwIAIAFB6CNqQQxqQgA3AgAgAUIANwLsI0EgIQMgAUEgNgLoIyABQf\
gOakEgaiABQegjakEgaigCADYCACABQfgOakEYaiICIAFB6CNqQRhqKQMANwMAIAFB+A5qQRBqIgog\
AUHoI2pBEGopAwA3AwAgAUH4DmpBCGoiDyABQegjakEIaikDADcDACABIAEpA+gjNwP4DiABQbgiak\
EYaiIGIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgsgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDCAB\
QfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQbgSaiABQbgiahAoIAIgBikDADcDACAKIA\
spAwA3AwAgDyAMKQMANwMAIAEgASkDuCI3A/gOQSAQFyIGRQ0cIAYgASkD+A43AAAgBkEYaiACKQMA\
NwAAIAZBEGogCikDADcAACAGQQhqIA8pAwA3AAAMCAsgBCAFQdgBEDoiAUGQEmogAUHYARA6GiABQe\
gjakEMakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBHGpCADcCACABQegjakEkakIANwIAIAFB6CNq\
QSxqQgA3AgAgAUHoI2pBNGpCADcCACABQegjakE8akIANwIAIAFCADcC7CMgAUHAADYC6CMgAUH4Dm\
ogAUHoI2pBxAAQOhogAUHwImogAUH4DmpBPGopAgA3AwBBMCEDIAFBuCJqQTBqIAFB+A5qQTRqKQIA\
NwMAIAFBuCJqQShqIgYgAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiAiABQfgOakEkaikCADcDACABQb\
giakEYaiIKIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIg8gAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoi\
CyABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAjIAFB+A5qQShqIg\
wgBikDADcDACABQfgOakEgaiINIAIpAwA3AwAgAUH4DmpBGGoiAiAKKQMANwMAIAFB+A5qQRBqIgog\
DykDADcDACABQfgOakEIaiIPIAspAwA3AwAgASABKQO4IjcD+A5BMBAXIgZFDRwgBiABKQP4DjcAAC\
AGQShqIAwpAwA3AAAgBkEgaiANKQMANwAAIAZBGGogAikDADcAACAGQRBqIAopAwA3AAAgBkEIaiAP\
KQMANwAADAcLIAQgBUHYARA6IgFBkBJqIAFB2AEQOhogAUHoI2pBDGpCADcCACABQegjakEUakIANw\
IAIAFB6CNqQRxqQgA3AgAgAUHoI2pBJGpCADcCACABQegjakEsakIANwIAIAFB6CNqQTRqQgA3AgAg\
AUHoI2pBPGpCADcCACABQgA3AuwjQcAAIQMgAUHAADYC6CMgAUH4DmogAUHoI2pBxAAQOhogAUG4Im\
pBOGoiBiABQfgOakE8aikCADcDACABQbgiakEwaiICIAFB+A5qQTRqKQIANwMAIAFBuCJqQShqIgog\
AUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiDyABQfgOakEkaikCADcDACABQbgiakEYaiILIAFB+A5qQR\
xqKQIANwMAIAFBuCJqQRBqIgwgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDSABQfgOakEMaikCADcD\
ACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAjIAFB+A5qQThqIhAgBikDADcDACABQfgOak\
EwaiIOIAIpAwA3AwAgAUH4DmpBKGoiAiAKKQMANwMAIAFB+A5qQSBqIgogDykDADcDACABQfgOakEY\
aiIPIAspAwA3AwAgAUH4DmpBEGoiCyAMKQMANwMAIAFB+A5qQQhqIgwgDSkDADcDACABIAEpA7giNw\
P4DkHAABAXIgZFDRwgBiABKQP4DjcAACAGQThqIBApAwA3AAAgBkEwaiAOKQMANwAAIAZBKGogAikD\
ADcAACAGQSBqIAopAwA3AAAgBkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhqIAwpAwA3AAAMBg\
sgBEH4DmogBUH4AhA6GiADQQBIDQECQAJAIAMNAEEBIQYMAQsgAxAXIgZFDR0gBkF8ai0AAEEDcUUN\
ACAGQQAgAxA8GgsgBEGQEmogBEH4DmpB+AIQOhogBCAEQfgOakHIARA6Ig9ByAFqIA9BkBJqQcgBak\
GpARA6IQEgD0HoI2ogD0H4DmpByAEQOhogD0GIIWogAUGpARA6GiAPQYghaiAPLQCwIiIBaiEKAkAg\
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\
IQggDCAFfCEFIB8gBHwhBCABQYABaiIBIAJHDQALCyAAIAQ3AzggACAFNwMwIAAgBjcDKCAAIAc3Ay\
AgACAINwMYIAAgCTcDECAAIAo3AwggACALNwMAIANBgAFqJAAL+FsCDH8FfiMAQYAGayIEJAACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOAgABAgsgASgCACICQQJ0QbTTwA\
BqKAIAIQMMEQtBICEFIAEoAgAiAg4YAQ8CDxADDwQFBgYHBwgPCQoLDwwNEBAOAQsgASgCACECDA8L\
QcAAIQUMDQtBMCEFDAwLQRwhBQwLC0EwIQUMCgtBwAAhBQwJC0EQIQUMCAtBFCEFDAcLQRwhBQwGC0\
EwIQUMBQtBwAAhBQwEC0EcIQUMAwtBMCEFDAILQcAAIQUMAQtBGCEFCyAFIANGDQBBASEBQTkhA0Gt\
gcAAIQIMAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4YAAEC\
AwQFBgcICQoLDA0ODxAREhMUFRYaAAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCAC\
AEQdAEakEcakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB\
0ARqQTxqQgA3AgAgBEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDoaIARBoANqQThqIgYgBE\
EoakE8aikCADcDACAEQaADakEwaiIHIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiCCAEQShqQSxqKQIA\
NwMAIARBoANqQSBqIgkgBEEoakEkaikCADcDACAEQaADakEYaiIKIARBKGpBHGopAgA3AwAgBEGgA2\
pBEGoiCyAEQShqQRRqKQIANwMAIARBoANqQQhqIgwgBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIg\
AikDQCACQcgBaiIDLQAAIgGtfDcDQCACQcgAaiEFAkAgAUGAAUYNACAFIAFqQQBBgAEgAWsQPBoLQQ\
AhASADQQA6AAAgAiAFQn8QEiAEQShqQQhqIgUgAkEIaikDACIQNwMAIARBKGpBEGogAkEQaikDACIR\
NwMAIARBKGpBGGogAkEYaikDACISNwMAIARBKGpBIGogAikDICITNwMAIARBKGpBKGogAkEoaikDAC\
IUNwMAIAwgEDcDACALIBE3AwAgCiASNwMAIAkgEzcDACAIIBQ3AwAgByACQTBqKQMANwMAIAYgAkE4\
aikDADcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIAVBwAAQUSACIAVByAAQOhogA0EAOgAAQcAAEBciAk\
UNGiACIAQpA6ADNwAAIAJBOGogBEGgA2pBOGopAwA3AAAgAkEwaiAEQaADakEwaikDADcAACACQShq\
IARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AAAgAkEYaiAEQaADakEYaikDADcAACACQR\
BqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBwAAhAwwyCyABKAIEIQIgBEHQBGpB\
HGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2AtAEIARBKGpBGG\
oiByAEQdAEakEYaikDADcDACAEQShqQRBqIgggBEHQBGpBEGopAwA3AwAgBEEoakEIaiIDIARB0ARq\
QQhqKQMANwMAIARBKGpBIGoiCSAEQdAEakEgaigCADYCACAEIAQpA9AENwMoIARBoANqQRBqIgogBE\
EoakEUaikCADcDACAEQaADakEIaiILIARBKGpBDGopAgA3AwAgBEGgA2pBGGoiDCAEQShqQRxqKQIA\
NwMAIAQgBCkCLDcDoAMgAiACKQNAIAJByAFqIgUtAAAiAa18NwNAIAJByABqIQYCQCABQYABRg0AIA\
YgAWpBAEGAASABaxA8GgtBACEBIAVBADoAACACIAZCfxASIAMgAkEIaikDACIQNwMAIAggAkEQaikD\
ACIRNwMAIAcgAkEYaikDACISNwMAIAkgAikDIDcDACAEQShqQShqIAJBKGopAwA3AwAgCyAQNwMAIA\
ogETcDACAMIBI3AwAgBCACKQMAIhA3AyggBCAQNwOgAyADQSAQUSACIANByAAQOhogBUEAOgAAQSAQ\
FyICRQ0aIAIgBCkDoAM3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIA\
JBCGogBEGgA2pBCGopAwA3AABBICEDDDELIAEoAgQhAiAEQdAEakEsakIANwIAIARB0ARqQSRqQgA3\
AgAgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQTA2At\
AEIARBKGpBKGoiByAEQdAEakEoaikDADcDACAEQShqQSBqIgggBEHQBGpBIGopAwA3AwAgBEEoakEY\
aiIJIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCiAEQdAEakEQaikDADcDACAEQShqQQhqIgMgBEHQBG\
pBCGopAwA3AwAgBEEoakEwaiAEQdAEakEwaigCADYCACAEIAQpA9AENwMoIARBoANqQSBqIgsgBEEo\
akEkaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiDSAEQShqQRRqKQIANw\
MAIARBoANqQQhqIg4gBEEoakEMaikCADcDACAEQaADakEoaiIPIARBKGpBLGopAgA3AwAgBCAEKQIs\
NwOgAyACIAIpA0AgAkHIAWoiBS0AACIBrXw3A0AgAkHIAGohBgJAIAFBgAFGDQAgBiABakEAQYABIA\
FrEDwaC0EAIQEgBUEAOgAAIAIgBkJ/EBIgAyACQQhqKQMAIhA3AwAgCiACQRBqKQMAIhE3AwAgCSAC\
QRhqKQMAIhI3AwAgCCACKQMgIhM3AwAgByACQShqKQMAIhQ3AwAgDiAQNwMAIA0gETcDACAMIBI3Aw\
AgCyATNwMAIA8gFDcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIANBMBBRIAIgA0HIABA6GiAFQQA6AABB\
MBAXIgJFDRogAiAEKQOgAzcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AA\
AgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3\
AABBMCEDDDALIAEoAgQhAiAEQdAEakEcakIANwIAIARB0ARqQRRqQgA3AgAgBEHQBGpBDGpCADcCAC\
AEQgA3AtQEIARBIDYC0AQgBEEoakEYaiIHIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCCAEQdAEakEQ\
aikDADcDACAEQShqQQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEgaiIJIARB0ARqQSBqKAIANgIAIA\
QgBCkD0AQ3AyggBEGgA2pBEGoiCiAEQShqQRRqKQIANwMAIARBoANqQQhqIgsgBEEoakEMaikCADcD\
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\
LQAAczoAACABQQNqIgMgAy0AACABQcsBai0AAHM6AAAgAkEEaiICQcgARw0ACyAFECUgBEEoakE4ai\
IGIAVBOGopAAA3AwAgBEEoakEwaiIHIAVBMGopAAA3AwAgBEEoakEoaiIIIAVBKGopAAA3AwAgBEEo\
akEgaiIJIAVBIGopAAA3AwAgBEEoakEYaiIKIAVBGGopAAA3AwAgBEEoakEQaiILIAVBEGopAAA3Aw\
AgBEEoakEIaiIMIAVBCGopAAA3AwAgBCAFKQAANwMoQQAhASAFQQBByAEQPEGQAmpBADoAAEHAACED\
QcAAEBciAkUNGiACIAQpAyg3AAAgAkE4aiAGKQMANwAAIAJBMGogBykDADcAACACQShqIAgpAwA3AA\
AgAkEgaiAJKQMANwAAIAJBGGogCikDADcAACACQRBqIAspAwA3AAAgAkEIaiAMKQMANwAADCoLIAEo\
AgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEoakEQaiAEQdAEakEQaigCAD\
YCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAEIAQpA9AE\
NwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEDBBACEBIAJB2ABqQQA6AAAgAkEQakL+uevF6Y6VmR\
A3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFyICRQ0aIAIgBCkDoAM3AAAgAkEIaiAFKQMANwAA\
DCkLIAEoAgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEoakEQaiAEQdAEak\
EQaigCADYCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAE\
IAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEC9BACEBIAJB2ABqQQA6AAAgAkEQakL+ue\
vF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFyICRQ0aIAIgBCkDoAM3AAAgAkEIaiAF\
KQMANwAADCgLIAEoAgQhAkEUIQNBACEBIARB0ARqQRRqQQA2AgAgBEHQBGpBDGpCADcCACAEQgA3At\
QEIARBFDYC0AQgBEEoakEQaiAEQdAEakEQaikDADcDACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARB\
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\
IAQgBCkD0AQ3AyggBEGgA2pBGGoiASAEQShqQRxqKQIANwMAIARBoANqQRBqIgggBEEoakEUaikCAD\
cDACAEQaADakEIaiIJIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAJBKGogBEGgA2oQKCAFIAEp\
AwA3AwAgBiAIKQMANwMAIAcgCSkDADcDACAEIAQpA6ADNwMoIAJCADcDAEEAIQEgAkHoAGpBADoAAC\
ACQQApA/CNQDcDCCACQRBqQQApA/iNQDcDACACQRhqQQApA4COQDcDACACQSBqQQApA4iOQDcDAEEg\
EBciAkUNGiACIAQpAyg3AAAgAkEYaiAFKQMANwAAIAJBEGogBikDADcAACACQQhqIAcpAwA3AAAMIA\
sgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEcakIANwIAIARB0ARqQSRq\
QgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB0ARqQTxqQgA3AgAgBEIANwLUBCAEQc\
AANgLQBCAEQShqIARB0ARqQcQAEDoaIARBoANqQThqIARBKGpBPGopAgA3AwBBMCEDIARBoANqQTBq\
IARBKGpBNGopAgA3AwAgBEGgA2pBKGoiASAEQShqQSxqKQIANwMAIARBoANqQSBqIgUgBEEoakEkai\
kCADcDACAEQaADakEYaiIGIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiByAEQShqQRRqKQIANwMAIARB\
oANqQQhqIgggBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIyAEQShqQShqIg\
kgASkDADcDACAEQShqQSBqIgogBSkDADcDACAEQShqQRhqIgUgBikDADcDACAEQShqQRBqIgYgBykD\
ADcDACAEQShqQQhqIgcgCCkDADcDACAEIAQpA6ADNwMoIAJByABqQgA3AwAgAkIANwNAQQAhASACQT\
hqQQApA6iPQDcDACACQTBqQQApA6CPQDcDACACQShqQQApA5iPQDcDACACQSBqQQApA5CPQDcDACAC\
QRhqQQApA4iPQDcDACACQRBqQQApA4CPQDcDACACQQhqQQApA/iOQDcDACACQQApA/COQDcDACACQd\
ABakEAOgAAQTAQFyICRQ0aIAIgBCkDKDcAACACQShqIAkpAwA3AAAgAkEgaiAKKQMANwAAIAJBGGog\
BSkDADcAACACQRBqIAYpAwA3AAAgAkEIaiAHKQMANwAADB8LIAEoAgQhAiAEQdAEakEMakIANwIAIA\
RB0ARqQRRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQSxqQgA3AgAgBEHQ\
BGpBNGpCADcCACAEQdAEakE8akIANwIAIARCADcC1ARBwAAhAyAEQcAANgLQBCAEQShqIARB0ARqQc\
QAEDoaIARBoANqQThqIgEgBEEoakE8aikCADcDACAEQaADakEwaiIFIARBKGpBNGopAgA3AwAgBEGg\
A2pBKGoiBiAEQShqQSxqKQIANwMAIARBoANqQSBqIgcgBEEoakEkaikCADcDACAEQaADakEYaiIIIA\
RBKGpBHGopAgA3AwAgBEGgA2pBEGoiCSAEQShqQRRqKQIANwMAIARBoANqQQhqIgogBEEoakEMaikC\
ADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIyAEQShqQThqIgsgASkDADcDACAEQShqQTBqIg\
wgBSkDADcDACAEQShqQShqIgUgBikDADcDACAEQShqQSBqIgYgBykDADcDACAEQShqQRhqIgcgCCkD\
ADcDACAEQShqQRBqIgggCSkDADcDACAEQShqQQhqIgkgCikDADcDACAEIAQpA6ADNwMoIAJByABqQg\
A3AwAgAkIANwNAQQAhASACQThqQQApA+iOQDcDACACQTBqQQApA+COQDcDACACQShqQQApA9iOQDcD\
ACACQSBqQQApA9COQDcDACACQRhqQQApA8iOQDcDACACQRBqQQApA8COQDcDACACQQhqQQApA7iOQD\
cDACACQQApA7COQDcDACACQdABakEAOgAAQcAAEBciAkUNGiACIAQpAyg3AAAgAkE4aiALKQMANwAA\
IAJBMGogDCkDADcAACACQShqIAUpAwA3AAAgAkEgaiAGKQMANwAAIAJBGGogBykDADcAACACQRBqIA\
gpAwA3AAAgAkEIaiAJKQMANwAADB4LIANBAEgNASABKAIEIQcCQAJAIAMNAEEBIQIMAQsgAxAXIgJF\
DRsgAkF8ai0AAEEDcUUNACACQQAgAxA8GgsgByAHQfACaiIILQAAIgFqQcgBaiEGAkAgAUGoAUYNAC\
AGQQBBqAEgAWsQPBoLQQAhBSAIQQA6AAAgBkEfOgAAIAdB7wJqIgEgAS0AAEGAAXI6AAADQCAHIAVq\
IgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFBAmoiBiAGLQAAIA\
FBygFqLQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQagBRw0ACyAHECUgBEEo\
aiAHQcgBEDoaQQAhASAHQQBByAEQPEHwAmpBADoAACAEQQA2AqADIARBoANqQQRyQQBBqAEQPBogBE\
GoATYCoAMgBEHQBGogBEGgA2pBrAEQOhogBEEoakHIAWogBEHQBGpBBHJBqAEQOhogBEEoakHwAmpB\
ADoAACAEQShqIAIgAxAzDB0LIANBAEgNACABKAIEIQcgAw0BQQEhAgwCCxBrAAsgAxAXIgJFDRggAk\
F8ai0AAEEDcUUNACACQQAgAxA8GgsgByAHQdACaiIILQAAIgFqQcgBaiEGAkAgAUGIAUYNACAGQQBB\
iAEgAWsQPBoLQQAhBSAIQQA6AAAgBkEfOgAAIAdBzwJqIgEgAS0AAEGAAXI6AAADQCAHIAVqIgEgAS\
0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFBAmoiBiAGLQAAIAFBygFq\
LQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQYgBRw0ACyAHECUgBEEoaiAHQc\
gBEDoaQQAhASAHQQBByAEQPEHQAmpBADoAACAEQQA2AqADIARBoANqQQRyQQBBiAEQPBogBEGIATYC\
oAMgBEHQBGogBEGgA2pBjAEQOhogBEEoakHIAWogBEHQBGpBBHJBiAEQOhogBEEoakHQAmpBADoAAC\
AEQShqIAIgAxA0DBkLIAEoAgQhAiAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBEEY\
IQMgBEEYNgLQBCAEQShqQRBqIARB0ARqQRBqKQMANwMAIARBKGpBCGogBEHQBGpBCGopAwA3AwAgBE\
EoakEYaiAEQdAEakEYaigCADYCACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBEGgA2pBEGoiBiAE\
QShqQRRqKQIANwMAIAQgBCkD0AQ3AyggBCAEKQIsNwOgAyACIAJBIGogBEGgA2oQMSACQgA3AwBBAC\
EBIAJB4ABqQQA6AAAgAkEAKQP4kUA3AwggAkEQakEAKQOAkkA3AwAgAkEYakEAKQOIkkA3AwBBGBAX\
IgJFDRcgAiAEKQOgAzcAACACQRBqIAYpAwA3AAAgAkEIaiAFKQMANwAADBgLQcAAQQFBACgC+NRAIg\
RBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0Eg\
QQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQUAAAtBHEEBQQAoAvjUQCIEQQ\
QgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKAL41EAiBEEEIAQbEQUAAAtBwABB\
AUEAKAL41EAiBEEEIAQbEQUAAAtBEEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EQQQFBACgC+NRAIgRBBC\
AEGxEFAAALQRRBAUEAKAL41EAiBEEEIAQbEQUAAAtBFEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EcQQFB\
ACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBB\
sRBQAAC0HAAEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EcQQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEA\
KAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0HAAEEBQQAoAvjUQCIEQQQgBB\
sRBQAACyADQQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQUAAAtBGEEBQQAo\
AvjUQCIEQQQgBBsRBQAACyAAIAI2AgQgACABNgIAIABBCGogAzYCACAEQYAGaiQAC5xWAhp/An4jAE\
GwAmsiAyQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCAA4YAAECAwQFBgcICQoLDA0O\
DxAREhMUFRYXAAsgACgCBCIAQcgAaiEEAkBBgAEgAEHIAWotAAAiBWsiBiACTw0AAkAgBUUNACAEIA\
VqIAEgBhA6GiAAIAApA0BCgAF8NwNAIAAgBEIAEBIgASAGaiEBIAIgBmshAgsgAiACQQd2IgYgAkEA\
RyACQf8AcUVxIgdrIgVBB3QiCGshAiAFRQ1FIAhFDUUgBkEAIAdrakEHdCEGIAEhBQNAIAAgACkDQE\
KAAXw3A0AgACAFQgAQEiAFQYABaiEFIAZBgH9qIgYNAAxGCwsgBCAFaiABIAIQOhogBSACaiECDEUL\
IAAoAgQiAEHIAGohBAJAQYABIABByAFqLQAAIgVrIgYgAk8NAAJAIAVFDQAgBCAFaiABIAYQOhogAC\
AAKQNAQoABfDcDQCAAIARCABASIAEgBmohASACIAZrIQILIAIgAkEHdiIGIAJBAEcgAkH/AHFFcSIH\
ayIFQQd0IghrIQIgBUUNQSAIRQ1BIAZBACAHa2pBB3QhBiABIQUDQCAAIAApA0BCgAF8NwNAIAAgBU\
IAEBIgBUGAAWohBSAGQYB/aiIGDQAMQgsLIAQgBWogASACEDoaIAUgAmohAgxBCyAAKAIEIgBByABq\
IQQCQEGAASAAQcgBai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDoaIAAgACkDQEKAAXw3A0\
AgACAEQgAQEiABIAZqIQEgAiAGayECCyACIAJBB3YiBiACQQBHIAJB/wBxRXEiB2siBUEHdCIIayEC\
IAVFDT0gCEUNPSAGQQAgB2tqQQd0IQYgASEFA0AgACAAKQNAQoABfDcDQCAAIAVCABASIAVBgAFqIQ\
UgBkGAf2oiBg0ADD4LCyAEIAVqIAEgAhA6GiAFIAJqIQIMPQsgACgCBCIAQShqIQQCQEHAACAAQegA\
ai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDoaIAAgACkDAELAAHw3AwAgACAEQQAQFCABIA\
ZqIQEgAiAGayECCyACIAJBBnYiBiACQQBHIAJBP3FFcSIHayIFQQZ0IghrIQIgBUUNOSAIRQ05IAZB\
ACAHa2pBBnQhBiABIQUDQCAAIAApAwBCwAB8NwMAIAAgBUEAEBQgBUHAAGohBSAGQUBqIgYNAAw6Cw\
sgBCAFaiABIAIQOhogBSACaiECDDkLIAAoAgQiCEHpAGotAABBBnQgCC0AaGoiAEUNNiAIIAEgAkGA\
CCAAayIAIAAgAksbIgUQNRogAiAFayICRQ1CIANB+ABqQRBqIAhBEGoiACkDADcDACADQfgAakEYai\
AIQRhqIgYpAwA3AwAgA0H4AGpBIGogCEEgaiIEKQMANwMAIANB+ABqQTBqIAhBMGopAwA3AwAgA0H4\
AGpBOGogCEE4aikDADcDACADQfgAakHAAGogCEHAAGopAwA3AwAgA0H4AGpByABqIAhByABqKQMANw\
MAIANB+ABqQdAAaiAIQdAAaikDADcDACADQfgAakHYAGogCEHYAGopAwA3AwAgA0H4AGpB4ABqIAhB\
4ABqKQMANwMAIAMgCCkDCDcDgAEgAyAIKQMoNwOgASAIQekAai0AACEHIAgtAGohCSADIAgtAGgiCj\
oA4AEgAyAIKQMAIh03A3ggAyAJIAdFckECciIHOgDhASADQegBakEYaiIJIAQpAgA3AwAgA0HoAWpB\
EGoiBCAGKQIANwMAIANB6AFqQQhqIgYgACkCADcDACADIAgpAgg3A+gBIANB6AFqIANB+ABqQShqIA\
ogHSAHEBogCSgCACEHIAQoAgAhBCAGKAIAIQkgAygChAIhCiADKAL8ASELIAMoAvQBIQwgAygC7AEh\
DSADKALoASEOIAggCCkDABAqIAgoApABIgZBN08NEyAIQZABaiAGQQV0aiIAQSBqIAo2AgAgAEEcai\
AHNgIAIABBGGogCzYCACAAQRRqIAQ2AgAgAEEQaiAMNgIAIABBDGogCTYCACAAQQhqIA02AgAgAEEE\
aiAONgIAIAggBkEBajYCkAEgCEEoaiIAQgA3AwAgAEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3Aw\
AgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAhBADsBaCAIQQhqIgAgCCkD\
cDcDACAAQQhqIAhB+ABqKQMANwMAIABBEGogCEGAAWopAwA3AwAgAEEYaiAIQYgBaikDADcDACAIIA\
gpAwBCAXw3AwAgASAFaiEBDDYLIAAoAgQiBEHIAWohCgJAQZABIARB2AJqLQAAIgBrIgggAksNAAJA\
IABFDQAgCiAAaiABIAgQOhogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQ\
FqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAA\
IABBywFqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJSABIAhqIQELIAEgAkGQAW5BkAFsIgBqIQcgAi\
AAayEJIAJBjwFNDTMgAEUNMwNAIAFBkAFqIQhBACEFA0AgBCAFaiIAIAAtAAAgASAFaiIGLQAAczoA\
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\
KQMANwMAIApBGGogGCkDADcDACAKQSBqIBkpAwA3AwAgCkEoaiAaKQMANwMAIApBMGogGykDADcDAC\
AKQThqIBwpAwA3AwAgAy0A4gEhDiADLQDhASEXIAMgAy0A4AEiGDoAcCADIAMpA3giHjcDCCADIA4g\
F0VyQQJyIg46AHEgA0HoAWpBGGoiFyAHKQIANwMAIANB6AFqQRBqIgcgBikCADcDACADQegBakEIai\
IGIAUpAgA3AwAgAyALKQIANwPoASADQegBaiAKIBggHiAOEBogFygCACEOIAcoAgAhByAGKAIAIRcg\
AygChAIhGCADKAL8ASEZIAMoAvQBIRogAygC7AEhGyADKALoASEcIAggCCkDABAqIAgoApABIgZBN0\
8NCSANIAZBBXRqIgUgGDYCHCAFIA42AhggBSAZNgIUIAUgBzYCECAFIBo2AgwgBSAXNgIIIAUgGzYC\
BCAFIBw2AgAgCCAGQQFqNgKQAQsgCCAIKQMAIB18Ih43AwAgAiAASQ0JIAEgAGohASACIABrIgJBgA\
hLDQALCyACRQ0TIAggASACEDUaIAggCCkDABAqDBMLIAAgAkGghcAAEEsACyAFQcAAQeCEwAAQSwAL\
IAZBwABB8ITAABBLAAsgBkEgQYCFwAAQSwALIANBkAJqQQhqIgEgGjYCACADQZACakEQaiIAIBg2Ag\
AgA0GQAmpBGGoiBSAONgIAIAMgGTYCnAIgA0GBAWoiBiABKQMANwAAIAMgFzYCpAIgA0GJAWoiASAA\
KQMANwAAIAMgBzYCrAIgA0GRAWoiACAFKQMANwAAIAMgGzYClAIgAyAcNgKQAiADIAMpA5ACNwB5IA\
NBCGpBGGogACkAADcDACADQQhqQRBqIAEpAAA3AwAgA0EIakEIaiAGKQAANwMAIAMgAykAeTcDCEGQ\
ksAAIANBCGpBgIbAAEH4hsAAEEIACyADQZACakEIaiIBIBQ2AgAgA0GQAmpBEGoiACASNgIAIANBkA\
JqQRhqIgUgEDYCACADIBM2ApwCIANBgQFqIgYgASkDADcAACADIBE2AqQCIANBiQFqIgEgACkDADcA\
ACADIA82AqwCIANBkQFqIgAgBSkDADcAACADIBU2ApQCIAMgFjYCkAIgAyADKQOQAjcAeSADQQhqQR\
hqIAApAAA3AwAgA0EIakEQaiABKQAANwMAIANBCGpBCGogBikAADcDACADIAMpAHk3AwhBkJLAACAD\
QQhqQYCGwABB+IbAABBCAAsgA0GYAmoiASAXNgIAIANBoAJqIgAgBzYCACADQagCaiIFIA42AgAgAy\
AaNgKcAiADQfEBaiIGIAEpAwA3AAAgAyAZNgKkAiADQfkBaiICIAApAwA3AAAgAyAYNgKsAiADQYEC\
aiIEIAUpAwA3AAAgAyAbNgKUAiADIBw2ApACIAMgAykDkAI3AOkBIAUgBCkAADcDACAAIAIpAAA3Aw\
AgASAGKQAANwMAIAMgAykA6QE3A5ACQZCSwAAgA0GQAmpBgIbAAEH4hsAAEEIACyAAIAJBsIXAABBM\
AAsgAkHBAE8NASAEIAEgCGogAhA6GgsgAEHoAGogAjoAAAwJCyACQcAAQYCAwAAQSwALIAJBgQFPDQ\
EgBCABIAhqIAIQOhoLIABByAFqIAI6AAAMBgsgAkGAAUGAgMAAEEsACyACQYEBTw0BIAQgASAIaiAC\
EDoaCyAAQcgBaiACOgAADAMLIAJBgAFBgIDAABBLAAsgAkGBAU8NAiAEIAEgCGogAhA6GgsgAEHIAW\
ogAjoAAAsgA0GwAmokAA8LIAJBgAFBgIDAABBLAAu1QQElfyMAQcAAayIDQThqQgA3AwAgA0EwakIA\
NwMAIANBKGpCADcDACADQSBqQgA3AwAgA0EYakIANwMAIANBEGpCADcDACADQQhqQgA3AwAgA0IANw\
MAIAAoAhwhBCAAKAIYIQUgACgCFCEGIAAoAhAhByAAKAIMIQggACgCCCEJIAAoAgQhCiAAKAIAIQsC\
QCACQQZ0IgJFDQAgASACaiEMA0AgAyABKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGH\
ZycjYCACADIAFBBGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyNgIEIAMgAUEI\
aigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnI2AgggAyABQQxqKAAAIgJBGHQgAk\
EIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZycjYCDCADIAFBEGooAAAiAkEYdCACQQh0QYCA/AdxciAC\
QQh2QYD+A3EgAkEYdnJyNgIQIAMgAUEUaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQR\
h2cnI2AhQgAyABQSBqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciINNgIgIAMg\
AUEcaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiDjYCHCADIAFBGGooAAAiAk\
EYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIg82AhggAygCACEQIAMoAgQhESADKAIIIRIg\
AygCDCETIAMoAhAhFCADKAIUIRUgAyABQSRqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIA\
JBGHZyciIWNgIkIAMgAUEoaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiFzYC\
KCADIAFBLGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIhg2AiwgAyABQTBqKA\
AAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIZNgIwIAMgAUE0aigAACICQRh0IAJB\
CHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiGjYCNCADIAFBOGooAAAiAkEYdCACQQh0QYCA/Adxci\
ACQQh2QYD+A3EgAkEYdnJyIgI2AjggAyABQTxqKAAAIhtBGHQgG0EIdEGAgPwHcXIgG0EIdkGA/gNx\
IBtBGHZyciIbNgI8IAsgCnEiHCAKIAlxcyALIAlxcyALQR53IAtBE3dzIAtBCndzaiAQIAQgBiAFcy\
AHcSAFc2ogB0EadyAHQRV3cyAHQQd3c2pqQZjfqJQEaiIdaiIeQR53IB5BE3dzIB5BCndzIB4gCyAK\
c3EgHHNqIAUgEWogHSAIaiIfIAcgBnNxIAZzaiAfQRp3IB9BFXdzIB9BB3dzakGRid2JB2oiHWoiHC\
AecSIgIB4gC3FzIBwgC3FzIBxBHncgHEETd3MgHEEKd3NqIAYgEmogHSAJaiIhIB8gB3NxIAdzaiAh\
QRp3ICFBFXdzICFBB3dzakHP94Oue2oiHWoiIkEedyAiQRN3cyAiQQp3cyAiIBwgHnNxICBzaiAHIB\
NqIB0gCmoiICAhIB9zcSAfc2ogIEEadyAgQRV3cyAgQQd3c2pBpbfXzX5qIiNqIh0gInEiJCAiIBxx\
cyAdIBxxcyAdQR53IB1BE3dzIB1BCndzaiAfIBRqICMgC2oiHyAgICFzcSAhc2ogH0EadyAfQRV3cy\
AfQQd3c2pB24TbygNqIiVqIiNBHncgI0ETd3MgI0EKd3MgIyAdICJzcSAkc2ogFSAhaiAlIB5qIiEg\
HyAgc3EgIHNqICFBGncgIUEVd3MgIUEHd3NqQfGjxM8FaiIkaiIeICNxIiUgIyAdcXMgHiAdcXMgHk\
EedyAeQRN3cyAeQQp3c2ogDyAgaiAkIBxqIiAgISAfc3EgH3NqICBBGncgIEEVd3MgIEEHd3NqQaSF\
/pF5aiIcaiIkQR53ICRBE3dzICRBCndzICQgHiAjc3EgJXNqIA4gH2ogHCAiaiIfICAgIXNxICFzai\
AfQRp3IB9BFXdzIB9BB3dzakHVvfHYemoiImoiHCAkcSIlICQgHnFzIBwgHnFzIBxBHncgHEETd3Mg\
HEEKd3NqIA0gIWogIiAdaiIhIB8gIHNxICBzaiAhQRp3ICFBFXdzICFBB3dzakGY1Z7AfWoiHWoiIk\
EedyAiQRN3cyAiQQp3cyAiIBwgJHNxICVzaiAWICBqIB0gI2oiICAhIB9zcSAfc2ogIEEadyAgQRV3\
cyAgQQd3c2pBgbaNlAFqIiNqIh0gInEiJSAiIBxxcyAdIBxxcyAdQR53IB1BE3dzIB1BCndzaiAXIB\
9qICMgHmoiHyAgICFzcSAhc2ogH0EadyAfQRV3cyAfQQd3c2pBvovGoQJqIh5qIiNBHncgI0ETd3Mg\
I0EKd3MgIyAdICJzcSAlc2ogGCAhaiAeICRqIiEgHyAgc3EgIHNqICFBGncgIUEVd3MgIUEHd3NqQc\
P7sagFaiIkaiIeICNxIiUgIyAdcXMgHiAdcXMgHkEedyAeQRN3cyAeQQp3c2ogGSAgaiAkIBxqIiAg\
ISAfc3EgH3NqICBBGncgIEEVd3MgIEEHd3NqQfS6+ZUHaiIcaiIkQR53ICRBE3dzICRBCndzICQgHi\
Ajc3EgJXNqIBogH2ogHCAiaiIiICAgIXNxICFzaiAiQRp3ICJBFXdzICJBB3dzakH+4/qGeGoiH2oi\
HCAkcSImICQgHnFzIBwgHnFzIBxBHncgHEETd3MgHEEKd3NqIAIgIWogHyAdaiIhICIgIHNxICBzai\
AhQRp3ICFBFXdzICFBB3dzakGnjfDeeWoiHWoiJUEedyAlQRN3cyAlQQp3cyAlIBwgJHNxICZzaiAb\
ICBqIB0gI2oiICAhICJzcSAic2ogIEEadyAgQRV3cyAgQQd3c2pB9OLvjHxqIiNqIh0gJXEiJiAlIB\
xxcyAdIBxxcyAdQR53IB1BE3dzIB1BCndzaiAQIBFBDncgEUEZd3MgEUEDdnNqIBZqIAJBD3cgAkEN\
d3MgAkEKdnNqIh8gImogIyAeaiIjICAgIXNxICFzaiAjQRp3ICNBFXdzICNBB3dzakHB0+2kfmoiIm\
oiEEEedyAQQRN3cyAQQQp3cyAQIB0gJXNxICZzaiARIBJBDncgEkEZd3MgEkEDdnNqIBdqIBtBD3cg\
G0ENd3MgG0EKdnNqIh4gIWogIiAkaiIkICMgIHNxICBzaiAkQRp3ICRBFXdzICRBB3dzakGGj/n9fm\
oiEWoiISAQcSImIBAgHXFzICEgHXFzICFBHncgIUETd3MgIUEKd3NqIBIgE0EOdyATQRl3cyATQQN2\
c2ogGGogH0EPdyAfQQ13cyAfQQp2c2oiIiAgaiARIBxqIhEgJCAjc3EgI3NqIBFBGncgEUEVd3MgEU\
EHd3NqQca7hv4AaiIgaiISQR53IBJBE3dzIBJBCndzIBIgISAQc3EgJnNqIBMgFEEOdyAUQRl3cyAU\
QQN2c2ogGWogHkEPdyAeQQ13cyAeQQp2c2oiHCAjaiAgICVqIhMgESAkc3EgJHNqIBNBGncgE0EVd3\
MgE0EHd3NqQczDsqACaiIlaiIgIBJxIicgEiAhcXMgICAhcXMgIEEedyAgQRN3cyAgQQp3c2ogFCAV\
QQ53IBVBGXdzIBVBA3ZzaiAaaiAiQQ93ICJBDXdzICJBCnZzaiIjICRqICUgHWoiFCATIBFzcSARc2\
ogFEEadyAUQRV3cyAUQQd3c2pB79ik7wJqIiRqIiZBHncgJkETd3MgJkEKd3MgJiAgIBJzcSAnc2og\
FSAPQQ53IA9BGXdzIA9BA3ZzaiACaiAcQQ93IBxBDXdzIBxBCnZzaiIdIBFqICQgEGoiFSAUIBNzcS\
ATc2ogFUEadyAVQRV3cyAVQQd3c2pBqonS0wRqIhBqIiQgJnEiESAmICBxcyAkICBxcyAkQR53ICRB\
E3dzICRBCndzaiAOQQ53IA5BGXdzIA5BA3ZzIA9qIBtqICNBD3cgI0ENd3MgI0EKdnNqIiUgE2ogEC\
AhaiITIBUgFHNxIBRzaiATQRp3IBNBFXdzIBNBB3dzakHc08LlBWoiEGoiD0EedyAPQRN3cyAPQQp3\
cyAPICQgJnNxIBFzaiANQQ53IA1BGXdzIA1BA3ZzIA5qIB9qIB1BD3cgHUENd3MgHUEKdnNqIiEgFG\
ogECASaiIUIBMgFXNxIBVzaiAUQRp3IBRBFXdzIBRBB3dzakHakea3B2oiEmoiECAPcSIOIA8gJHFz\
IBAgJHFzIBBBHncgEEETd3MgEEEKd3NqIBZBDncgFkEZd3MgFkEDdnMgDWogHmogJUEPdyAlQQ13cy\
AlQQp2c2oiESAVaiASICBqIhUgFCATc3EgE3NqIBVBGncgFUEVd3MgFUEHd3NqQdKi+cF5aiISaiIN\
QR53IA1BE3dzIA1BCndzIA0gECAPc3EgDnNqIBdBDncgF0EZd3MgF0EDdnMgFmogImogIUEPdyAhQQ\
13cyAhQQp2c2oiICATaiASICZqIhYgFSAUc3EgFHNqIBZBGncgFkEVd3MgFkEHd3NqQe2Mx8F6aiIm\
aiISIA1xIicgDSAQcXMgEiAQcXMgEkEedyASQRN3cyASQQp3c2ogGEEOdyAYQRl3cyAYQQN2cyAXai\
AcaiARQQ93IBFBDXdzIBFBCnZzaiITIBRqICYgJGoiFyAWIBVzcSAVc2ogF0EadyAXQRV3cyAXQQd3\
c2pByM+MgHtqIhRqIg5BHncgDkETd3MgDkEKd3MgDiASIA1zcSAnc2ogGUEOdyAZQRl3cyAZQQN2cy\
AYaiAjaiAgQQ93ICBBDXdzICBBCnZzaiIkIBVqIBQgD2oiDyAXIBZzcSAWc2ogD0EadyAPQRV3cyAP\
QQd3c2pBx//l+ntqIhVqIhQgDnEiJyAOIBJxcyAUIBJxcyAUQR53IBRBE3dzIBRBCndzaiAaQQ53IB\
pBGXdzIBpBA3ZzIBlqIB1qIBNBD3cgE0ENd3MgE0EKdnNqIiYgFmogFSAQaiIWIA8gF3NxIBdzaiAW\
QRp3IBZBFXdzIBZBB3dzakHzl4C3fGoiFWoiGEEedyAYQRN3cyAYQQp3cyAYIBQgDnNxICdzaiACQQ\
53IAJBGXdzIAJBA3ZzIBpqICVqICRBD3cgJEENd3MgJEEKdnNqIhAgF2ogFSANaiINIBYgD3NxIA9z\
aiANQRp3IA1BFXdzIA1BB3dzakHHop6tfWoiF2oiFSAYcSIZIBggFHFzIBUgFHFzIBVBHncgFUETd3\
MgFUEKd3NqIBtBDncgG0EZd3MgG0EDdnMgAmogIWogJkEPdyAmQQ13cyAmQQp2c2oiAiAPaiAXIBJq\
Ig8gDSAWc3EgFnNqIA9BGncgD0EVd3MgD0EHd3NqQdHGqTZqIhJqIhdBHncgF0ETd3MgF0EKd3MgFy\
AVIBhzcSAZc2ogH0EOdyAfQRl3cyAfQQN2cyAbaiARaiAQQQ93IBBBDXdzIBBBCnZzaiIbIBZqIBIg\
DmoiFiAPIA1zcSANc2ogFkEadyAWQRV3cyAWQQd3c2pB59KkoQFqIg5qIhIgF3EiGSAXIBVxcyASIB\
VxcyASQR53IBJBE3dzIBJBCndzaiAeQQ53IB5BGXdzIB5BA3ZzIB9qICBqIAJBD3cgAkENd3MgAkEK\
dnNqIh8gDWogDiAUaiINIBYgD3NxIA9zaiANQRp3IA1BFXdzIA1BB3dzakGFldy9AmoiFGoiDkEedy\
AOQRN3cyAOQQp3cyAOIBIgF3NxIBlzaiAiQQ53ICJBGXdzICJBA3ZzIB5qIBNqIBtBD3cgG0ENd3Mg\
G0EKdnNqIh4gD2ogFCAYaiIPIA0gFnNxIBZzaiAPQRp3IA9BFXdzIA9BB3dzakG4wuzwAmoiGGoiFC\
AOcSIZIA4gEnFzIBQgEnFzIBRBHncgFEETd3MgFEEKd3NqIBxBDncgHEEZd3MgHEEDdnMgImogJGog\
H0EPdyAfQQ13cyAfQQp2c2oiIiAWaiAYIBVqIhYgDyANc3EgDXNqIBZBGncgFkEVd3MgFkEHd3NqQf\
zbsekEaiIVaiIYQR53IBhBE3dzIBhBCndzIBggFCAOc3EgGXNqICNBDncgI0EZd3MgI0EDdnMgHGog\
JmogHkEPdyAeQQ13cyAeQQp2c2oiHCANaiAVIBdqIg0gFiAPc3EgD3NqIA1BGncgDUEVd3MgDUEHd3\
NqQZOa4JkFaiIXaiIVIBhxIhkgGCAUcXMgFSAUcXMgFUEedyAVQRN3cyAVQQp3c2ogHUEOdyAdQRl3\
cyAdQQN2cyAjaiAQaiAiQQ93ICJBDXdzICJBCnZzaiIjIA9qIBcgEmoiDyANIBZzcSAWc2ogD0Eady\
APQRV3cyAPQQd3c2pB1OapqAZqIhJqIhdBHncgF0ETd3MgF0EKd3MgFyAVIBhzcSAZc2ogJUEOdyAl\
QRl3cyAlQQN2cyAdaiACaiAcQQ93IBxBDXdzIBxBCnZzaiIdIBZqIBIgDmoiFiAPIA1zcSANc2ogFk\
EadyAWQRV3cyAWQQd3c2pBu5WoswdqIg5qIhIgF3EiGSAXIBVxcyASIBVxcyASQR53IBJBE3dzIBJB\
CndzaiAhQQ53ICFBGXdzICFBA3ZzICVqIBtqICNBD3cgI0ENd3MgI0EKdnNqIiUgDWogDiAUaiINIB\
YgD3NxIA9zaiANQRp3IA1BFXdzIA1BB3dzakGukouOeGoiFGoiDkEedyAOQRN3cyAOQQp3cyAOIBIg\
F3NxIBlzaiARQQ53IBFBGXdzIBFBA3ZzICFqIB9qIB1BD3cgHUENd3MgHUEKdnNqIiEgD2ogFCAYai\
IPIA0gFnNxIBZzaiAPQRp3IA9BFXdzIA9BB3dzakGF2ciTeWoiGGoiFCAOcSIZIA4gEnFzIBQgEnFz\
IBRBHncgFEETd3MgFEEKd3NqICBBDncgIEEZd3MgIEEDdnMgEWogHmogJUEPdyAlQQ13cyAlQQp2c2\
oiESAWaiAYIBVqIhYgDyANc3EgDXNqIBZBGncgFkEVd3MgFkEHd3NqQaHR/5V6aiIVaiIYQR53IBhB\
E3dzIBhBCndzIBggFCAOc3EgGXNqIBNBDncgE0EZd3MgE0EDdnMgIGogImogIUEPdyAhQQ13cyAhQQ\
p2c2oiICANaiAVIBdqIg0gFiAPc3EgD3NqIA1BGncgDUEVd3MgDUEHd3NqQcvM6cB6aiIXaiIVIBhx\
IhkgGCAUcXMgFSAUcXMgFUEedyAVQRN3cyAVQQp3c2ogJEEOdyAkQRl3cyAkQQN2cyATaiAcaiARQQ\
93IBFBDXdzIBFBCnZzaiITIA9qIBcgEmoiDyANIBZzcSAWc2ogD0EadyAPQRV3cyAPQQd3c2pB8Jau\
knxqIhJqIhdBHncgF0ETd3MgF0EKd3MgFyAVIBhzcSAZc2ogJkEOdyAmQRl3cyAmQQN2cyAkaiAjai\
AgQQ93ICBBDXdzICBBCnZzaiIkIBZqIBIgDmoiFiAPIA1zcSANc2ogFkEadyAWQRV3cyAWQQd3c2pB\
o6Oxu3xqIg5qIhIgF3EiGSAXIBVxcyASIBVxcyASQR53IBJBE3dzIBJBCndzaiAQQQ53IBBBGXdzIB\
BBA3ZzICZqIB1qIBNBD3cgE0ENd3MgE0EKdnNqIiYgDWogDiAUaiINIBYgD3NxIA9zaiANQRp3IA1B\
FXdzIA1BB3dzakGZ0MuMfWoiFGoiDkEedyAOQRN3cyAOQQp3cyAOIBIgF3NxIBlzaiACQQ53IAJBGX\
dzIAJBA3ZzIBBqICVqICRBD3cgJEENd3MgJEEKdnNqIhAgD2ogFCAYaiIPIA0gFnNxIBZzaiAPQRp3\
IA9BFXdzIA9BB3dzakGkjOS0fWoiGGoiFCAOcSIZIA4gEnFzIBQgEnFzIBRBHncgFEETd3MgFEEKd3\
NqIBtBDncgG0EZd3MgG0EDdnMgAmogIWogJkEPdyAmQQ13cyAmQQp2c2oiAiAWaiAYIBVqIhYgDyAN\
c3EgDXNqIBZBGncgFkEVd3MgFkEHd3NqQYXruKB/aiIVaiIYQR53IBhBE3dzIBhBCndzIBggFCAOc3\
EgGXNqIB9BDncgH0EZd3MgH0EDdnMgG2ogEWogEEEPdyAQQQ13cyAQQQp2c2oiGyANaiAVIBdqIg0g\
FiAPc3EgD3NqIA1BGncgDUEVd3MgDUEHd3NqQfDAqoMBaiIXaiIVIBhxIhkgGCAUcXMgFSAUcXMgFU\
EedyAVQRN3cyAVQQp3c2ogHkEOdyAeQRl3cyAeQQN2cyAfaiAgaiACQQ93IAJBDXdzIAJBCnZzaiIf\
IA9qIBcgEmoiEiANIBZzcSAWc2ogEkEadyASQRV3cyASQQd3c2pBloKTzQFqIhpqIg9BHncgD0ETd3\
MgD0EKd3MgDyAVIBhzcSAZc2ogIkEOdyAiQRl3cyAiQQN2cyAeaiATaiAbQQ93IBtBDXdzIBtBCnZz\
aiIXIBZqIBogDmoiFiASIA1zcSANc2ogFkEadyAWQRV3cyAWQQd3c2pBiNjd8QFqIhlqIh4gD3EiGi\
APIBVxcyAeIBVxcyAeQR53IB5BE3dzIB5BCndzaiAcQQ53IBxBGXdzIBxBA3ZzICJqICRqIB9BD3cg\
H0ENd3MgH0EKdnNqIg4gDWogGSAUaiIiIBYgEnNxIBJzaiAiQRp3ICJBFXdzICJBB3dzakHM7qG6Am\
oiGWoiFEEedyAUQRN3cyAUQQp3cyAUIB4gD3NxIBpzaiAjQQ53ICNBGXdzICNBA3ZzIBxqICZqIBdB\
D3cgF0ENd3MgF0EKdnNqIg0gEmogGSAYaiISICIgFnNxIBZzaiASQRp3IBJBFXdzIBJBB3dzakG1+c\
KlA2oiGWoiHCAUcSIaIBQgHnFzIBwgHnFzIBxBHncgHEETd3MgHEEKd3NqIB1BDncgHUEZd3MgHUED\
dnMgI2ogEGogDkEPdyAOQQ13cyAOQQp2c2oiGCAWaiAZIBVqIiMgEiAic3EgInNqICNBGncgI0EVd3\
MgI0EHd3NqQbOZ8MgDaiIZaiIVQR53IBVBE3dzIBVBCndzIBUgHCAUc3EgGnNqICVBDncgJUEZd3Mg\
JUEDdnMgHWogAmogDUEPdyANQQ13cyANQQp2c2oiFiAiaiAZIA9qIiIgIyASc3EgEnNqICJBGncgIk\
EVd3MgIkEHd3NqQcrU4vYEaiIZaiIdIBVxIhogFSAccXMgHSAccXMgHUEedyAdQRN3cyAdQQp3c2og\
IUEOdyAhQRl3cyAhQQN2cyAlaiAbaiAYQQ93IBhBDXdzIBhBCnZzaiIPIBJqIBkgHmoiJSAiICNzcS\
Ajc2ogJUEadyAlQRV3cyAlQQd3c2pBz5Tz3AVqIh5qIhJBHncgEkETd3MgEkEKd3MgEiAdIBVzcSAa\
c2ogEUEOdyARQRl3cyARQQN2cyAhaiAfaiAWQQ93IBZBDXdzIBZBCnZzaiIZICNqIB4gFGoiISAlIC\
JzcSAic2ogIUEadyAhQRV3cyAhQQd3c2pB89+5wQZqIiNqIh4gEnEiFCASIB1xcyAeIB1xcyAeQR53\
IB5BE3dzIB5BCndzaiAgQQ53ICBBGXdzICBBA3ZzIBFqIBdqIA9BD3cgD0ENd3MgD0EKdnNqIhEgIm\
ogIyAcaiIiICEgJXNxICVzaiAiQRp3ICJBFXdzICJBB3dzakHuhb6kB2oiHGoiI0EedyAjQRN3cyAj\
QQp3cyAjIB4gEnNxIBRzaiATQQ53IBNBGXdzIBNBA3ZzICBqIA5qIBlBD3cgGUENd3MgGUEKdnNqIh\
QgJWogHCAVaiIgICIgIXNxICFzaiAgQRp3ICBBFXdzICBBB3dzakHvxpXFB2oiJWoiHCAjcSIVICMg\
HnFzIBwgHnFzIBxBHncgHEETd3MgHEEKd3NqICRBDncgJEEZd3MgJEEDdnMgE2ogDWogEUEPdyARQQ\
13cyARQQp2c2oiEyAhaiAlIB1qIiEgICAic3EgInNqICFBGncgIUEVd3MgIUEHd3NqQZTwoaZ4aiId\
aiIlQR53ICVBE3dzICVBCndzICUgHCAjc3EgFXNqICZBDncgJkEZd3MgJkEDdnMgJGogGGogFEEPdy\
AUQQ13cyAUQQp2c2oiJCAiaiAdIBJqIiIgISAgc3EgIHNqICJBGncgIkEVd3MgIkEHd3NqQYiEnOZ4\
aiIUaiIdICVxIhUgJSAccXMgHSAccXMgHUEedyAdQRN3cyAdQQp3c2ogEEEOdyAQQRl3cyAQQQN2cy\
AmaiAWaiATQQ93IBNBDXdzIBNBCnZzaiISICBqIBQgHmoiHiAiICFzcSAhc2ogHkEadyAeQRV3cyAe\
QQd3c2pB+v/7hXlqIhNqIiBBHncgIEETd3MgIEEKd3MgICAdICVzcSAVc2ogAkEOdyACQRl3cyACQQ\
N2cyAQaiAPaiAkQQ93ICRBDXdzICRBCnZzaiIkICFqIBMgI2oiISAeICJzcSAic2ogIUEadyAhQRV3\
cyAhQQd3c2pB69nBonpqIhBqIiMgIHEiEyAgIB1xcyAjIB1xcyAjQR53ICNBE3dzICNBCndzaiACIB\
tBDncgG0EZd3MgG0EDdnNqIBlqIBJBD3cgEkENd3MgEkEKdnNqICJqIBAgHGoiAiAhIB5zcSAec2og\
AkEadyACQRV3cyACQQd3c2pB98fm93tqIiJqIhwgIyAgc3EgE3MgC2ogHEEedyAcQRN3cyAcQQp3c2\
ogGyAfQQ53IB9BGXdzIB9BA3ZzaiARaiAkQQ93ICRBDXdzICRBCnZzaiAeaiAiICVqIhsgAiAhc3Eg\
IXNqIBtBGncgG0EVd3MgG0EHd3NqQfLxxbN8aiIeaiELIBwgCmohCiAjIAlqIQkgICAIaiEIIB0gB2\
ogHmohByAbIAZqIQYgAiAFaiEFICEgBGohBCABQcAAaiIBIAxHDQALCyAAIAQ2AhwgACAFNgIYIAAg\
BjYCFCAAIAc2AhAgACAINgIMIAAgCTYCCCAAIAo2AgQgACALNgIAC5kvAgN/Kn4jAEGAAWsiAyQAIA\
NBAEGAARA8IgMgASkAADcDACADIAEpAAg3AwggAyABKQAQNwMQIAMgASkAGDcDGCADIAEpACA3AyAg\
AyABKQAoNwMoIAMgASkAMCIGNwMwIAMgASkAOCIHNwM4IAMgASkAQCIINwNAIAMgASkASCIJNwNIIA\
MgASkAUCIKNwNQIAMgASkAWCILNwNYIAMgASkAYCIMNwNgIAMgASkAaCINNwNoIAMgASkAcCIONwNw\
IAMgASkAeCIPNwN4IAAgDCAKIA4gCSAIIAsgDyAIIAcgDSALIAYgCCAJIAkgCiAOIA8gCCAIIAYgDy\
AKIA4gCyAHIA0gDyAHIAsgBiANIA0gDCAHIAYgAEE4aiIBKQMAIhAgACkDGCIRfHwiEkL5wvibkaOz\
8NsAhUIgiSITQvHt9Pilp/2npX98IhQgEIVCKIkiFSASfHwiFiAThUIwiSIXIBR8IhggFYVCAYkiGS\
AAQTBqIgQpAwAiGiAAKQMQIht8IAMpAyAiEnwiEyAChULr+obav7X2wR+FQiCJIhxCq/DT9K/uvLc8\
fCIdIBqFQiiJIh4gE3wgAykDKCICfCIffHwiICAAQShqIgUpAwAiISAAKQMIIiJ8IAMpAxAiE3wiFE\
Kf2PnZwpHagpt/hUIgiSIVQrvOqqbY0Ouzu398IiMgIYVCKIkiJCAUfCADKQMYIhR8IiUgFYVCMIki\
JoVCIIkiJyAAKQNAIAApAyAiKCAAKQMAIil8IAMpAwAiFXwiKoVC0YWa7/rPlIfRAIVCIIkiK0KIkv\
Od/8z5hOoAfCIsICiFQiiJIi0gKnwgAykDCCIqfCIuICuFQjCJIisgLHwiLHwiLyAZhUIoiSIZICB8\
fCIgICeFQjCJIicgL3wiLyAZhUIBiSIZIA8gDiAWICwgLYVCAYkiLHx8IhYgHyAchUIwiSIchUIgiS\
IfICYgI3wiI3wiJiAshUIoiSIsIBZ8fCIWfHwiLSAJIAggIyAkhUIBiSIjIC58fCIkIBeFQiCJIhcg\
HCAdfCIcfCIdICOFQiiJIiMgJHx8IiQgF4VCMIkiF4VCIIkiLiALIAogHCAehUIBiSIcICV8fCIeIC\
uFQiCJIiUgGHwiGCAchUIoiSIcIB58fCIeICWFQjCJIiUgGHwiGHwiKyAZhUIoiSIZIC18fCItIC6F\
QjCJIi4gK3wiKyAZhUIBiSIZIA8gCSAgIBggHIVCAYkiGHx8IhwgFiAfhUIwiSIWhUIgiSIfIBcgHX\
wiF3wiHSAYhUIoiSIYIBx8fCIcfHwiICAIIB4gFyAjhUIBiSIXfCASfCIeICeFQiCJIiMgFiAmfCIW\
fCImIBeFQiiJIhcgHnx8Ih4gI4VCMIkiI4VCIIkiJyAKIA4gFiAshUIBiSIWICR8fCIkICWFQiCJIi\
UgL3wiLCAWhUIoiSIWICR8fCIkICWFQjCJIiUgLHwiLHwiLyAZhUIoiSIZICB8fCIgICeFQjCJIicg\
L3wiLyAZhUIBiSIZIC0gLCAWhUIBiSIWfCACfCIsIBwgH4VCMIkiHIVCIIkiHyAjICZ8IiN8IiYgFo\
VCKIkiFiAsfCAUfCIsfHwiLSAMICMgF4VCAYkiFyAkfCAqfCIjIC6FQiCJIiQgHCAdfCIcfCIdIBeF\
QiiJIhcgI3x8IiMgJIVCMIkiJIVCIIkiLiAcIBiFQgGJIhggHnwgFXwiHCAlhUIgiSIeICt8IiUgGI\
VCKIkiGCAcfCATfCIcIB6FQjCJIh4gJXwiJXwiKyAZhUIoiSIZIC18fCItIC6FQjCJIi4gK3wiKyAZ\
hUIBiSIZICAgJSAYhUIBiSIYfCACfCIgICwgH4VCMIkiH4VCIIkiJSAkIB18Ih18IiQgGIVCKIkiGC\
AgfCATfCIgfHwiLCAMIBwgHSAXhUIBiSIXfHwiHCAnhUIgiSIdIB8gJnwiH3wiJiAXhUIoiSIXIBx8\
IBV8IhwgHYVCMIkiHYVCIIkiJyAIIAsgHyAWhUIBiSIWICN8fCIfIB6FQiCJIh4gL3wiIyAWhUIoiS\
IWIB98fCIfIB6FQjCJIh4gI3wiI3wiLyAZhUIoiSIZICx8ICp8IiwgJ4VCMIkiJyAvfCIvIBmFQgGJ\
IhkgCSAtICMgFoVCAYkiFnx8IiMgICAlhUIwiSIghUIgiSIlIB0gJnwiHXwiJiAWhUIoiSIWICN8IB\
J8IiN8fCItIA4gCiAdIBeFQgGJIhcgH3x8Ih0gLoVCIIkiHyAgICR8IiB8IiQgF4VCKIkiFyAdfHwi\
HSAfhUIwiSIfhUIgiSIuIAYgICAYhUIBiSIYIBx8IBR8IhwgHoVCIIkiHiArfCIgIBiFQiiJIhggHH\
x8IhwgHoVCMIkiHiAgfCIgfCIrIBmFQiiJIhkgLXx8Ii0gLoVCMIkiLiArfCIrIBmFQgGJIhkgDCAN\
ICwgICAYhUIBiSIYfHwiICAjICWFQjCJIiOFQiCJIiUgHyAkfCIffCIkIBiFQiiJIhggIHx8IiB8IB\
J8IiwgHCAfIBeFQgGJIhd8IBR8IhwgJ4VCIIkiHyAjICZ8IiN8IiYgF4VCKIkiFyAcfCAqfCIcIB+F\
QjCJIh+FQiCJIicgCSAHICMgFoVCAYkiFiAdfHwiHSAehUIgiSIeIC98IiMgFoVCKIkiFiAdfHwiHS\
AehUIwiSIeICN8IiN8Ii8gGYVCKIkiGSAsfCAVfCIsICeFQjCJIicgL3wiLyAZhUIBiSIZIAggDyAt\
ICMgFoVCAYkiFnx8IiMgICAlhUIwiSIghUIgiSIlIB8gJnwiH3wiJiAWhUIoiSIWICN8fCIjfHwiLS\
AGIB8gF4VCAYkiFyAdfCATfCIdIC6FQiCJIh8gICAkfCIgfCIkIBeFQiiJIhcgHXx8Ih0gH4VCMIki\
H4VCIIkiLiAKICAgGIVCAYkiGCAcfCACfCIcIB6FQiCJIh4gK3wiICAYhUIoiSIYIBx8fCIcIB6FQj\
CJIh4gIHwiIHwiKyAZhUIoiSIZIC18fCItIC6FQjCJIi4gK3wiKyAZhUIBiSIZICwgICAYhUIBiSIY\
fCATfCIgICMgJYVCMIkiI4VCIIkiJSAfICR8Ih98IiQgGIVCKIkiGCAgfCASfCIgfHwiLCAHIBwgHy\
AXhUIBiSIXfCACfCIcICeFQiCJIh8gIyAmfCIjfCImIBeFQiiJIhcgHHx8IhwgH4VCMIkiH4VCIIki\
JyAJICMgFoVCAYkiFiAdfHwiHSAehUIgiSIeIC98IiMgFoVCKIkiFiAdfCAVfCIdIB6FQjCJIh4gI3\
wiI3wiLyAZhUIoiSIZICx8fCIsICeFQjCJIicgL3wiLyAZhUIBiSIZIA0gLSAjIBaFQgGJIhZ8IBR8\
IiMgICAlhUIwiSIghUIgiSIlIB8gJnwiH3wiJiAWhUIoiSIWICN8fCIjfHwiLSAOIB8gF4VCAYkiFy\
AdfHwiHSAuhUIgiSIfICAgJHwiIHwiJCAXhUIoiSIXIB18ICp8Ih0gH4VCMIkiH4VCIIkiLiAMIAsg\
ICAYhUIBiSIYIBx8fCIcIB6FQiCJIh4gK3wiICAYhUIoiSIYIBx8fCIcIB6FQjCJIh4gIHwiIHwiKy\
AZhUIoiSIZIC18IBR8Ii0gLoVCMIkiLiArfCIrIBmFQgGJIhkgCyAsICAgGIVCAYkiGHwgFXwiICAj\
ICWFQjCJIiOFQiCJIiUgHyAkfCIffCIkIBiFQiiJIhggIHx8IiB8fCIsIAogBiAcIB8gF4VCAYkiF3\
x8IhwgJ4VCIIkiHyAjICZ8IiN8IiYgF4VCKIkiFyAcfHwiHCAfhUIwiSIfhUIgiSInIAwgIyAWhUIB\
iSIWIB18IBN8Ih0gHoVCIIkiHiAvfCIjIBaFQiiJIhYgHXx8Ih0gHoVCMIkiHiAjfCIjfCIvIBmFQi\
iJIhkgLHx8IiwgJ4VCMIkiJyAvfCIvIBmFQgGJIhkgCSAtICMgFoVCAYkiFnwgKnwiIyAgICWFQjCJ\
IiCFQiCJIiUgHyAmfCIffCImIBaFQiiJIhYgI3x8IiN8IBJ8Ii0gDSAfIBeFQgGJIhcgHXwgEnwiHS\
AuhUIgiSIfICAgJHwiIHwiJCAXhUIoiSIXIB18fCIdIB+FQjCJIh+FQiCJIi4gByAgIBiFQgGJIhgg\
HHx8IhwgHoVCIIkiHiArfCIgIBiFQiiJIhggHHwgAnwiHCAehUIwiSIeICB8IiB8IisgGYVCKIkiGS\
AtfHwiLSAuhUIwiSIuICt8IisgGYVCAYkiGSANIA4gLCAgIBiFQgGJIhh8fCIgICMgJYVCMIkiI4VC\
IIkiJSAfICR8Ih98IiQgGIVCKIkiGCAgfHwiIHx8IiwgDyAcIB8gF4VCAYkiF3wgKnwiHCAnhUIgiS\
IfICMgJnwiI3wiJiAXhUIoiSIXIBx8fCIcIB+FQjCJIh+FQiCJIicgDCAjIBaFQgGJIhYgHXx8Ih0g\
HoVCIIkiHiAvfCIjIBaFQiiJIhYgHXwgAnwiHSAehUIwiSIeICN8IiN8Ii8gGYVCKIkiGSAsfCATfC\
IsICeFQjCJIicgL3wiLyAZhUIBiSIZIAsgCCAtICMgFoVCAYkiFnx8IiMgICAlhUIwiSIghUIgiSIl\
IB8gJnwiH3wiJiAWhUIoiSIWICN8fCIjfCAUfCItIAcgHyAXhUIBiSIXIB18IBV8Ih0gLoVCIIkiHy\
AgICR8IiB8IiQgF4VCKIkiFyAdfHwiHSAfhUIwiSIfhUIgiSIuIAYgICAYhUIBiSIYIBx8fCIcIB6F\
QiCJIh4gK3wiICAYhUIoiSIYIBx8IBR8IhwgHoVCMIkiHiAgfCIgfCIrIBmFQiiJIhkgLXx8Ii0gLo\
VCMIkiLiArfCIrIBmFQgGJIhkgDCAsICAgGIVCAYkiGHx8IiAgIyAlhUIwiSIjhUIgiSIlIB8gJHwi\
H3wiJCAYhUIoiSIYICB8ICp8IiB8fCIsIA4gByAcIB8gF4VCAYkiF3x8IhwgJ4VCIIkiHyAjICZ8Ii\
N8IiYgF4VCKIkiFyAcfHwiHCAfhUIwiSIfhUIgiSInIAsgDSAjIBaFQgGJIhYgHXx8Ih0gHoVCIIki\
HiAvfCIjIBaFQiiJIhYgHXx8Ih0gHoVCMIkiHiAjfCIjfCIvIBmFQiiJIhkgLHx8IiwgDyAgICWFQj\
CJIiAgJHwiJCAYhUIBiSIYIBx8fCIcIB6FQiCJIh4gK3wiJSAYhUIoiSIYIBx8IBJ8IhwgHoVCMIki\
HiAlfCIlIBiFQgGJIhh8fCIrIAogLSAjIBaFQgGJIhZ8IBN8IiMgIIVCIIkiICAfICZ8Ih98IiYgFo\
VCKIkiFiAjfHwiIyAghUIwiSIghUIgiSItIB8gF4VCAYkiFyAdfCACfCIdIC6FQiCJIh8gJHwiJCAX\
hUIoiSIXIB18IBV8Ih0gH4VCMIkiHyAkfCIkfCIuIBiFQiiJIhggK3wgFHwiKyAthUIwiSItIC58Ii\
4gGIVCAYkiGCAJIA4gHCAkIBeFQgGJIhd8fCIcICwgJ4VCMIkiJIVCIIkiJyAgICZ8IiB8IiYgF4VC\
KIkiFyAcfHwiHHx8IiwgDyAGICAgFoVCAYkiFiAdfHwiHSAehUIgiSIeICQgL3wiIHwiJCAWhUIoiS\
IWIB18fCIdIB6FQjCJIh6FQiCJIi8gCCAgIBmFQgGJIhkgI3wgFXwiICAfhUIgiSIfICV8IiMgGYVC\
KIkiGSAgfHwiICAfhUIwiSIfICN8IiN8IiUgGIVCKIkiGCAsfHwiLCAMIBwgJ4VCMIkiHCAmfCImIB\
eFQgGJIhcgHXx8Ih0gH4VCIIkiHyAufCInIBeFQiiJIhcgHXwgE3wiHSAfhUIwiSIfICd8IicgF4VC\
AYkiF3x8Ii4gIyAZhUIBiSIZICt8ICp8IiMgHIVCIIkiHCAeICR8Ih58IiQgGYVCKIkiGSAjfCASfC\
IjIByFQjCJIhyFQiCJIisgCiAgIB4gFoVCAYkiFnx8Ih4gLYVCIIkiICAmfCImIBaFQiiJIhYgHnwg\
AnwiHiAghUIwiSIgICZ8IiZ8Ii0gF4VCKIkiFyAufCASfCIuICuFQjCJIisgLXwiLSAXhUIBiSIXIA\
ogJiAWhUIBiSIWIB18fCIdICwgL4VCMIkiJoVCIIkiLCAcICR8Ihx8IiQgFoVCKIkiFiAdfCATfCId\
fHwiLyAcIBmFQgGJIhkgHnwgKnwiHCAfhUIgiSIeICYgJXwiH3wiJSAZhUIoiSIZIBx8IAJ8IhwgHo\
VCMIkiHoVCIIkiJiAGIAcgIyAfIBiFQgGJIhh8fCIfICCFQiCJIiAgJ3wiIyAYhUIoiSIYIB98fCIf\
ICCFQjCJIiAgI3wiI3wiJyAXhUIoiSIXIC98fCIvIBV8IA0gHCAdICyFQjCJIh0gJHwiJCAWhUIBiS\
IWfHwiHCAghUIgiSIgIC18IiwgFoVCKIkiFiAcfCAVfCIcICCFQjCJIiAgLHwiLCAWhUIBiSIWfCIt\
ICp8IC0gDiAJICMgGIVCAYkiGCAufHwiIyAdhUIgiSIdIB4gJXwiHnwiJSAYhUIoiSIYICN8fCIjIB\
2FQjCJIh2FQiCJIi0gDCAeIBmFQgGJIhkgH3wgFHwiHiArhUIgiSIfICR8IiQgGYVCKIkiGSAefHwi\
HiAfhUIwiSIfICR8IiR8IisgFoVCKIkiFnwiLnwgLyAmhUIwiSImICd8IicgF4VCAYkiFyATfCAjfC\
IjIBR8ICwgHyAjhUIgiSIffCIjIBeFQiiJIhd8IiwgH4VCMIkiHyAjfCIjIBeFQgGJIhd8Ii98IC8g\
ByAcIAZ8ICQgGYVCAYkiGXwiHHwgHCAmhUIgiSIcIB0gJXwiHXwiJCAZhUIoiSIZfCIlIByFQjCJIh\
yFQiCJIiYgHSAYhUIBiSIYIBJ8IB58Ih0gAnwgICAdhUIgiSIdICd8Ih4gGIVCKIkiGHwiICAdhUIw\
iSIdIB58Ih58IicgF4VCKIkiF3wiL3wgDyAlIA58IC4gLYVCMIkiDiArfCIlIBaFQgGJIhZ8Iit8IC\
sgHYVCIIkiHSAjfCIjIBaFQiiJIhZ8IisgHYVCMIkiHSAjfCIjIBaFQgGJIhZ8Ii18IC0gCyAsIAp8\
IB4gGIVCAYkiCnwiGHwgGCAOhUIgiSIOIBwgJHwiGHwiHCAKhUIoiSIKfCIeIA6FQjCJIg6FQiCJIi\
QgDSAgIAx8IBggGYVCAYkiGHwiGXwgGSAfhUIgiSIZICV8Ih8gGIVCKIkiGHwiICAZhUIwiSIZIB98\
Ih98IiUgFoVCKIkiFnwiLCAqfCAIIB4gEnwgLyAmhUIwiSISICd8IiogF4VCAYkiF3wiHnwgIyAZIB\
6FQiCJIgh8IhkgF4VCKIkiF3wiHiAIhUIwiSIIIBl8IhkgF4VCAYkiF3wiI3wgIyAGICsgDXwgHyAY\
hUIBiSIMfCINfCANIBKFQiCJIgYgDiAcfCINfCIOIAyFQiiJIgx8IhIgBoVCMIkiBoVCIIkiGCAPIC\
AgCXwgDSAKhUIBiSIJfCIKfCAdIAqFQiCJIgogKnwiDSAJhUIoiSIJfCIPIAqFQjCJIgogDXwiDXwi\
KiAXhUIoiSIXfCIcICmFIAcgDyALfCAGIA58IgYgDIVCAYkiC3wiDHwgDCAIhUIgiSIHICwgJIVCMI\
kiCCAlfCIMfCIOIAuFQiiJIgt8Ig8gB4VCMIkiByAOfCIOhTcDACAAICIgEyAeIBV8IA0gCYVCAYki\
CXwiDXwgDSAIhUIgiSIIIAZ8IgYgCYVCKIkiCXwiDYUgFCASIAJ8IAwgFoVCAYkiDHwiEnwgEiAKhU\
IgiSIKIBl8IhIgDIVCKIkiDHwiAiAKhUIwiSIKIBJ8IhKFNwMIIAEgECAcIBiFQjCJIhOFIA4gC4VC\
AYmFNwMAIAAgGyATICp8IguFIA+FNwMQIAAgKCANIAiFQjCJIgiFIBIgDIVCAYmFNwMgIAAgESAIIA\
Z8IgaFIAKFNwMYIAUgISALIBeFQgGJhSAHhTcDACAEIBogBiAJhUIBiYUgCoU3AwAgA0GAAWokAAur\
LQEhfyMAQcAAayICQRhqIgNCADcDACACQSBqIgRCADcDACACQThqIgVCADcDACACQTBqIgZCADcDAC\
ACQShqIgdCADcDACACQQhqIgggASkACDcDACACQRBqIgkgASkAEDcDACADIAEoABgiCjYCACAEIAEo\
ACAiAzYCACACIAEpAAA3AwAgAiABKAAcIgQ2AhwgAiABKAAkIgs2AiQgByABKAAoIgw2AgAgAiABKA\
AsIgc2AiwgBiABKAAwIg02AgAgAiABKAA0IgY2AjQgBSABKAA4Ig42AgAgAiABKAA8IgE2AjwgACAH\
IAwgAigCFCIFIAUgBiAMIAUgBCALIAMgCyAKIAQgByAKIAIoAgQiDyAAKAIQIhBqIAAoAggiEUEKdy\
ISIAAoAgQiE3MgESATcyAAKAIMIhRzIAAoAgAiFWogAigCACIWakELdyAQaiIXc2pBDncgFGoiGEEK\
dyIZaiAJKAIAIgkgE0EKdyIaaiAIKAIAIgggFGogFyAacyAYc2pBD3cgEmoiGyAZcyACKAIMIgIgEm\
ogGCAXQQp3IhdzIBtzakEMdyAaaiIYc2pBBXcgF2oiHCAYQQp3Ih1zIAUgF2ogGCAbQQp3IhdzIBxz\
akEIdyAZaiIYc2pBB3cgF2oiGUEKdyIbaiALIBxBCnciHGogFyAEaiAYIBxzIBlzakEJdyAdaiIXIB\
tzIB0gA2ogGSAYQQp3IhhzIBdzakELdyAcaiIZc2pBDXcgGGoiHCAZQQp3Ih1zIBggDGogGSAXQQp3\
IhdzIBxzakEOdyAbaiIYc2pBD3cgF2oiGUEKdyIbaiAdIAZqIBkgGEEKdyIecyAXIA1qIBggHEEKdy\
IXcyAZc2pBBncgHWoiGHNqQQd3IBdqIhlBCnciHCAeIAFqIBkgGEEKdyIdcyAXIA5qIBggG3MgGXNq\
QQl3IB5qIhlzakEIdyAbaiIXQX9zcWogFyAZcWpBmfOJ1AVqQQd3IB1qIhhBCnciG2ogBiAcaiAXQQ\
p3Ih4gCSAdaiAZQQp3IhkgGEF/c3FqIBggF3FqQZnzidQFakEGdyAcaiIXQX9zcWogFyAYcWpBmfOJ\
1AVqQQh3IBlqIhhBCnciHCAMIB5qIBdBCnciHSAPIBlqIBsgGEF/c3FqIBggF3FqQZnzidQFakENdy\
AeaiIXQX9zcWogFyAYcWpBmfOJ1AVqQQt3IBtqIhhBf3NxaiAYIBdxakGZ84nUBWpBCXcgHWoiGUEK\
dyIbaiACIBxqIBhBCnciHiABIB1qIBdBCnciHSAZQX9zcWogGSAYcWpBmfOJ1AVqQQd3IBxqIhdBf3\
NxaiAXIBlxakGZ84nUBWpBD3cgHWoiGEEKdyIcIBYgHmogF0EKdyIfIA0gHWogGyAYQX9zcWogGCAX\
cWpBmfOJ1AVqQQd3IB5qIhdBf3NxaiAXIBhxakGZ84nUBWpBDHcgG2oiGEF/c3FqIBggF3FqQZnzid\
QFakEPdyAfaiIZQQp3IhtqIAggHGogGEEKdyIdIAUgH2ogF0EKdyIeIBlBf3NxaiAZIBhxakGZ84nU\
BWpBCXcgHGoiF0F/c3FqIBcgGXFqQZnzidQFakELdyAeaiIYQQp3IhkgByAdaiAXQQp3IhwgDiAeai\
AbIBhBf3NxaiAYIBdxakGZ84nUBWpBB3cgHWoiF0F/c3FqIBcgGHFqQZnzidQFakENdyAbaiIYQX9z\
Ih5xaiAYIBdxakGZ84nUBWpBDHcgHGoiG0EKdyIdaiAJIBhBCnciGGogDiAXQQp3IhdqIAwgGWogAi\
AcaiAbIB5yIBdzakGh1+f2BmpBC3cgGWoiGSAbQX9zciAYc2pBodfn9gZqQQ13IBdqIhcgGUF/c3Ig\
HXNqQaHX5/YGakEGdyAYaiIYIBdBf3NyIBlBCnciGXNqQaHX5/YGakEHdyAdaiIbIBhBf3NyIBdBCn\
ciF3NqQaHX5/YGakEOdyAZaiIcQQp3Ih1qIAggG0EKdyIeaiAPIBhBCnciGGogAyAXaiABIBlqIBwg\
G0F/c3IgGHNqQaHX5/YGakEJdyAXaiIXIBxBf3NyIB5zakGh1+f2BmpBDXcgGGoiGCAXQX9zciAdc2\
pBodfn9gZqQQ93IB5qIhkgGEF/c3IgF0EKdyIXc2pBodfn9gZqQQ53IB1qIhsgGUF/c3IgGEEKdyIY\
c2pBodfn9gZqQQh3IBdqIhxBCnciHWogByAbQQp3Ih5qIAYgGUEKdyIZaiAKIBhqIBYgF2ogHCAbQX\
9zciAZc2pBodfn9gZqQQ13IBhqIhcgHEF/c3IgHnNqQaHX5/YGakEGdyAZaiIYIBdBf3NyIB1zakGh\
1+f2BmpBBXcgHmoiGSAYQX9zciAXQQp3IhtzakGh1+f2BmpBDHcgHWoiHCAZQX9zciAYQQp3Ihhzak\
Gh1+f2BmpBB3cgG2oiHUEKdyIXaiALIBlBCnciGWogDSAbaiAdIBxBf3NyIBlzakGh1+f2BmpBBXcg\
GGoiGyAXQX9zcWogDyAYaiAdIBxBCnciGEF/c3FqIBsgGHFqQdz57vh4akELdyAZaiIcIBdxakHc+e\
74eGpBDHcgGGoiHSAcQQp3IhlBf3NxaiAHIBhqIBwgG0EKdyIYQX9zcWogHSAYcWpB3Pnu+HhqQQ53\
IBdqIhwgGXFqQdz57vh4akEPdyAYaiIeQQp3IhdqIA0gHUEKdyIbaiAWIBhqIBwgG0F/c3FqIB4gG3\
FqQdz57vh4akEOdyAZaiIdIBdBf3NxaiADIBlqIB4gHEEKdyIYQX9zcWogHSAYcWpB3Pnu+HhqQQ93\
IBtqIhsgF3FqQdz57vh4akEJdyAYaiIcIBtBCnciGUF/c3FqIAkgGGogGyAdQQp3IhhBf3NxaiAcIB\
hxakHc+e74eGpBCHcgF2oiHSAZcWpB3Pnu+HhqQQl3IBhqIh5BCnciF2ogASAcQQp3IhtqIAIgGGog\
HSAbQX9zcWogHiAbcWpB3Pnu+HhqQQ53IBlqIhwgF0F/c3FqIAQgGWogHiAdQQp3IhhBf3NxaiAcIB\
hxakHc+e74eGpBBXcgG2oiGyAXcWpB3Pnu+HhqQQZ3IBhqIh0gG0EKdyIZQX9zcWogDiAYaiAbIBxB\
CnciGEF/c3FqIB0gGHFqQdz57vh4akEIdyAXaiIcIBlxakHc+e74eGpBBncgGGoiHkEKdyIfaiAWIB\
xBCnciF2ogCSAdQQp3IhtqIAggGWogHiAXQX9zcWogCiAYaiAcIBtBf3NxaiAeIBtxakHc+e74eGpB\
BXcgGWoiGCAXcWpB3Pnu+HhqQQx3IBtqIhkgGCAfQX9zcnNqQc76z8p6akEJdyAXaiIXIBkgGEEKdy\
IYQX9zcnNqQc76z8p6akEPdyAfaiIbIBcgGUEKdyIZQX9zcnNqQc76z8p6akEFdyAYaiIcQQp3Ih1q\
IAggG0EKdyIeaiANIBdBCnciF2ogBCAZaiALIBhqIBwgGyAXQX9zcnNqQc76z8p6akELdyAZaiIYIB\
wgHkF/c3JzakHO+s/KempBBncgF2oiFyAYIB1Bf3Nyc2pBzvrPynpqQQh3IB5qIhkgFyAYQQp3IhhB\
f3Nyc2pBzvrPynpqQQ13IB1qIhsgGSAXQQp3IhdBf3Nyc2pBzvrPynpqQQx3IBhqIhxBCnciHWogAy\
AbQQp3Ih5qIAIgGUEKdyIZaiAPIBdqIA4gGGogHCAbIBlBf3Nyc2pBzvrPynpqQQV3IBdqIhcgHCAe\
QX9zcnNqQc76z8p6akEMdyAZaiIYIBcgHUF/c3JzakHO+s/KempBDXcgHmoiGSAYIBdBCnciG0F/c3\
JzakHO+s/KempBDncgHWoiHCAZIBhBCnciGEF/c3JzakHO+s/KempBC3cgG2oiHUEKdyIgIBRqIA4g\
AyABIAsgFiAJIBYgByACIA8gASAWIA0gASAIIBUgESAUQX9zciATc2ogBWpB5peKhQVqQQh3IBBqIh\
dBCnciHmogGiALaiASIBZqIBQgBGogDiAQIBcgEyASQX9zcnNqakHml4qFBWpBCXcgFGoiFCAXIBpB\
f3Nyc2pB5peKhQVqQQl3IBJqIhIgFCAeQX9zcnNqQeaXioUFakELdyAaaiIaIBIgFEEKdyIUQX9zcn\
NqQeaXioUFakENdyAeaiIXIBogEkEKdyISQX9zcnNqQeaXioUFakEPdyAUaiIeQQp3Ih9qIAogF0EK\
dyIhaiAGIBpBCnciGmogCSASaiAHIBRqIB4gFyAaQX9zcnNqQeaXioUFakEPdyASaiIUIB4gIUF/c3\
JzakHml4qFBWpBBXcgGmoiEiAUIB9Bf3Nyc2pB5peKhQVqQQd3ICFqIhogEiAUQQp3IhRBf3Nyc2pB\
5peKhQVqQQd3IB9qIhcgGiASQQp3IhJBf3Nyc2pB5peKhQVqQQh3IBRqIh5BCnciH2ogAiAXQQp3Ii\
FqIAwgGkEKdyIaaiAPIBJqIAMgFGogHiAXIBpBf3Nyc2pB5peKhQVqQQt3IBJqIhQgHiAhQX9zcnNq\
QeaXioUFakEOdyAaaiISIBQgH0F/c3JzakHml4qFBWpBDncgIWoiGiASIBRBCnciF0F/c3JzakHml4\
qFBWpBDHcgH2oiHiAaIBJBCnciH0F/c3JzakHml4qFBWpBBncgF2oiIUEKdyIUaiACIBpBCnciEmog\
CiAXaiAeIBJBf3NxaiAhIBJxakGkorfiBWpBCXcgH2oiFyAUQX9zcWogByAfaiAhIB5BCnciGkF/c3\
FqIBcgGnFqQaSit+IFakENdyASaiIeIBRxakGkorfiBWpBD3cgGmoiHyAeQQp3IhJBf3NxaiAEIBpq\
IB4gF0EKdyIaQX9zcWogHyAacWpBpKK34gVqQQd3IBRqIh4gEnFqQaSit+IFakEMdyAaaiIhQQp3Ih\
RqIAwgH0EKdyIXaiAGIBpqIB4gF0F/c3FqICEgF3FqQaSit+IFakEIdyASaiIfIBRBf3NxaiAFIBJq\
ICEgHkEKdyISQX9zcWogHyAScWpBpKK34gVqQQl3IBdqIhcgFHFqQaSit+IFakELdyASaiIeIBdBCn\
ciGkF/c3FqIA4gEmogFyAfQQp3IhJBf3NxaiAeIBJxakGkorfiBWpBB3cgFGoiHyAacWpBpKK34gVq\
QQd3IBJqIiFBCnciFGogCSAeQQp3IhdqIAMgEmogHyAXQX9zcWogISAXcWpBpKK34gVqQQx3IBpqIh\
4gFEF/c3FqIA0gGmogISAfQQp3IhJBf3NxaiAeIBJxakGkorfiBWpBB3cgF2oiFyAUcWpBpKK34gVq\
QQZ3IBJqIh8gF0EKdyIaQX9zcWogCyASaiAXIB5BCnciEkF/c3FqIB8gEnFqQaSit+IFakEPdyAUai\
IXIBpxakGkorfiBWpBDXcgEmoiHkEKdyIhaiAPIBdBCnciImogBSAfQQp3IhRqIAEgGmogCCASaiAX\
IBRBf3NxaiAeIBRxakGkorfiBWpBC3cgGmoiEiAeQX9zciAic2pB8/3A6wZqQQl3IBRqIhQgEkF/c3\
IgIXNqQfP9wOsGakEHdyAiaiIaIBRBf3NyIBJBCnciEnNqQfP9wOsGakEPdyAhaiIXIBpBf3NyIBRB\
CnciFHNqQfP9wOsGakELdyASaiIeQQp3Ih9qIAsgF0EKdyIhaiAKIBpBCnciGmogDiAUaiAEIBJqIB\
4gF0F/c3IgGnNqQfP9wOsGakEIdyAUaiIUIB5Bf3NyICFzakHz/cDrBmpBBncgGmoiEiAUQX9zciAf\
c2pB8/3A6wZqQQZ3ICFqIhogEkF/c3IgFEEKdyIUc2pB8/3A6wZqQQ53IB9qIhcgGkF/c3IgEkEKdy\
ISc2pB8/3A6wZqQQx3IBRqIh5BCnciH2ogDCAXQQp3IiFqIAggGkEKdyIaaiANIBJqIAMgFGogHiAX\
QX9zciAac2pB8/3A6wZqQQ13IBJqIhQgHkF/c3IgIXNqQfP9wOsGakEFdyAaaiISIBRBf3NyIB9zak\
Hz/cDrBmpBDncgIWoiGiASQX9zciAUQQp3IhRzakHz/cDrBmpBDXcgH2oiFyAaQX9zciASQQp3IhJz\
akHz/cDrBmpBDXcgFGoiHkEKdyIfaiAGIBJqIAkgFGogHiAXQX9zciAaQQp3IhpzakHz/cDrBmpBB3\
cgEmoiEiAeQX9zciAXQQp3IhdzakHz/cDrBmpBBXcgGmoiFEEKdyIeIAogF2ogEkEKdyIhIAMgGmog\
HyAUQX9zcWogFCAScWpB6e210wdqQQ93IBdqIhJBf3NxaiASIBRxakHp7bXTB2pBBXcgH2oiFEF/c3\
FqIBQgEnFqQenttdMHakEIdyAhaiIaQQp3IhdqIAIgHmogFEEKdyIfIA8gIWogEkEKdyIhIBpBf3Nx\
aiAaIBRxakHp7bXTB2pBC3cgHmoiFEF/c3FqIBQgGnFqQenttdMHakEOdyAhaiISQQp3Ih4gASAfai\
AUQQp3IiIgByAhaiAXIBJBf3NxaiASIBRxakHp7bXTB2pBDncgH2oiFEF/c3FqIBQgEnFqQenttdMH\
akEGdyAXaiISQX9zcWogEiAUcWpB6e210wdqQQ53ICJqIhpBCnciF2ogDSAeaiASQQp3Ih8gBSAiai\
AUQQp3IiEgGkF/c3FqIBogEnFqQenttdMHakEGdyAeaiIUQX9zcWogFCAacWpB6e210wdqQQl3ICFq\
IhJBCnciHiAGIB9qIBRBCnciIiAIICFqIBcgEkF/c3FqIBIgFHFqQenttdMHakEMdyAfaiIUQX9zcW\
ogFCAScWpB6e210wdqQQl3IBdqIhJBf3NxaiASIBRxakHp7bXTB2pBDHcgImoiGkEKdyIXaiAOIBRB\
CnciH2ogFyAMIB5qIBJBCnciISAEICJqIB8gGkF/c3FqIBogEnFqQenttdMHakEFdyAeaiIUQX9zcW\
ogFCAacWpB6e210wdqQQ93IB9qIhJBf3NxaiASIBRxakHp7bXTB2pBCHcgIWoiGiASQQp3Ih5zICEg\
DWogEiAUQQp3Ig1zIBpzakEIdyAXaiIUc2pBBXcgDWoiEkEKdyIXaiAaQQp3IgMgD2ogDSAMaiAUIA\
NzIBJzakEMdyAeaiIMIBdzIB4gCWogEiAUQQp3Ig1zIAxzakEJdyADaiIDc2pBDHcgDWoiDyADQQp3\
IglzIA0gBWogAyAMQQp3IgxzIA9zakEFdyAXaiIDc2pBDncgDGoiDUEKdyIFaiAPQQp3Ig4gCGogDC\
AEaiADIA5zIA1zakEGdyAJaiIEIAVzIAkgCmogDSADQQp3IgNzIARzakEIdyAOaiIMc2pBDXcgA2oi\
DSAMQQp3Ig5zIAMgBmogDCAEQQp3IgNzIA1zakEGdyAFaiIEc2pBBXcgA2oiDEEKdyIFajYCCCAAIB\
EgCiAbaiAdIBwgGUEKdyIKQX9zcnNqQc76z8p6akEIdyAYaiIPQQp3aiADIBZqIAQgDUEKdyIDcyAM\
c2pBD3cgDmoiDUEKdyIWajYCBCAAIBMgASAYaiAPIB0gHEEKdyIBQX9zcnNqQc76z8p6akEFdyAKai\
IJaiAOIAJqIAwgBEEKdyICcyANc2pBDXcgA2oiBEEKd2o2AgAgACABIBVqIAYgCmogCSAPICBBf3Ny\
c2pBzvrPynpqQQZ3aiADIAtqIA0gBXMgBHNqQQt3IAJqIgpqNgIQIAAgASAQaiAFaiACIAdqIAQgFn\
MgCnNqQQt3ajYCDAuEKAIwfwF+IwBBwABrIgNBGGoiBEIANwMAIANBIGoiBUIANwMAIANBOGoiBkIA\
NwMAIANBMGoiB0IANwMAIANBKGoiCEIANwMAIANBCGoiCSABKQAINwMAIANBEGoiCiABKQAQNwMAIA\
QgASgAGCILNgIAIAUgASgAICIENgIAIAMgASkAADcDACADIAEoABwiBTYCHCADIAEoACQiDDYCJCAI\
IAEoACgiDTYCACADIAEoACwiCDYCLCAHIAEoADAiDjYCACADIAEoADQiBzYCNCAGIAEoADgiDzYCAC\
ADIAEoADwiATYCPCAAIAggASAEIAUgByAIIAsgBCAMIAwgDSAPIAEgBCAEIAsgASANIA8gCCAFIAcg\
ASAFIAggCyAHIAcgDiAFIAsgAEEkaiIQKAIAIhEgAEEUaiISKAIAIhNqaiIGQZmag98Fc0EQdyIUQb\
rqv6p6aiIVIBFzQRR3IhYgBmpqIhcgFHNBGHciGCAVaiIZIBZzQRl3IhogAEEgaiIbKAIAIhUgAEEQ\
aiIcKAIAIh1qIAooAgAiBmoiCiACc0Grs4/8AXNBEHciHkHy5rvjA2oiHyAVc0EUdyIgIApqIAMoAh\
QiAmoiIWpqIiIgAEEcaiIjKAIAIhYgAEEMaiIkKAIAIiVqIAkoAgAiCWoiCiAAKQMAIjNCIIinc0GM\
0ZXYeXNBEHciFEGF3Z7be2oiJiAWc0EUdyInIApqIAMoAgwiCmoiKCAUc0EYdyIpc0EQdyIqIABBGG\
oiKygCACIsIAAoAggiLWogAygCACIUaiIuIDOnc0H/pLmIBXNBEHciL0HnzKfQBmoiMCAsc0EUdyIx\
IC5qIAMoAgQiA2oiLiAvc0EYdyIvIDBqIjBqIjIgGnNBFHciGiAiamoiIiAqc0EYdyIqIDJqIjIgGn\
NBGXciGiABIA8gFyAwIDFzQRl3IjBqaiIXICEgHnNBGHciHnNBEHciISApICZqIiZqIikgMHNBFHci\
MCAXamoiF2pqIjEgDCAEICYgJ3NBGXciJiAuamoiJyAYc0EQdyIYIB4gH2oiHmoiHyAmc0EUdyImIC\
dqaiInIBhzQRh3IhhzQRB3Ii4gCCANIB4gIHNBGXciHiAoamoiICAvc0EQdyIoIBlqIhkgHnNBFHci\
HiAgamoiICAoc0EYdyIoIBlqIhlqIi8gGnNBFHciGiAxamoiMSAuc0EYdyIuIC9qIi8gGnNBGXciGi\
ABIAwgIiAZIB5zQRl3IhlqaiIeIBcgIXNBGHciF3NBEHciISAYIB9qIhhqIh8gGXNBFHciGSAeamoi\
HmpqIiIgBCAgIBggJnNBGXciGGogBmoiICAqc0EQdyImIBcgKWoiF2oiKSAYc0EUdyIYICBqaiIgIC\
ZzQRh3IiZzQRB3IiogDSAPIBcgMHNBGXciFyAnamoiJyAoc0EQdyIoIDJqIjAgF3NBFHciFyAnamoi\
JyAoc0EYdyIoIDBqIjBqIjIgGnNBFHciGiAiamoiIiAqc0EYdyIqIDJqIjIgGnNBGXciGiAxIDAgF3\
NBGXciF2ogAmoiMCAeICFzQRh3Ih5zQRB3IiEgJiApaiImaiIpIBdzQRR3IhcgMGogCmoiMGpqIjEg\
DiAmIBhzQRl3IhggJ2ogA2oiJiAuc0EQdyInIB4gH2oiHmoiHyAYc0EUdyIYICZqaiImICdzQRh3Ii\
dzQRB3Ii4gHiAZc0EZdyIZICBqIBRqIh4gKHNBEHciICAvaiIoIBlzQRR3IhkgHmogCWoiHiAgc0EY\
dyIgIChqIihqIi8gGnNBFHciGiAxamoiMSAuc0EYdyIuIC9qIi8gGnNBGXciGiAiICggGXNBGXciGW\
ogAmoiIiAwICFzQRh3IiFzQRB3IiggJyAfaiIfaiInIBlzQRR3IhkgImogCWoiImpqIjAgDiAeIB8g\
GHNBGXciGGpqIh4gKnNBEHciHyAhIClqIiFqIikgGHNBFHciGCAeaiAUaiIeIB9zQRh3Ih9zQRB3Ii\
ogBCAIICEgF3NBGXciFyAmamoiISAgc0EQdyIgIDJqIiYgF3NBFHciFyAhamoiISAgc0EYdyIgICZq\
IiZqIjIgGnNBFHciGiAwaiADaiIwICpzQRh3IiogMmoiMiAac0EZdyIaIAwgMSAmIBdzQRl3Ihdqai\
ImICIgKHNBGHciInNBEHciKCAfIClqIh9qIikgF3NBFHciFyAmaiAGaiImamoiMSAPIA0gHyAYc0EZ\
dyIYICFqaiIfIC5zQRB3IiEgIiAnaiIiaiInIBhzQRR3IhggH2pqIh8gIXNBGHciIXNBEHciLiALIC\
IgGXNBGXciGSAeaiAKaiIeICBzQRB3IiAgL2oiIiAZc0EUdyIZIB5qaiIeICBzQRh3IiAgImoiImoi\
LyAac0EUdyIaIDFqaiIxIC5zQRh3Ii4gL2oiLyAac0EZdyIaIA4gByAwICIgGXNBGXciGWpqIiIgJi\
Aoc0EYdyImc0EQdyIoICEgJ2oiIWoiJyAZc0EUdyIZICJqaiIiaiAGaiIwIB4gISAYc0EZdyIYaiAK\
aiIeICpzQRB3IiEgJiApaiImaiIpIBhzQRR3IhggHmogA2oiHiAhc0EYdyIhc0EQdyIqIAwgBSAmIB\
dzQRl3IhcgH2pqIh8gIHNBEHciICAyaiImIBdzQRR3IhcgH2pqIh8gIHNBGHciICAmaiImaiIyIBpz\
QRR3IhogMGogFGoiMCAqc0EYdyIqIDJqIjIgGnNBGXciGiAEIAEgMSAmIBdzQRl3IhdqaiImICIgKH\
NBGHciInNBEHciKCAhIClqIiFqIikgF3NBFHciFyAmamoiJmpqIjEgCyAhIBhzQRl3IhggH2ogCWoi\
HyAuc0EQdyIhICIgJ2oiImoiJyAYc0EUdyIYIB9qaiIfICFzQRh3IiFzQRB3Ii4gDSAiIBlzQRl3Ih\
kgHmogAmoiHiAgc0EQdyIgIC9qIiIgGXNBFHciGSAeamoiHiAgc0EYdyIgICJqIiJqIi8gGnNBFHci\
GiAxamoiMSAuc0EYdyIuIC9qIi8gGnNBGXciGiAwICIgGXNBGXciGWogCWoiIiAmIChzQRh3IiZzQR\
B3IiggISAnaiIhaiInIBlzQRR3IhkgImogBmoiImpqIjAgBSAeICEgGHNBGXciGGogAmoiHiAqc0EQ\
dyIhICYgKWoiJmoiKSAYc0EUdyIYIB5qaiIeICFzQRh3IiFzQRB3IiogDCAmIBdzQRl3IhcgH2pqIh\
8gIHNBEHciICAyaiImIBdzQRR3IhcgH2ogFGoiHyAgc0EYdyIgICZqIiZqIjIgGnNBFHciGiAwamoi\
MCAqc0EYdyIqIDJqIjIgGnNBGXciGiAHIDEgJiAXc0EZdyIXaiAKaiImICIgKHNBGHciInNBEHciKC\
AhIClqIiFqIikgF3NBFHciFyAmamoiJmpqIjEgDyAhIBhzQRl3IhggH2pqIh8gLnNBEHciISAiICdq\
IiJqIicgGHNBFHciGCAfaiADaiIfICFzQRh3IiFzQRB3Ii4gDiAIICIgGXNBGXciGSAeamoiHiAgc0\
EQdyIgIC9qIiIgGXNBFHciGSAeamoiHiAgc0EYdyIgICJqIiJqIi8gGnNBFHciGiAxaiAKaiIxIC5z\
QRh3Ii4gL2oiLyAac0EZdyIaIAggMCAiIBlzQRl3IhlqIBRqIiIgJiAoc0EYdyImc0EQdyIoICEgJ2\
oiIWoiJyAZc0EUdyIZICJqaiIiamoiMCANIAsgHiAhIBhzQRl3IhhqaiIeICpzQRB3IiEgJiApaiIm\
aiIpIBhzQRR3IhggHmpqIh4gIXNBGHciIXNBEHciKiAOICYgF3NBGXciFyAfaiAJaiIfICBzQRB3Ii\
AgMmoiJiAXc0EUdyIXIB9qaiIfICBzQRh3IiAgJmoiJmoiMiAac0EUdyIaIDBqaiIwICpzQRh3Iiog\
MmoiMiAac0EZdyIaIAwgMSAmIBdzQRl3IhdqIANqIiYgIiAoc0EYdyIic0EQdyIoICEgKWoiIWoiKS\
AXc0EUdyIXICZqaiImaiAGaiIxIAcgISAYc0EZdyIYIB9qIAZqIh8gLnNBEHciISAiICdqIiJqIicg\
GHNBFHciGCAfamoiHyAhc0EYdyIhc0EQdyIuIAUgIiAZc0EZdyIZIB5qaiIeICBzQRB3IiAgL2oiIi\
AZc0EUdyIZIB5qIAJqIh4gIHNBGHciICAiaiIiaiIvIBpzQRR3IhogMWpqIjEgLnNBGHciLiAvaiIv\
IBpzQRl3IhogByAPIDAgIiAZc0EZdyIZamoiIiAmIChzQRh3IiZzQRB3IiggISAnaiIhaiInIBlzQR\
R3IhkgImpqIiJqaiIwIAEgHiAhIBhzQRl3IhhqIANqIh4gKnNBEHciISAmIClqIiZqIikgGHNBFHci\
GCAeamoiHiAhc0EYdyIhc0EQdyIqIA4gJiAXc0EZdyIXIB9qaiIfICBzQRB3IiAgMmoiJiAXc0EUdy\
IXIB9qIAJqIh8gIHNBGHciICAmaiImaiIyIBpzQRR3IhogMGogCWoiMCAqc0EYdyIqIDJqIjIgGnNB\
GXciGiAIIAQgMSAmIBdzQRl3IhdqaiImICIgKHNBGHciInNBEHciKCAhIClqIiFqIikgF3NBFHciFy\
AmamoiJmogCmoiMSAFICEgGHNBGXciGCAfaiAUaiIfIC5zQRB3IiEgIiAnaiIiaiInIBhzQRR3Ihgg\
H2pqIh8gIXNBGHciIXNBEHciLiALICIgGXNBGXciGSAeamoiHiAgc0EQdyIgIC9qIiIgGXNBFHciGS\
AeaiAKaiIeICBzQRh3IiAgImoiImoiLyAac0EUdyIaIDFqaiIxIC5zQRh3Ii4gL2oiLyAac0EZdyIa\
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\
AhQgAyABQRxqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIKNgIcIAMgAUEgai\
gAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiCzYCICADIAFBGGooAAAiAkEYdCAC\
QQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIgw2AhggAygCACENIAMoAgQhDiADKAIIIQ8gAygCEC\
EQIAMoAgwhESADKAIUIRIgAyABQSRqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZy\
ciITNgIkIAMgAUEoaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiFDYCKCADIA\
FBMGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIhU2AjAgAyABQSxqKAAAIgJB\
GHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIWNgIsIAMgAUE0aigAACICQRh0IAJBCHRBgI\
D8B3FyIAJBCHZBgP4DcSACQRh2cnIiAjYCNCADIAFBOGooAAAiF0EYdCAXQQh0QYCA/AdxciAXQQh2\
QYD+A3EgF0EYdnJyIhc2AjggAyABQTxqKAAAIhhBGHQgGEEIdEGAgPwHcXIgGEEIdkGA/gNxIBhBGH\
ZyciIYNgI8IAggEyAKcyAYcyAMIBBzIBVzIBEgDnMgE3MgF3NBAXciGXNBAXciGnNBAXciGyAKIBJz\
IAJzIBAgD3MgFHMgGHNBAXciHHNBAXciHXMgGCACcyAdcyAVIBRzIBxzIBtzQQF3Ih5zQQF3Ih9zIB\
ogHHMgHnMgGSAYcyAbcyAXIBVzIBpzIBYgE3MgGXMgCyAMcyAXcyASIBFzIBZzIA8gDXMgC3MgAnNB\
AXciIHNBAXciIXNBAXciInNBAXciI3NBAXciJHNBAXciJXNBAXciJnNBAXciJyAdICFzIAIgFnMgIX\
MgFCALcyAgcyAdc0EBdyIoc0EBdyIpcyAcICBzIChzIB9zQQF3IipzQQF3IitzIB8gKXMgK3MgHiAo\
cyAqcyAnc0EBdyIsc0EBdyItcyAmICpzICxzICUgH3MgJ3MgJCAecyAmcyAjIBtzICVzICIgGnMgJH\
MgISAZcyAjcyAgIBdzICJzIClzQQF3Ii5zQQF3Ii9zQQF3IjBzQQF3IjFzQQF3IjJzQQF3IjNzQQF3\
IjRzQQF3IjUgKyAvcyApICNzIC9zICggInMgLnMgK3NBAXciNnNBAXciN3MgKiAucyA2cyAtc0EBdy\
I4c0EBdyI5cyAtIDdzIDlzICwgNnMgOHMgNXNBAXciOnNBAXciO3MgNCA4cyA6cyAzIC1zIDVzIDIg\
LHMgNHMgMSAncyAzcyAwICZzIDJzIC8gJXMgMXMgLiAkcyAwcyA3c0EBdyI8c0EBdyI9c0EBdyI+c0\
EBdyI/c0EBdyJAc0EBdyJBc0EBdyJCc0EBdyJDIDkgPXMgNyAxcyA9cyA2IDBzIDxzIDlzQQF3IkRz\
QQF3IkVzIDggPHMgRHMgO3NBAXciRnNBAXciR3MgOyBFcyBHcyA6IERzIEZzIENzQQF3IkhzQQF3Ik\
lzIEIgRnMgSHMgQSA7cyBDcyBAIDpzIEJzID8gNXMgQXMgPiA0cyBAcyA9IDNzID9zIDwgMnMgPnMg\
RXNBAXciSnNBAXciS3NBAXciTHNBAXciTXNBAXciTnNBAXciT3NBAXciUHNBAXdqIEYgSnMgRCA+cy\
BKcyBHc0EBdyJRcyBJc0EBdyJSIEUgP3MgS3MgUXNBAXciUyBMIEEgOiA5IDwgMSAmIB8gKCAhIBcg\
EyAQIAhBHnciVGogDiAFIAdBHnciECAGcyAIcSAGc2pqIA0gBCAIQQV3aiAGIAVzIAdxIAVzampBmf\
OJ1AVqIg5BBXdqQZnzidQFaiJVQR53IgggDkEedyINcyAGIA9qIA4gVCAQc3EgEHNqIFVBBXdqQZnz\
idQFaiIOcSANc2ogECARaiBVIA0gVHNxIFRzaiAOQQV3akGZ84nUBWoiEEEFd2pBmfOJ1AVqIhFBHn\
ciD2ogDCAIaiARIBBBHnciEyAOQR53IgxzcSAMc2ogEiANaiAMIAhzIBBxIAhzaiARQQV3akGZ84nU\
BWoiEUEFd2pBmfOJ1AVqIhJBHnciCCARQR53IhBzIAogDGogESAPIBNzcSATc2ogEkEFd2pBmfOJ1A\
VqIgpxIBBzaiALIBNqIBAgD3MgEnEgD3NqIApBBXdqQZnzidQFaiIMQQV3akGZ84nUBWoiD0EedyIL\
aiAVIApBHnciF2ogCyAMQR53IhNzIBQgEGogDCAXIAhzcSAIc2ogD0EFd2pBmfOJ1AVqIhRxIBNzai\
AWIAhqIA8gEyAXc3EgF3NqIBRBBXdqQZnzidQFaiIVQQV3akGZ84nUBWoiFiAVQR53IhcgFEEedyII\
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\
IANBhYHAACAEEFNFDQYgA0GMgcAAIAQQUw0KQdgBEBciBEUNHCACQQA2AgAgAkEEckEAQYABEDwaIA\
JBgAE2AgAgAkGwAWogAkGEARA6GiAEQdAAaiACQbABakEEckGAARA6GiAEQcgAakIANwMAIARCADcD\
QCAEQQA6ANABIARBACkDsI5ANwMAIARBCGpBACkDuI5ANwMAIARBEGpBACkDwI5ANwMAIARBGGpBAC\
kDyI5ANwMAIARBIGpBACkD0I5ANwMAIARBKGpBACkD2I5ANwMAIARBMGpBACkD4I5ANwMAIARBOGpB\
ACkD6I5ANwMAQRQhBQwjC0HwABAXIgRFDQwgAkGwAWpBCGoQWCAEQSBqIAJB2AFqKQMANwMAIARBGG\
ogAkGwAWpBIGopAwA3AwAgBEEQaiACQbABakEYaikDADcDACAEQQhqIAJBsAFqQRBqKQMANwMAIAQg\
AikDuAE3AwAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCAC\
ACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOhogBEHgAGogAkGw\
AWpBPGopAgA3AAAgBEHYAGogAkGwAWpBNGopAgA3AAAgBEHQAGogAkGwAWpBLGopAgA3AAAgBEHIAG\
ogAkGwAWpBJGopAgA3AAAgBEHAAGogAkGwAWpBHGopAgA3AAAgBEE4aiACQbABakEUaikCADcAACAE\
QTBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ACggBEEAOgBoQQMhBQwiCwJAAkACQAJAIANBuoDAAE\
EKEFNFDQAgA0HEgMAAQQoQU0UNASADQc6AwABBChBTRQ0CIANB2IDAAEEKEFNFDQMgA0HogMAAQQoQ\
Uw0MQegAEBciBEUNFiACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsak\
IANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAEQdgA\
aiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbABakEsaikCADcAAC\
AEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAkGwAWpBFGopAgA3\
AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARCADcDACAEQQA6AGAgBEEAKQPYjUA3Aw\
ggBEEQakEAKQPgjUA3AwAgBEEYakEAKALojUA2AgBBCyEFDCULQeACEBciBEUNDyAEQQBByAEQPCEF\
IAJBADYCACACQQRyQQBBkAEQPBogAkGQATYCACACQbABaiACQZQBEDoaIAVByAFqIAJBsAFqQQRyQZ\
ABEDoaIAVBADoA2AJBBSEFDCQLQdgCEBciBEUNDyAEQQBByAEQPCEFIAJBADYCACACQQRyQQBBiAEQ\
PBogAkGIATYCACACQbABaiACQYwBEDoaIAVByAFqIAJBsAFqQQRyQYgBEDoaIAVBADoA0AJBBiEFDC\
MLQbgCEBciBEUNDyAEQQBByAEQPCEFIAJBADYCACACQQRyQQBB6AAQPBogAkHoADYCACACQbABaiAC\
QewAEDoaIAVByAFqIAJBsAFqQQRyQegAEDoaIAVBADoAsAJBByEFDCILQZgCEBciBEUNDyAEQQBByA\
EQPCEFIAJBADYCACACQQRyQQBByAAQPBogAkHIADYCACACQbABaiACQcwAEDoaIAVByAFqIAJBsAFq\
QQRyQcgAEDoaIAVBADoAkAJBCCEFDCELAkAgA0HigMAAQQMQU0UNACADQeWAwABBAxBTDQhB4AAQFy\
IERQ0RIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0\
akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDoaIARB0ABqIAJBsAFqQT\
xqKQIANwAAIARByABqIAJBsAFqQTRqKQIANwAAIARBwABqIAJBsAFqQSxqKQIANwAAIARBOGogAkGw\
AWpBJGopAgA3AAAgBEEwaiACQbABakEcaikCADcAACAEQShqIAJBsAFqQRRqKQIANwAAIARBIGogAk\
GwAWpBDGopAgA3AAAgBCACKQK0ATcAGCAEQv6568XpjpWZEDcDECAEQoHGlLqW8ermbzcDCCAEQgA3\
AwAgBEEAOgBYQQohBQwhC0HgABAXIgRFDQ8gAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAk\
EkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFq\
IAJBxAAQOhogBEHQAGogAkGwAWpBPGopAgA3AAAgBEHIAGogAkGwAWpBNGopAgA3AAAgBEHAAGogAk\
GwAWpBLGopAgA3AAAgBEE4aiACQbABakEkaikCADcAACAEQTBqIAJBsAFqQRxqKQIANwAAIARBKGog\
AkGwAWpBFGopAgA3AAAgBEEgaiACQbABakEMaikCADcAACAEIAIpArQBNwAYIARC/rnrxemOlZkQNw\
MQIARCgcaUupbx6uZvNwMIIARCADcDACAEQQA6AFhBCSEFDCALAkACQAJAAkAgAykAAELTkIWa08WM\
mTRRDQAgAykAAELTkIWa08XMmjZRDQEgAykAAELTkIWa0+WMnDRRDQIgAykAAELTkIWa06XNmDJRDQ\
MgAykAAELTkIXa1KiMmThRDQcgAykAAELTkIXa1MjMmjZSDQpB2AIQFyIERQ0eIARBAEHIARA8IQUg\
AkEANgIAIAJBBHJBAEGIARA8GiACQYgBNgIAIAJBsAFqIAJBjAEQOhogBUHIAWogAkGwAWpBBHJBiA\
EQOhogBUEAOgDQAkEWIQUMIwtB4AIQFyIERQ0UIARBAEHIARA8IQUgAkEANgIAIAJBBHJBAEGQARA8\
GiACQZABNgIAIAJBsAFqIAJBlAEQOhogBUHIAWogAkGwAWpBBHJBkAEQOhogBUEAOgDYAkENIQUMIg\
tB2AIQFyIERQ0UIARBAEHIARA8IQUgAkEANgIAIAJBBHJBAEGIARA8GiACQYgBNgIAIAJBsAFqIAJB\
jAEQOhogBUHIAWogAkGwAWpBBHJBiAEQOhogBUEAOgDQAkEOIQUMIQtBuAIQFyIERQ0UIARBAEHIAR\
A8IQUgAkEANgIAIAJBBHJBAEHoABA8GiACQegANgIAIAJBsAFqIAJB7AAQOhogBUHIAWogAkGwAWpB\
BHJB6AAQOhogBUEAOgCwAkEPIQUMIAtBmAIQFyIERQ0UIARBAEHIARA8IQUgAkEANgIAIAJBBHJBAE\
HIABA8GiACQcgANgIAIAJBsAFqIAJBzAAQOhogBUHIAWogAkGwAWpBBHJByAAQOhogBUEAOgCQAkEQ\
IQUMHwtB8AAQFyIERQ0UIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQS\
xqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDoaIARB\
4ABqIAJBsAFqQTxqKQIANwAAIARB2ABqIAJBsAFqQTRqKQIANwAAIARB0ABqIAJBsAFqQSxqKQIANw\
AAIARByABqIAJBsAFqQSRqKQIANwAAIARBwABqIAJBsAFqQRxqKQIANwAAIARBOGogAkGwAWpBFGop\
AgA3AAAgBEEwaiACQbABakEMaikCADcAACAEIAIpArQBNwAoIARCADcDACAEQQA6AGggBEEAKQOQjk\
A3AwggBEEQakEAKQOYjkA3AwAgBEEYakEAKQOgjkA3AwAgBEEgakEAKQOojkA3AwBBESEFDB4LQfAA\
EBciBEUNFCACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIA\
JBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAEQeAAaiACQbAB\
akE8aikCADcAACAEQdgAaiACQbABakE0aikCADcAACAEQdAAaiACQbABakEsaikCADcAACAEQcgAai\
ACQbABakEkaikCADcAACAEQcAAaiACQbABakEcaikCADcAACAEQThqIAJBsAFqQRRqKQIANwAAIARB\
MGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAKCAEQgA3AwAgBEEAOgBoIARBACkD8I1ANwMIIARBEG\
pBACkD+I1ANwMAIARBGGpBACkDgI5ANwMAIARBIGpBACkDiI5ANwMAQRIhBQwdC0HYARAXIgRFDRQg\
AkEANgIAIAJBBHJBAEGAARA8GiACQYABNgIAIAJBsAFqIAJBhAEQOhogBEHQAGogAkGwAWpBBHJBgA\
EQOhogBEHIAGpCADcDACAEQgA3A0AgBEEAOgDQASAEQQApA/COQDcDACAEQQhqQQApA/iOQDcDACAE\
QRBqQQApA4CPQDcDACAEQRhqQQApA4iPQDcDACAEQSBqQQApA5CPQDcDACAEQShqQQApA5iPQDcDAC\
AEQTBqQQApA6CPQDcDACAEQThqQQApA6iPQDcDAEETIQUMHAtB+AIQFyIERQ0VIARBAEHIARA8IQUg\
AkEANgIAIAJBBHJBAEGoARA8GiACQagBNgIAIAJBsAFqIAJBrAEQOhogBUHIAWogAkGwAWpBBHJBqA\
EQOhogBUEAOgDwAkEVIQUMGwsgA0HygMAAQQUQU0UNFyADQZOBwABBBRBTDQFB6AAQFyIERQ0WIARC\
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\
QEEAQaTVwAA2AqzVQEEAQbTVwAA2AsDVQEEAQazVwAA2ArTVQEEAQbzVwAA2AsjVQEEAQbTVwAA2Ar\
zVQEEAQcTVwAA2AtDVQEEAQbzVwAA2AsTVQEEAQQA2ArjYQEEAQczVwAA2AtjVQEEAQcTVwAA2AszV\
QEEAQczVwAA2AtTVQEEAQdTVwAA2AuDVQEEAQdTVwAA2AtzVQEEAQdzVwAA2AujVQEEAQdzVwAA2Au\
TVQEEAQeTVwAA2AvDVQEEAQeTVwAA2AuzVQEEAQezVwAA2AvjVQEEAQezVwAA2AvTVQEEAQfTVwAA2\
AoDWQEEAQfTVwAA2AvzVQEEAQfzVwAA2AojWQEEAQfzVwAA2AoTWQEEAQYTWwAA2ApDWQEEAQYTWwA\
A2AozWQEEAQYzWwAA2ApjWQEEAQZTWwAA2AqDWQEEAQYzWwAA2ApTWQEEAQZzWwAA2AqjWQEEAQZTW\
wAA2ApzWQEEAQaTWwAA2ArDWQEEAQZzWwAA2AqTWQEEAQazWwAA2ArjWQEEAQaTWwAA2AqzWQEEAQb\
TWwAA2AsDWQEEAQazWwAA2ArTWQEEAQbzWwAA2AsjWQEEAQbTWwAA2ArzWQEEAQcTWwAA2AtDWQEEA\
QbzWwAA2AsTWQEEAQczWwAA2AtjWQEEAQcTWwAA2AszWQEEAQdTWwAA2AuDWQEEAQczWwAA2AtTWQE\
EAQdzWwAA2AujWQEEAQdTWwAA2AtzWQEEAQeTWwAA2AvDWQEEAQdzWwAA2AuTWQEEAQezWwAA2AvjW\
QEEAQeTWwAA2AuzWQEEAQfTWwAA2AoDXQEEAQezWwAA2AvTWQEEAQfzWwAA2AojXQEEAQfTWwAA2Av\
zWQEEAQYTXwAA2ApDXQEEAQfzWwAA2AoTXQEEAIAY2AqDYQEEAQYTXwAA2AozXQEEAIAhBWGoiADYC\
mNhAIAYgAEEBcjYCBCAIIAZqQVxqQSg2AgBBAEGAgIABNgK82EALQQAhAUEAKAKY2EAiACACTQ0AQQ\
AgACACayIBNgKY2EBBAEEAKAKg2EAiACACaiIFNgKg2EAgBSABQQFyNgIEIAAgAkEDcjYCBCAAQQhq\
DwsgAQu5JQIDfx5+IwBBwABrIgNBOGpCADcDACADQTBqQgA3AwAgA0EoakIANwMAIANBIGpCADcDAC\
ADQRhqQgA3AwAgA0EQakIANwMAIANBCGpCADcDACADQgA3AwACQCACRQ0AIAEgAkEGdGohBCAAKQMQ\
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\
OGogA0E4aikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakEoaiADQShqKQMANwMAIAFBCGpBIG\
ogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBCGog\
A0EIaikDADcDACABIAMpAwA3AwggAykDQCEPIAFBCGpByABqIANByABqEEUgASAPNwNIIAIgAUEIak\
HQARA6GkEAIQMMHwsgAigCBCEDQdABEBciAkUNBiABQQhqQThqIANBOGopAwA3AwAgAUEIakEwaiAD\
QTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQR\
hqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgASADKQMANwMIIAMp\
A0AhDyABQQhqQcgAaiADQcgAahBFIAEgDzcDSCACIAFBCGpB0AEQOhpBASEDDB4LIAIoAgQhA0HQAR\
AXIgJFDQYgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQShqIANBKGop\
AwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBqIANBEGopAw\
A3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADKQNAIQ8gAUEIakHIAGogA0HIAGoQRSAB\
IA83A0ggAiABQQhqQdABEDoaQQIhAwwdCyACKAIEIQNB8AAQFyICRQ0GIAFBCGpBIGogA0EgaikDAD\
cDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8g\
AUEIakEoaiADQShqEDkgASAPNwMIIAIgAUEIakHwABA6GkEDIQMMHAsgAigCBCEDQfgOEBciAkUNBi\
ABQQhqQYgBaiADQYgBaikDADcDACABQQhqQYABaiADQYABaikDADcDACABQQhqQfgAaiADQfgAaikD\
ADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBIGogA0EgaikDAD\
cDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBwABqIANBwABqKQMA\
NwMAIAFBCGpByABqIANByABqKQMANwMAIAFBCGpB0ABqIANB0ABqKQMANwMAIAFBCGpB2ABqIANB2A\
BqKQMANwMAIAFBCGpB4ABqIANB4ABqKQMANwMAIAEgAykDcDcDeCABIAMpAwg3AxAgASADKQMoNwMw\
IAMpAwAhDyADLQBqIQQgAy0AaSEFIAMtAGghBgJAIAMoApABQQV0IgcNAEEAIQcMGwsgAUGAD2pBGG\
oiCCADQZQBaiIJQRhqKQAANwMAIAFBgA9qQRBqIgogCUEQaikAADcDACABQYAPakEIaiILIAlBCGop\
AAA3AwAgASAJKQAANwOADyADQdQBaiEJQQAgB0FgakEFdmshDCABQbwBaiEDQQIhBwNAIANBYGoiDS\
ABKQOADzcAACANQRhqIAgpAwA3AAAgDUEQaiAKKQMANwAAIA1BCGogCykDADcAAAJAAkAgDCAHaiIO\
QQJGDQAgCCAJQWBqIg1BGGopAAA3AwAgCiANQRBqKQAANwMAIAsgDUEIaikAADcDACABIA0pAAA3A4\
APIAdBOEcNARBsAAsgB0F/aiEHDBwLIAMgASkDgA83AAAgA0EYaiAIKQMANwAAIANBEGogCikDADcA\
ACADQQhqIAspAwA3AAAgDkEBRg0bIAggCUEYaikAADcDACAKIAlBEGopAAA3AwAgCyAJQQhqKQAANw\
MAIAEgCSkAADcDgA8gA0HAAGohAyAHQQJqIQcgCUHAAGohCQwACwsQcAALEHEAC0HQAUEIQQAoAvjU\
QCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQ\
AAC0HwAEEIQQAoAvjUQCIBQQQgARsRBQAAC0H4DkEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMC\
QEHoABAXIgJFDQAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABIAMpAwg3Ax\
AgAykDACEPIAFBCGpBIGogA0EgahA5IAEgDzcDCCACIAFBCGpB6AAQOhpBFyEDDBQLQegAQQhBACgC\
+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgCEBciAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0\
HIAWoQRiACIAFBCGpB2AIQOhpBFiEDDBMLQdgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJA\
QfgCEBciAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQRyACIAFBCGpB+AIQOhpBFSEDDB\
ILQfgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgBEBciAkUNACABQQhqQThqIANBOGop\
AwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAw\
A3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3\
AwAgASADKQMANwMIIANByABqKQMAIQ8gAykDQCEQIAFBCGpB0ABqIANB0ABqEEUgAUEIakHIAGogDz\
cDACABIBA3A0ggAiABQQhqQdgBEDoaQRQhAwwRC0HYAUEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIE\
IQMCQEHYARAXIgJFDQAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQS\
hqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBq\
IANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADQcgAaikDACEPIAMpA0AhEC\
ABQQhqQdAAaiADQdAAahBFIAFBCGpByABqIA83AwAgASAQNwNIIAIgAUEIakHYARA6GkETIQMMEAtB\
2AFBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB8AAQFyICRQ0AIAFBCGpBIGogA0EgaikDAD\
cDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8g\
AUEIakEoaiADQShqEDkgASAPNwMIIAIgAUEIakHwABA6GkESIQMMDwtB8ABBCEEAKAL41EAiAUEEIA\
EbEQUAAAsgAigCBCEDAkBB8AAQFyICRQ0AIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGop\
AwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8gAUEIakEoaiADQShqEDkgAS\
APNwMIIAIgAUEIakHwABA6GkERIQMMDgtB8ABBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB\
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\
AgAMAwsgAEEAQRkgA0EBdmtBH3EgA0EfRht0IQIDQCAFIAJBHXZBBHFqQRBqIgYoAgAiA0UNAiACQQ\
F0IQIgAyEFIAMoAgRBeHEgAEcNAAsLIAMoAggiACABNgIMIAMgATYCCCABQRhqQQA2AgAgASADNgIM\
IAEgADYCCAwCCyAGIAE2AgAgAUEYaiAFNgIACyABIAE2AgwgASABNgIIC0EAQQAoAsTYQEF/aiIBNg\
LE2EAgAQ0DQQAoArTYQCIADQFB/x8hAQwCCyAAQQN2IgNBA3RBjNXAAGohAAJAAkBBACgChNVAIgJB\
ASADdCIDcUUNACAAKAIIIQMMAQtBACACIANyNgKE1UAgACEDCyAAIAE2AgggAyABNgIMIAEgADYCDC\
ABIAM2AggPC0EAIQEDQCABQQFqIQEgACgCCCIADQALIAFB/x8gAUH/H0sbIQELQQAgATYCxNhADwsL\
lQwBGH8jACECIAAoAgAhAyAAKAIIIQQgACgCDCEFIAAoAgQhBiACQcAAayICQRhqIgdCADcDACACQS\
BqIghCADcDACACQThqIglCADcDACACQTBqIgpCADcDACACQShqIgtCADcDACACQQhqIgwgASkACDcD\
ACACQRBqIg0gASkAEDcDACAHIAEoABgiDjYCACAIIAEoACAiDzYCACACIAEpAAA3AwAgAiABKAAcIh\
A2AhwgAiABKAAkIhE2AiQgCyABKAAoIhI2AgAgAiABKAAsIgs2AiwgCiABKAAwIhM2AgAgAiABKAA0\
Igo2AjQgCSABKAA4IhQ2AgAgAiABKAA8IhU2AjwgACADIBMgCyASIBEgDyAQIA4gBiAEIAUgBiADIA\
YgBHFqIAUgBkF/c3FqIAIoAgAiFmpBA3ciAXFqIAQgAUF/c3FqIAIoAgQiF2pBB3ciByABcWogBiAH\
QX9zcWogDCgCACIMakELdyIIIAdxaiABIAhBf3NxaiACKAIMIhhqQRN3IgkgCHEgAWogByAJQX9zcW\
ogDSgCACINakEDdyIBIAlxIAdqIAggAUF/c3FqIAIoAhQiGWpBB3ciAiABcSAIaiAJIAJBf3NxampB\
C3ciByACcSAJaiABIAdBf3NxampBE3ciCCAHcSABaiACIAhBf3NxampBA3ciASAIcSACaiAHIAFBf3\
NxampBB3ciAiABcSAHaiAIIAJBf3NxampBC3ciByACcSAIaiABIAdBf3NxampBE3ciCCAHcSABaiAC\
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\
IRQgAS0AaiEIIAJB4ABqIAQpAhg3AwAgAkHYAGogFDcDACACQdAAaiATNwMAIAJByABqIBI3AwBCAC\
ESIAJCADcDACAIQQRyIQkgAkEIaiEEDAELIAJBEGogAUEQaikDADcDACACQRhqIAFBGGopAwA3AwAg\
AkEgaiABQSBqKQMANwMAIAJBMGogAUEwaikDADcDACACQThqIAFBOGopAwA3AwAgAkHAAGogAUHAAG\
opAwA3AwAgAkHIAGogAUHIAGopAwA3AwAgAkHQAGogAUHQAGopAwA3AwAgAkHYAGogAUHYAGopAwA3\
AwAgAkHgAGogAUHgAGopAwA3AwAgAiABKQMINwMIIAIgASkDKDcDKCABLQBqIQggAiABKQMAIhI3Aw\
AgCCAERXJBAnIhCSACQQhqIQQgAyEGCyACIAk6AGkgAiAFOgBoAkACQCAGRQ0AIAFB8ABqIQogAkEo\
aiEHQQEgBmshCyAIQQRyIQggBkEFdCABakH0AGohASAGQX9qIANPIQwDQCAMDQIgAkHwAGpBGGoiBi\
AEQRhqIg0pAgA3AwAgAkHwAGpBEGoiDiAEQRBqIg8pAgA3AwAgAkHwAGpBCGoiECAEQQhqIhEpAgA3\
AwAgAiAEKQIANwNwIAJB8ABqIAcgBSASIAkQGiAQKQMAIRMgDikDACEUIAYpAwAhFSACKQNwIRYgB0\
EYaiABQRhqKQIANwIAIAdBEGogAUEQaikCADcCACAHQQhqIAFBCGopAgA3AgAgByABKQIANwIAIAQg\
CikDADcDACARIApBCGopAwA3AwAgDyAKQRBqKQMANwMAIA0gCkEYaikDADcDAEIAIRIgAkIANwMAIA\
IgFTcDYCACIBQ3A1ggAiATNwNQIAIgFjcDSCACIAg6AGlBwAAhBSACQcAAOgBoIAFBYGohASAIIQkg\
C0EBaiILQQFHDQALCyAAIAJB8AAQOhoMAgtBACALayADQdCFwAAQTwALIAAgASkDCDcDCCAAIAEpAy\
g3AyggAEEQaiABQRBqKQMANwMAIABBGGogAUEYaikDADcDACAAQSBqIAFBIGopAwA3AwAgAEEwaiAB\
QTBqKQMANwMAIABBOGogAUE4aikDADcDACAAQcAAaiABQcAAaikDADcDACAAQcgAaiABQcgAaikDAD\
cDACAAQdAAaiABQdAAaikDADcDACAAQdgAaiABQdgAaikDADcDACAAQeAAaiABQeAAaikDADcDACAB\
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\
AwAgA0HIAGogA0GoAWpBLGopAgA3AwAgA0HAAGogA0GoAWpBJGopAgA3AwAgA0E4aiADQagBakEcai\
kCADcDACADQTBqIANBqAFqQRRqKQIANwMAIANBKGogA0GoAWpBDGopAgA3AwAgAyADKQKsATcDICAD\
IAY3A1ggA0EIaiADQSBqQQEQFQsgAUHAAGpBADoAACACIAMoAggiAUEYdCABQQh0QYCA/AdxciABQQ\
h2QYD+A3EgAUEYdnJyNgAAIAIgAygCDCIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnI2\
AAQgAiADKAIQIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYACCACIAMoAhQiAUEYdC\
ABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAMIAIgAygCGCIBQRh0IAFBCHRBgID8B3FyIAFB\
CHZBgP4DcSABQRh2cnI2ABAgA0HwAWokAAuyBgEVfyMAQbABayICJAACQAJAAkAgACgCkAEiAyABe6\
ciBE0NACAAQfAAaiEFIAJBKGohBiACQQhqIQcgAkHwAGpBIGohCCADQX9qIQkgA0EFdCAAakHUAGoh\
CiADQX5qQTdJIQsDQCAAIAk2ApABIAlFDQIgACAJQX9qIgw2ApABIAAtAGohDSACQfAAakEYaiIDIA\
pBGGoiDikAADcDACACQfAAakEQaiIPIApBEGoiECkAADcDACACQfAAakEIaiIRIApBCGoiEikAADcD\
ACAIIApBIGopAAA3AAAgCEEIaiAKQShqKQAANwAAIAhBEGogCkEwaikAADcAACAIQRhqIApBOGopAA\
A3AAAgByAFKQMANwMAIAdBCGogBUEIaiITKQMANwMAIAdBEGogBUEQaiIUKQMANwMAIAdBGGogBUEY\
aiIVKQMANwMAIAIgCikAADcDcCAGQThqIAJB8ABqQThqKQMANwAAIAZBMGogAkHwAGpBMGopAwA3AA\
AgBkEoaiACQfAAakEoaikDADcAACAGQSBqIAgpAwA3AAAgBkEYaiADKQMANwAAIAZBEGogDykDADcA\
ACAGQQhqIBEpAwA3AAAgBiACKQNwNwAAIAJBwAA6AGggAiANQQRyIg06AGkgAkIANwMAIAMgFSkCAD\
cDACAPIBQpAgA3AwAgESATKQIANwMAIAIgBSkCADcDcCACQfAAaiAGQcAAQgAgDRAaIAMoAgAhAyAP\
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\
QQhqIA4pAwA3AAAgByAGKQMQNwAAIANBBGohAyALIAFBIGoiAUcNAAsgBigCCCEHCwJAAkACQAJAIA\
lFDQAgB0EFdCICIAVLDQEgBSACayIBQR9NDQIgCUEgRw0DIAQgAmoiAiAAIAhqIgEpAAA3AAAgAkEY\
aiABQRhqKQAANwAAIAJBEGogAUEQaikAADcAACACQQhqIAFBCGopAAA3AAAgB0EBaiEHCyAGQTBqJA\
AgBw8LIAIgBUGwhMAAEEwAC0EgIAFBsITAABBLAAtBICAJQeSLwAAQTgALgQQCA38CfiMAQfABayID\
JAAgACkDACEGIAEgAUHAAGotAAAiBGoiBUGAAToAACADQQhqQRBqIABBGGooAgA2AgAgA0EQaiAAQR\
BqKQIANwMAIAMgACkCCDcDCCAGQgmGIQYgBK1CA4YhBwJAIARBP3MiAEUNACAFQQFqQQAgABA8Ggsg\
BiAHhCEGAkACQCAEQThxQThGDQAgAUE4aiAGNwAAIANBCGogARATDAELIANBCGogARATIANB4ABqQQ\
xqQgA3AgAgA0HgAGpBFGpCADcCACADQeAAakEcakIANwIAIANB4ABqQSRqQgA3AgAgA0HgAGpBLGpC\
ADcCACADQeAAakE0akIANwIAIANBnAFqQgA3AgAgA0IANwJkIANBwAA2AmAgA0GoAWogA0HgAGpBxA\
AQOhogA0HQAGogA0GoAWpBNGopAgA3AwAgA0HIAGogA0GoAWpBLGopAgA3AwAgA0HAAGogA0GoAWpB\
JGopAgA3AwAgA0E4aiADQagBakEcaikCADcDACADQTBqIANBqAFqQRRqKQIANwMAIANBKGogA0GoAW\
pBDGopAgA3AwAgAyADKQKsATcDICADIAY3A1ggA0EIaiADQSBqEBMLIAIgAygCCDYAACACIAMpAgw3\
AAQgAiADKQIUNwAMIAFBwABqQQA6AAAgA0HwAWokAAvwAwIDfwJ+IwBB8AFrIgMkACABQcAAai0AAC\
EEIAApAwAhBiADQRBqIABBEGopAgA3AwAgAyAAKQIINwMIIAEgBGoiAEGAAToAACAGQgmGIQYgBK1C\
A4YhByADIANBCGo2AhwCQCAEQT9zIgVFDQAgAEEBakEAIAUQPBoLIAcgBoQhBgJAAkAgBEE4cUE4Rg\
0AIAFBOGogBjcAACADQRxqIAEQHQwBCyADQRxqIAEQHSADQeAAakEMakIANwIAIANB4ABqQRRqQgA3\
AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQgA3AgAgA0HgAGpBNGpCADcCAC\
ADQZwBakIANwIAIANCADcCZCADQcAANgJgIANBqAFqIANB4ABqQcQAEDoaIANB0ABqIANBqAFqQTRq\
KQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAW\
pBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3\
AyAgAyAGNwNYIANBHGogA0EgahAdCyABQcAAakEAOgAAIAIgAykDCDcAACACIAMpAxA3AAggA0HwAW\
okAAvZAwIDfwJ+IwBB4AFrIgMkACAAKQMAIQYgASABQcAAai0AACIEaiIFQYABOgAAIANBCGogAEEQ\
aikCADcDACADIAApAgg3AwAgBkIJhiEGIAStQgOGIQcCQCAEQT9zIgBFDQAgBUEBakEAIAAQPBoLIA\
cgBoQhBgJAAkAgBEE4cUE4Rg0AIAFBOGogBjcAACADIAEQIAwBCyADIAEQICADQdAAakEMakIANwIA\
IANB0ABqQRRqQgA3AgAgA0HQAGpBHGpCADcCACADQdAAakEkakIANwIAIANB0ABqQSxqQgA3AgAgA0\
HQAGpBNGpCADcCACADQYwBakIANwIAIANCADcCVCADQcAANgJQIANBmAFqIANB0ABqQcQAEDoaIANB\
wABqIANBmAFqQTRqKQIANwMAIANBOGogA0GYAWpBLGopAgA3AwAgA0EwaiADQZgBakEkaikCADcDAC\
ADQShqIANBmAFqQRxqKQIANwMAIANBIGogA0GYAWpBFGopAgA3AwAgA0EYaiADQZgBakEMaikCADcD\
ACADIAMpApwBNwMQIAMgBjcDSCADIANBEGoQIAsgAiADKQMANwAAIAIgAykDCDcACCABQcAAakEAOg\
AAIANB4AFqJAAL1AMCBH8CfiMAQdABayIDJAAgASABQcAAai0AACIEaiIFQQE6AAAgACkDAEIJhiEH\
IAStQgOGIQgCQCAEQT9zIgZFDQAgBUEBakEAIAYQPBoLIAcgCIQhBwJAAkAgBEE4cUE4Rg0AIAFBOG\
ogBzcAACAAQQhqIAFBARAYDAELIABBCGoiBCABQQEQGCADQcAAakEMakIANwIAIANBwABqQRRqQgA3\
AgAgA0HAAGpBHGpCADcCACADQcAAakEkakIANwIAIANBwABqQSxqQgA3AgAgA0HAAGpBNGpCADcCAC\
ADQfwAakIANwIAIANCADcCRCADQcAANgJAIANBiAFqIANBwABqQcQAEDoaIANBMGogA0GIAWpBNGop\
AgA3AwAgA0EoaiADQYgBakEsaikCADcDACADQSBqIANBiAFqQSRqKQIANwMAIANBGGogA0GIAWpBHG\
opAgA3AwAgA0EQaiADQYgBakEUaikCADcDACADQQhqIANBiAFqQQxqKQIANwMAIAMgAykCjAE3AwAg\
AyAHNwM4IAQgA0EBEBgLIAFBwABqQQA6AAAgAiAAKQMINwAAIAIgAEEQaikDADcACCACIABBGGopAw\
A3ABAgA0HQAWokAAuJAwEFfwJAAkACQCABQQlJDQBBACECQc3/eyABQRAgAUEQSxsiAWsgAE0NASAB\
QRAgAEELakF4cSAAQQtJGyIDakEMahAXIgBFDQEgAEF4aiECAkACQCABQX9qIgQgAHENACACIQEMAQ\
sgAEF8aiIFKAIAIgZBeHEgBCAAakEAIAFrcUF4aiIAQQAgASAAIAJrQRBLG2oiASACayIAayEEAkAg\
BkEDcUUNACABIAEoAgRBAXEgBHJBAnI2AgQgBCABakEEaiIEIAQoAgBBAXI2AgAgBSAFKAIAQQFxIA\
ByQQJyNgIAIAAgAmpBBGoiBCAEKAIAQQFyNgIAIAIgABAhDAELIAIoAgAhAiABIAQ2AgQgASACIABq\
NgIACyABKAIEIgBBA3FFDQIgAEF4cSICIANBEGpNDQIgASAAQQFxIANyQQJyNgIEIAEgA2oiACACIA\
NrIgJBA3I2AgQgACACQQRyaiIDIAMoAgBBAXI2AgAgACACECEMAgsgABAXIQILIAIPCyABQQhqC5cD\
AQV/IwBBkARrIgMkACAAQcgBaiEEAkACQAJAAkACQCAAQfACai0AACIFRQ0AQagBIAVrIgYgAksNAS\
ABIAQgBWogBhA6IAZqIQEgAiAGayECCyACIAJBqAFuIgVBqAFsIgdJDQEgAiAHayEGAkAgBUGoAWwi\
AkUNACABIQUDQCADQeACaiAAQagBEDoaIAAQJSAFIANB4AJqQagBEDpBqAFqIQUgAkHYfmoiAg0ACw\
sCQCAGDQBBACEGDAQLIANBADYCsAEgA0GwAWpBBHJBAEGoARA8GiADQagBNgKwASADQeACaiADQbAB\
akGsARA6GiADQQhqIANB4AJqQQRyQagBEDoaIANB4AJqIABBqAEQOhogABAlIANBCGogA0HgAmpBqA\
EQOhogBkGpAU8NAiABIAdqIANBCGogBhA6GiAEIANBCGpBqAEQOhoMAwsgASAEIAVqIAIQOhogBSAC\
aiEGDAILQaGNwABBI0HEjcAAEFUACyAGQagBQcSMwAAQSwALIABB8AJqIAY6AAAgA0GQBGokAAuXAw\
EFfyMAQbADayIDJAAgAEHIAWohBAJAAkACQAJAAkAgAEHQAmotAAAiBUUNAEGIASAFayIGIAJLDQEg\
ASAEIAVqIAYQOiAGaiEBIAIgBmshAgsgAiACQYgBbiIFQYgBbCIHSQ0BIAIgB2shBgJAIAVBiAFsIg\
JFDQAgASEFA0AgA0GgAmogAEGIARA6GiAAECUgBSADQaACakGIARA6QYgBaiEFIAJB+H5qIgINAAsL\
AkAgBg0AQQAhBgwECyADQQA2ApABIANBkAFqQQRyQQBBiAEQPBogA0GIATYCkAEgA0GgAmogA0GQAW\
pBjAEQOhogA0EIaiADQaACakEEckGIARA6GiADQaACaiAAQYgBEDoaIAAQJSADQQhqIANBoAJqQYgB\
EDoaIAZBiQFPDQIgASAHaiADQQhqIAYQOhogBCADQQhqQYgBEDoaDAMLIAEgBCAFaiACEDoaIAUgAm\
ohBgwCC0GhjcAAQSNBxI3AABBVAAsgBkGIAUHEjMAAEEsACyAAQdACaiAGOgAAIANBsANqJAALggMB\
A38CQAJAAkACQCAALQBoIgNFDQACQCADQcEATw0AIAAgA2pBKGogASACQcAAIANrIgMgAyACSxsiAx\
A6GiAAIAAtAGggA2oiBDoAaCABIANqIQECQCACIANrIgINAEEAIQIMAwsgAEEIaiAAQShqIgRBwAAg\
ACkDACAALQBqIABB6QBqIgMtAABFchAaIARBAEHBABA8GiADIAMtAABBAWo6AAAMAQsgA0HAAEGQhM\
AAEEwACwJAIAJBwABLDQAgAkHAACACQcAASRshAkEAIQMMAgsgAEEIaiEFIABB6QBqIgMtAAAhBANA\
IAUgAUHAACAAKQMAIAAtAGogBEH/AXFFchAaIAMgAy0AAEEBaiIEOgAAIAFBwABqIQEgAkFAaiICQc\
AASw0ACyAALQBoIQQLIARB/wFxIgNBwQBPDQEgAkHAACADayIEIAQgAksbIQILIAAgA2pBKGogASAC\
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\
IAJBGGoQLCEBIAJBMGokACABC3QBAn8jAEGQAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2\
ooAAA2AgAgA0EEaiIDQYABRw0ACyACQYABNgIAIAJBiAFqIAJBhAEQOhogACACQYgBakEEckGAARA6\
IAEtAIABOgCAASACQZACaiQAC3QBAn8jAEGgAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2\
ooAAA2AgAgA0EEaiIDQYgBRw0ACyACQYgBNgIAIAJBkAFqIAJBjAEQOhogACACQZABakEEckGIARA6\
IAEtAIgBOgCIASACQaACaiQAC3QBAn8jAEHgAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2\
ooAAA2AgAgA0EEaiIDQagBRw0ACyACQagBNgIAIAJBsAFqIAJBrAEQOhogACACQbABakEEckGoARA6\
IAEtAKgBOgCoASACQeACaiQAC3IBAn8jAEGgAWsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2\
ooAAA2AgAgA0EEaiIDQcgARw0ACyACQcgANgIAIAJB0ABqIAJBzAAQOhogACACQdAAakEEckHIABA6\
IAEtAEg6AEggAkGgAWokAAtyAQJ/IwBB4AFrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKA\
AANgIAIANBBGoiA0HoAEcNAAsgAkHoADYCACACQfAAaiACQewAEDoaIAAgAkHwAGpBBHJB6AAQOiAB\
LQBoOgBoIAJB4AFqJAALdAECfyMAQbACayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAAD\
YCACADQQRqIgNBkAFHDQALIAJBkAE2AgAgAkGYAWogAkGUARA6GiAAIAJBmAFqQQRyQZABEDogAS0A\
kAE6AJABIAJBsAJqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQ\
M2AgAgA0ICNwIMIANByIrAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EI\
aiACEFkAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAj\
cCDCADQaiKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBZAAts\
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\
NEJMQUtFMlNCTEFLRTNLRUNDQUstMjI0S0VDQ0FLLTI1NktFQ0NBSy0zODRLRUNDQUstNTEyTUQ0TU\
Q1UklQRU1ELTE2MFNIQS0xU0hBLTIyNFNIQS0yNTZTSEEtMzg0U0hBLTUxMlRJR0VSdW5zdXBwb3J0\
ZWQgYWxnb3JpdGhtbm9uLWRlZmF1bHQgbGVuZ3RoIHNwZWNpZmllZCBmb3Igbm9uLWV4dGVuZGFibG\
UgYWxnb3JpdGhtbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AOYA\
EAAcAAAAMgIAAAUAAABBcnJheVZlYzogY2FwYWNpdHkgZXhjZWVkZWQgaW4gZXh0ZW5kL2Zyb21faX\
Rlcn4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYXJyYXl2\
ZWMtMC43LjIvc3JjL2FycmF5dmVjLnJzAFMBEABQAAAAAQQAAAUAAABUBhAATQAAAAEGAAAJAAAAfi\
8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9ibGFrZTMtMS4z\
LjAvc3JjL2xpYi5ycwAAAMQBEABJAAAAuQEAAAkAAADEARAASQAAAF8CAAAKAAAAxAEQAEkAAACNAg\
AACQAAAMQBEABJAAAA3QIAAAoAAADEARAASQAAANYCAAAJAAAAxAEQAEkAAAABAwAAGQAAAMQBEABJ\
AAAAAwMAAAkAAADEARAASQAAAAMDAAA4AAAAxAEQAEkAAAD4AwAAMgAAAMQBEABJAAAAqgQAABYAAA\
DEARAASQAAALwEAAAWAAAAxAEQAEkAAADtBAAAEgAAAMQBEABJAAAA9wQAABIAAADEARAASQAAAGkF\
AAAhAAAAEQAAAAQAAAAEAAAAEgAAABEAAAAgAAAAAQAAABMAAAARAAAABAAAAAQAAAASAAAAfi8uY2\
FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9hcnJheXZlYy0wLjcu\
Mi9zcmMvYXJyYXl2ZWNfaW1wbC5ycwAAACADEABVAAAAJwAAACAAAABDYXBhY2l0eUVycm9yAAAAiA\
MQAA0AAABpbnN1ZmZpY2llbnQgY2FwYWNpdHkAAACgAxAAFQAAABEAAAAAAAAAAQAAABQAAABpbmRl\
eCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAA0AMQACAAAADwAx\
AAEgAAADogAACgCBAAAAAAABQEEAACAAAAKTAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1\
MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0ND\
Q1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3\
NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5cmFuZ2Ugc3\
RhcnQgaW5kZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIAAAAPEEEAASAAAAAwUQ\
ACIAAAByYW5nZSBlbmQgaW5kZXggOAUQABAAAAADBRAAIgAAAHNsaWNlIGluZGV4IHN0YXJ0cyBhdC\
AgYnV0IGVuZHMgYXQgAFgFEAAWAAAAbgUQAA0AAABzb3VyY2Ugc2xpY2UgbGVuZ3RoICgpIGRvZXMg\
bm90IG1hdGNoIGRlc3RpbmF0aW9uIHNsaWNlIGxlbmd0aCAojAUQABUAAAChBRAAKwAAACgEEAABAA\
AAVAYQAE0AAAAQDAAADQAAAH4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5\
ZGI5ZWM4MjMvYmxvY2stYnVmZmVyLTAuMTAuMC9zcmMvbGliLnJz9AUQAFAAAAD8AAAAJwAAAC9ydX\
N0Yy9mMWVkZDA0Mjk1ODJkZDI5Y2NjYWNhZjUwZmQxMzRiMDU1OTNiZDljL2xpYnJhcnkvY29yZS9z\
cmMvc2xpY2UvbW9kLnJzYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKClUBhAATQAAAB\
8GAAAJAAAAAAAAAAEjRWeJq83v/ty6mHZUMhDw4dLDAAAAAGfmCWqFrme7cvNuPDr1T6V/Ug5RjGgF\
m6vZgx8ZzeBb2J4FwQfVfDYX3XAwOVkO9zELwP8RFVhop4/5ZKRP+r4IybzzZ+YJajunyoSFrme7K/\
iU/nLzbjzxNh1fOvVPpdGC5q1/Ug5RH2w+K4xoBZtrvUH7q9mDH3khfhMZzeBb2J4FwV2du8sH1Xw2\
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\
7K2QVDo6BtknPCsAv6IwgISjrn7AAyDtbTICxoZAqWl9KKeDinr1MMtfesV55+t55ERotem83AUPtH\
Oj4g5XiG54Gteg9ui9zbqchy+jZMG80WqXi9dmll7iIas8w+XlqmMQkJCNaUhEsxiYu4oePq6HZOO0\
3DuJMfm9rxnVu1/coEVjymWUmyb+KIbsUZw/YAFdHrdJUKEGQORNsct29+VwbL/tK1Xv8hgSQaM2Wn\
AIBwzLRGCYT3UUTecOKKgOQ9lWzWVQX1PXkSXBlu8KcvEjMsgfpWNzbzmgw251bGwgcG9pbnRlciBw\
YXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdW\
xkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3QAAAQAAAAAAAAAQAAAACAAAAAwAAAAIAAA\
ACAAAAAcAAAAIAAAADAAAABAAAAAEAAAABAAAAAUAAAAFAAAABwAAAAgAAAAMAAAAEAAAAAcAAAAIA\
AAADAAAABAAAAAIAAAAEAAAAAYAAAAQAAAACAAAAAwAAAAIAAAACAAAAAcAAAAIAAAADAAAABAAAAA\
EAAAABAAAAAUAAAAFAAAABwAAAAgAAAAMAAAAEAAAAAcAAAAIAAAADAAAABAAAAAIAAAAEAAAAAYAA\
AAALq4gIAABG5hbWUBr7iAgAB5AEVqc19zeXM6OlR5cGVFcnJvcjo6bmV3OjpfX3diZ19uZXdfYTRi\
NjFhMGY1NDgyNGNmZDo6aGQwZmM0NjMyMGI3ZGQ5OWEBO3dhc21fYmluZGdlbjo6X193YmluZGdlbl\
9vYmplY3RfZHJvcF9yZWY6OmhkZGYxZjhlODllMjczZjBkAlVqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5\
dGVfbGVuZ3RoOjpfX3diZ19ieXRlTGVuZ3RoXzNlMjUwYjQxYTg5MTU3NTc6Omg1ZGQ4ZjQyMDFmYT\
A0NGU2A1Vqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfb2Zmc2V0OjpfX3diZ19ieXRlT2Zmc2V0XzQy\
MDRlY2IyNGE2ZTVkZjk6Omg2MDEyMWZmY2ViMDUyYjQ4BExqc19zeXM6OlVpbnQ4QXJyYXk6OmJ1Zm\
Zlcjo6X193YmdfYnVmZmVyX2ZhY2YwMzk4YTI4MWM4NWI6OmhiMDZhZjNlYzc5OTA3ZWY2BXlqc19z\
eXM6OlVpbnQ4QXJyYXk6Om5ld193aXRoX2J5dGVfb2Zmc2V0X2FuZF9sZW5ndGg6Ol9fd2JnX25ld3\
dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoXzRiOWI4YzRlM2Y1YWRiZmY6OmgwNzFlZmZhMTYwOTM5NjJj\
Bkxqc19zeXM6OlVpbnQ4QXJyYXk6Omxlbmd0aDo6X193YmdfbGVuZ3RoXzFlYjhmYzYwOGEwZDRjZG\
I6Omg4NjE2OGQxNDEzMTJkOWQ3BzJ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fbWVtb3J5OjpoNzA2\
NmYxYTQ1YzJkNzg4YQhVanNfc3lzOjpXZWJBc3NlbWJseTo6TWVtb3J5OjpidWZmZXI6Ol9fd2JnX2\
J1ZmZlcl8zOTdlYWE0ZDcyZWU5NGRkOjpoOGVjMDRmOWE1ZDgzYjZhMwlGanNfc3lzOjpVaW50OEFy\
cmF5OjpuZXc6Ol9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmOjpoYjNiYTQwNGE1ZDgzYjNkMgpGan\
Nfc3lzOjpVaW50OEFycmF5OjpzZXQ6Ol9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwOjpoODQyYjZh\
YjRkODFiN2ZkYwsxd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3Rocm93OjpoYjNjZDc3YTExYWFhMD\
UwMgwzd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3JldGhyb3c6OmgxYjVhNzgwMjNiZTU0MzExDUBk\
ZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpkaWdlc3Q6OmgyYmNjMTg3MGQ5YW\
IzODNjDixzaGEyOjpzaGE1MTI6OmNvbXByZXNzNTEyOjpoNmIxMGMzM2FkMDVjMzVmNg9KZGVub19z\
dGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6ZGlnZXN0X2FuZF9yZXNldDo6aDQ0ZjRiNj\
M5NjUyZDdlMTcQQGRlbm9fc3RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OnVwZGF0ZTo6\
aGUwZjdjN2YyMmZjYjkzYTIRLHNoYTI6OnNoYTI1Njo6Y29tcHJlc3MyNTY6OmhlODc4MDI5Y2NmZG\
QzZGY0EjNibGFrZTI6OkJsYWtlMmJWYXJDb3JlOjpjb21wcmVzczo6aDlmODdhNzZhOGZiZWUyMmIT\
KXJpcGVtZDo6YzE2MDo6Y29tcHJlc3M6OmgxODljNDc5ZmJkNjdhZmFkFDNibGFrZTI6OkJsYWtlMn\
NWYXJDb3JlOjpjb21wcmVzczo6aDlkZGE5YzJhMmI2MTc2ODkVK3NoYTE6OmNvbXByZXNzOjpjb21w\
cmVzczo6aDUwZTVkODNlOTFkNjU0YWEWO2Rlbm9fc3RkX3dhc21fY3J5cHRvOjpEaWdlc3RDb250ZX\
h0OjpuZXc6Omg4NTJmMGUyNTRkYTI0NDJhFzpkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+\
OjptYWxsb2M6OmgyYTI3MjA3ZWU5YWY3ZmU5GCx0aWdlcjo6Y29tcHJlc3M6OmNvbXByZXNzOjpoNm\
QyNThmYmY3NTQ4YmZlMRktYmxha2UzOjpPdXRwdXRSZWFkZXI6OmZpbGw6OmhhOWMyNzBjOWI3ZmY0\
MWVlGjZibGFrZTM6OnBvcnRhYmxlOjpjb21wcmVzc19pbl9wbGFjZTo6aGM0YWQ3NDc3Y2JmNTJmMG\
UbE2RpZ2VzdGNvbnRleHRfY2xvbmUcZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFwcGVyOjpDb3JlV3Jh\
cHBlcjxUPiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX06OmhlMWZhYWExOW\
M5MTM0ODllHWg8bWQ1OjpNZDVDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29y\
ZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Ont7Y2xvc3VyZX19OjpoNTZjODcxYTc1MGM1MTgwZB4wYm\
xha2UzOjpjb21wcmVzc19zdWJ0cmVlX3dpZGU6Omg5OTVmOTJhMDk5ZDk4NjM0HzhkbG1hbGxvYzo6\
ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpmcmVlOjpoY2I3OTQ3YTlhN2UyODJjYSAgbWQ0Ojpjb21wcm\
Vzczo6aDkwZDU0MDM2Y2E2MzNlM2MhQWRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmRp\
c3Bvc2VfY2h1bms6OmgyZjkwYmRkZmFiOWZkYWY5IhNkaWdlc3Rjb250ZXh0X3Jlc2V0I3I8c2hhMj\
o6Y29yZV9hcGk6OlNoYTUxMlZhckNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6VmFyaWFibGVPdXRw\
dXRDb3JlPjo6ZmluYWxpemVfdmFyaWFibGVfY29yZTo6aDllYTRhMjE1OGUwNzAzM2IkL2JsYWtlMz\
o6SGFzaGVyOjpmaW5hbGl6ZV94b2Y6OmhiODgzZTZjNWM0ZTVkNDBiJSBrZWNjYWs6OmYxNjAwOjpo\
YTgyNTc5MGNmMjVhNWY1ZSYsY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZDo6aDQ5ZDJjZmNjYWZiYm\
RlNGQnDl9fcnVzdF9yZWFsbG9jKHI8c2hhMjo6Y29yZV9hcGk6OlNoYTI1NlZhckNvcmUgYXMgZGln\
ZXN0Ojpjb3JlX2FwaTo6VmFyaWFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfdmFyaWFibGVfY29yZT\
o6aDAzYTkzMGI4Yzc0YzllZDUpXTxzaGExOjpTaGExQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpG\
aXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoYjVkOWVjNzAyNDhlMTgyMCoxYm\
xha2UzOjpIYXNoZXI6Om1lcmdlX2N2X3N0YWNrOjpoNDdiNmUyNGU2N2UyMTY1Yis1Y29yZTo6Zm10\
OjpGb3JtYXR0ZXI6OnBhZF9pbnRlZ3JhbDo6aGM2Njk0N2IxZGVkNTc4YWEsI2NvcmU6OmZtdDo6d3\
JpdGU6OmhiYmFmMzlmMDliZjQ5ZWZiLTRibGFrZTM6OmNvbXByZXNzX3BhcmVudHNfcGFyYWxsZWw6\
OmhhMDczMmZhY2IxMjc2OWJiLmQ8cmlwZW1kOjpSaXBlbWQxNjBDb3JlIGFzIGRpZ2VzdDo6Y29yZV\
9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhkZThmYzJhZjcxMWYx\
ODVmL1s8bWQ1OjpNZDVDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46Om\
ZpbmFsaXplX2ZpeGVkX2NvcmU6OmgwYjMwMDNlNDg0MjlhYzNkMFs8bWQ0OjpNZDRDb3JlIGFzIGRp\
Z2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmgzZT\
JiMzAwNzMwYWE4YWYwMV88dGlnZXI6OlRpZ2VyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhl\
ZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoNDU3M2E0MGViYzU0Y2E1MzIwZGxtYW\
xsb2M6OkRsbWFsbG9jPEE+OjptYWxsb2M6OmgxODlmYmNhMDM3M2FiODI4M2U8ZGlnZXN0Ojpjb3Jl\
X2FwaTo6eG9mX3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZW\
FkZXI+OjpyZWFkOjpoOGE2ZDliYzFkOGM4YTc0NTRlPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFk\
ZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6aD\
c0YzJhMGFkMGJjOGFmODU1LWJsYWtlMzo6Q2h1bmtTdGF0ZTo6dXBkYXRlOjpoYzU4OGE4Y2Q3YzI2\
Y2VmNTYvY29yZTo6Zm10OjpudW06OmltcDo6Zm10X3U2NDo6aDY2MjhhM2U3MjI3ZTg1NTM3BmRpZ2\
VzdDg+ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6OnVwZGF0ZTo6aGJkOTQ0YWQ2\
M2Y2MjlkYTE5WzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3\
JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDFlNjc5OGM0NDQwOWIxM2M6Bm1lbWNweTsbZGlnZXN0\
Y29udGV4dF9kaWdlc3RBbmREcm9wPAZtZW1zZXQ9P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3\
VyZXM6Omludm9rZTNfbXV0OjpoNGE4M2FkMzFhZDllYjlkOT4UZGlnZXN0Y29udGV4dF9kaWdlc3Q/\
LWpzX3N5czo6VWludDhBcnJheTo6dG9fdmVjOjpoNmVhOWI5MWQ1MjIzZGJiZEAcZGlnZXN0Y29udG\
V4dF9kaWdlc3RBbmRSZXNldEERZGlnZXN0Y29udGV4dF9uZXdCLmNvcmU6OnJlc3VsdDo6dW53cmFw\
X2ZhaWxlZDo6aGQ1ODRlZmI3Yjg0YmYzMjZDUDxhcnJheXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm\
9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg4Y2EzNjljOTgxMGMyMjI5RFA8YXJyYXl2\
ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYW\
JkMmI2NDNkZDBlY2QyY0VbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+\
IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMzFiOWEwZGUxMGRmODY4OUZbPGJsb2NrX2\
J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46\
OmNsb25lOjpoNmQ1ZmZjMTIxNjVhNDVlZkdbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2\
tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoZTQ1NzhiZDExMWQ2NDYw\
N0hbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb2\
5lOjpDbG9uZT46OmNsb25lOjpoNzY2ZWMwMWYwODU4YjU3OElbPGJsb2NrX2J1ZmZlcjo6QmxvY2tC\
dWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMzg2Nz\
U4YmUyNWRiYzlmYUpbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFz\
IGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMzhlMzdmZDQxYjU4ZTJmNks/Y29yZTo6c2xpY2\
U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6OmhjM2UwZGNmNmQ4NjZlMWJlTEFjb3Jl\
OjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsOjpoNmMxMDlhYzg1ODdmMj\
kxMU09Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWlsOjpoZDI3ZGMzODVh\
N2VjMTNjMU5OY29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6bGVuX21pc2\
1hdGNoX2ZhaWw6OmhlZGQxMGM1YmNjMDI2MTBjTzZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5k\
c19jaGVjazo6aGNlMDUwMmY2MzcxMWZhZDhQN3N0ZDo6cGFuaWNraW5nOjpydXN0X3BhbmljX3dpdG\
hfaG9vazo6aDYwNmQ3YzdmN2E0MjNiOThROmJsYWtlMjo6Qmxha2UyYlZhckNvcmU6Om5ld193aXRo\
X3BhcmFtczo6aDU4N2Y5YTcyNzlmMzcxNmRSGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZVMGbWVtY2\
1wVENjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjp3cml0ZV9wcmVmaXg6OmhhYTBh\
ZGYwMGNiNjdkZWQ3VSljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoZWMxZmMwNTdiZDBiYWYwYlYUZG\
lnZXN0Y29udGV4dF91cGRhdGVXEV9fd2JpbmRnZW5fbWFsbG9jWDpibGFrZTI6OkJsYWtlMnNWYXJD\
b3JlOjpuZXdfd2l0aF9wYXJhbXM6Omg1ZmY0NTlmMjMxYWI4ZDY4WS1jb3JlOjpwYW5pY2tpbmc6On\
BhbmljX2ZtdDo6aDYzMTRiNWM5MWFiZTczNDlaP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3Vy\
ZXM6Omludm9rZTRfbXV0OjpoMGRhMGY0NDM1YWYyZTNlYVs/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0Oj\
pjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgwMDg1MjE2YzlhMTJhZWRmXD93YXNtX2JpbmRnZW46OmNv\
bnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDNmMGUyMmI1ODczODUwMDZdP3dhc21fYmluZG\
dlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoMzJlNGU5MGYwYzA4MjM5MF4/d2Fz\
bV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmhiNWQ0MWNhNmRjZDZiMz\
Q4Xz93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDczZGIzMGMw\
OGZiNWJjZDBgP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoOT\
k0MDdiYzUzNzNkMzBmOWE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19t\
dXQ6OmhmODAzN2M3ZmFjMTc4MDllYj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbn\
Zva2UyX211dDo6aDkxMTRjMzZhYmJlNDBmNzljQ3N0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19o\
YW5kbGVyOjp7e2Nsb3N1cmV9fTo6aDliOTg1YTI5M2FhYzRjZTFkEl9fd2JpbmRnZW5fcmVhbGxvY2\
U/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMV9tdXQ6OmhkMWIyODM5MTNl\
Y2RiMGQxZjJjb3JlOjpvcHRpb246Ok9wdGlvbjxUPjo6dW53cmFwOjpoNWE3ZGY5MWI1ZDYwOTBjYm\
cwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgwZDljZDYyNmRhYmFhMWVmaDI8JlQgYXMg\
Y29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoZDMwM2JjMTZhZWU1NTkxMGkRcnVzdF9iZWdpbl91bn\
dpbmRqD19fd2JpbmRnZW5fZnJlZWs0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93Ojpo\
NGI0OTAxNDgzMGNhZmU2M2wzYXJyYXl2ZWM6OmFycmF5dmVjOjpleHRlbmRfcGFuaWM6OmgzN2Q1OT\
hkNzVkMGQyZTZmbTljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxfb25jZTo6aDJhYjg2\
NzY3ZWMxN2M1MGRuH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXJvTmNvcmU6OmZtdDo6bn\
VtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10OjpoMDQ2ZWNjNWVh\
YWIzNGNkNXAxd2FzbV9iaW5kZ2VuOjpfX3J0Ojp0aHJvd19udWxsOjpoZGE3OGMxMGZhOTdiYTRjOH\
Eyd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aDU0MzNjYzM4Zjk0MTk1ZmZyKndhc21f\
YmluZGdlbjo6dGhyb3dfc3RyOjpoYTdhZjVhZTY3MjEyZjIxYXNJc3RkOjpzeXNfY29tbW9uOjpiYW\
NrdHJhY2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoYTAzYWJlZjAyYThiNzBmZHQqd2Fz\
bV9iaW5kZ2VuOjp0aHJvd192YWw6OmgwNWYxN2ZkOTc3Nzc3YjlkdTE8VCBhcyBjb3JlOjphbnk6Ok\
FueT46OnR5cGVfaWQ6OmhhMGM0NDkyMjE2ZDRkMmU3dgpydXN0X3BhbmljdzdzdGQ6OmFsbG9jOjpk\
ZWZhdWx0X2FsbG9jX2Vycm9yX2hvb2s6OmhmOWMzOTNiYTNjZDI4N2UxeG9jb3JlOjpwdHI6OmRyb3\
BfaW5fcGxhY2U8JmNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjpjb3BpZWQ6OkNvcGllZDxjb3JlOjpzbGlj\
ZTo6aXRlcjo6SXRlcjx1OD4+Pjo6aDYzYzJlMTQ5N2I1MmYzZDcA74CAgAAJcHJvZHVjZXJzAghsYW\
5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjU3LjAgKGYxZWRkMDQyOSAyMDIxLTEx\
LTI5KQZ3YWxydXMGMC4xOS4wDHdhc20tYmluZGdlbgYwLjIuNzg=\
");
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
    return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret36 = getObject(idx);
    dropObject(idx);
    return ret36;
}
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
let cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
let cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code61 = arg.charCodeAt(offset);
        if (code61 > 0x7F) break;
        mem[ptr + offset] = code61;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret37 = encodeString(arg, view);
        offset += ret37.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
}
function isLikeNone(x) {
    return x === undefined || x === null;
}
let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data30, length) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.digest(retptr, ptr0, len0, addHeapObject(data30), !isLikeNone(length), isLikeNone(length) ? 0 : length);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DigestContextFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_digestcontext_free(ptr));
class DigestContext {
    static __wrap(ptr) {
        const obj = Object.create(DigestContext.prototype);
        obj.ptr = ptr;
        DigestContextFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
    }
    constructor(algorithm){
        var ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret38 = wasm.digestcontext_new(ptr0, len0);
        return DigestContext.__wrap(ret38);
    }
    update(data31) {
        wasm.digestcontext_update(this.ptr, addHeapObject(data31));
    }
    digest(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndReset(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndDrop(length) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    reset() {
        wasm.digestcontext_reset(this.ptr);
    }
    clone() {
        var ret39 = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret39);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbg_new_a4b61a0f54824cfd: function(arg0, arg1) {
            var ret40 = new TypeError(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret40);
        },
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject(arg0);
        },
        __wbg_byteLength_3e250b41a8915757: function(arg0) {
            var ret41 = getObject(arg0).byteLength;
            return ret41;
        },
        __wbg_byteOffset_4204ecb24a6e5df9: function(arg0) {
            var ret42 = getObject(arg0).byteOffset;
            return ret42;
        },
        __wbg_buffer_facf0398a281c85b: function(arg0) {
            var ret43 = getObject(arg0).buffer;
            return addHeapObject(ret43);
        },
        __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff: function(arg0, arg1, arg2) {
            var ret44 = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
            return addHeapObject(ret44);
        },
        __wbg_length_1eb8fc608a0d4cdb: function(arg0) {
            var ret45 = getObject(arg0).length;
            return ret45;
        },
        __wbindgen_memory: function() {
            var ret46 = wasm.memory;
            return addHeapObject(ret46);
        },
        __wbg_buffer_397eaa4d72ee94dd: function(arg0) {
            var ret47 = getObject(arg0).buffer;
            return addHeapObject(ret47);
        },
        __wbg_new_a7ce447f15ff496f: function(arg0) {
            var ret48 = new Uint8Array(getObject(arg0));
            return addHeapObject(ret48);
        },
        __wbg_set_969ad0a60e51d320: function(arg0, arg1, arg2) {
            getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        },
        __wbindgen_rethrow: function(arg0) {
            throw takeObject(arg0);
        }
    }
};
const wasmModule = new WebAssembly.Module(data);
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
const wasm = wasmInstance.exports;
const _wasm = wasm;
const _wasmModule = wasmModule;
const _wasmInstance = wasmInstance;
const mod53 = {
    digest: digest,
    DigestContext: DigestContext,
    _wasm: _wasm,
    _wasmModule: _wasmModule,
    _wasmInstance: _wasmInstance,
    _wasmBytes: data
};
const digestAlgorithms = [
    "BLAKE2B-256",
    "BLAKE2B-384",
    "BLAKE2B",
    "BLAKE2S",
    "BLAKE3",
    "KECCAK-224",
    "KECCAK-256",
    "KECCAK-384",
    "KECCAK-512",
    "SHA-384",
    "SHA3-224",
    "SHA3-256",
    "SHA3-384",
    "SHA3-512",
    "SHAKE128",
    "SHAKE256",
    "TIGER",
    "RIPEMD-160",
    "SHA-224",
    "SHA-256",
    "SHA-512",
    "MD4",
    "MD5",
    "SHA-1", 
];
const hexTable1 = new TextEncoder().encode("0123456789abcdef");
function encode4(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i150 = 0; i150 < dst.length; i150++){
        const v = src[i150];
        dst[i150 * 2] = hexTable1[v >> 4];
        dst[i150 * 2 + 1] = hexTable1[v & 0x0f];
    }
    return dst;
}
const coerceToBytes = (data32)=>{
    if (data32 instanceof Uint8Array) {
        return data32;
    } else if (typeof data32 === "string") {
        return new TextEncoder().encode(data32);
    } else if (ArrayBuffer.isView(data32)) {
        return new Uint8Array(data32.buffer, data32.byteOffset, data32.byteLength);
    } else if (data32 instanceof ArrayBuffer) {
        return new Uint8Array(data32);
    } else {
        throw new TypeError("expected data to be string | BufferSource");
    }
};
class Hash extends Transform {
    #context;
    constructor(algorithm, _opts){
        super({
            transform (chunk, _encoding, callback) {
                context.update(coerceToBytes(chunk));
                callback();
            },
            flush (callback) {
                this.push(context.digest(undefined));
                callback();
            }
        });
        if (typeof algorithm === "string") {
            algorithm = algorithm.toUpperCase();
            if (opensslToWebCryptoDigestNames[algorithm]) {
                algorithm = opensslToWebCryptoDigestNames[algorithm];
            }
            this.#context = new mod53.DigestContext(algorithm);
        } else {
            this.#context = algorithm;
        }
        const context = this.#context;
    }
    copy() {
        return new Hash(this.#context.clone());
    }
    update(data33, _encoding) {
        let bytes;
        if (typeof data33 === "string") {
            data33 = new TextEncoder().encode(data33);
            bytes = coerceToBytes(data33);
        } else {
            bytes = coerceToBytes(data33);
        }
        this.#context.update(bytes);
        return this;
    }
    digest(encoding) {
        const digest1 = this.#context.digest(undefined);
        if (encoding === undefined) {
            return Buffer.from(digest1);
        }
        switch(encoding){
            case "hex":
                return new TextDecoder().decode(encode4(new Uint8Array(digest1)));
            case "binary":
                return String.fromCharCode(...digest1);
            case "base64":
                return encode(digest1);
            default:
                throw new Error(`The output encoding for hash digest is not implemented: ${encoding}`);
        }
    }
}
const opensslToWebCryptoDigestNames = {
    BLAKE2B512: "BLAKE2B",
    BLAKE2S256: "BLAKE2S",
    RIPEMD160: "RIPEMD-160",
    RMD160: "RIPEMD-160",
    SHA1: "SHA-1",
    SHA224: "SHA-224",
    SHA256: "SHA-256",
    SHA384: "SHA-384",
    SHA512: "SHA-512"
};
function createHash(algorithm, opts) {
    return new Hash(algorithm, opts);
}
function getHashes() {
    return digestAlgorithms;
}
const MAX_ALLOC = Math.pow(2, 30) - 1;
const createHasher = (algorithm)=>(value)=>Buffer.from(createHash(algorithm).update(value).digest());
function getZeroes(zeros1) {
    return Buffer.alloc(zeros1);
}
const sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
};
function toBuffer(bufferable) {
    if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
        return Buffer.from(bufferable);
    } else {
        return Buffer.from(bufferable.buffer);
    }
}
class Hmac {
    hash;
    ipad1;
    opad;
    alg;
    blocksize;
    size;
    ipad2;
    constructor(alg, key, saltLen){
        this.hash = createHasher(alg);
        const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
            key = this.hash(key);
        } else if (key.length < blocksize) {
            key = Buffer.concat([
                key,
                getZeroes(blocksize - key.length)
            ], blocksize);
        }
        const ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        const opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        for(let i151 = 0; i151 < blocksize; i151++){
            ipad[i151] = key[i151] ^ 0x36;
            opad[i151] = key[i151] ^ 0x5C;
        }
        const ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.size = sizes[alg];
    }
    run(data34, ipad) {
        data34.copy(ipad, this.blocksize);
        const h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
    }
}
function pbkdf2Sync(password, salt, iterations, keylen, digest2 = "sha1") {
    if (typeof iterations !== "number" || iterations < 0) {
        throw new TypeError("Bad iterations");
    }
    if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError("Bad key length");
    }
    const bufferedPassword = toBuffer(password);
    const bufferedSalt = toBuffer(salt);
    const hmac1 = new Hmac(digest2, bufferedPassword, bufferedSalt.length);
    const DK = Buffer.allocUnsafe(keylen);
    const block1 = Buffer.allocUnsafe(bufferedSalt.length + 4);
    bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
    let destPos = 0;
    const hLen = sizes[digest2];
    const l = Math.ceil(keylen / hLen);
    for(let i152 = 1; i152 <= l; i152++){
        block1.writeUInt32BE(i152, bufferedSalt.length);
        const T = hmac1.run(block1, hmac1.ipad1);
        let U = T;
        for(let j = 1; j < iterations; j++){
            U = hmac1.run(U, hmac1.ipad2);
            for(let k28 = 0; k28 < hLen; k28++)T[k28] ^= U[k28];
        }
        T.copy(DK, destPos);
        destPos += hLen;
    }
    return DK;
}
function pbkdf2(password, salt, iterations, keylen, digest3 = "sha1", callback) {
    setTimeout(()=>{
        let err = null, res;
        try {
            res = pbkdf2Sync(password, salt, iterations, keylen, digest3);
        } catch (e) {
            err = e;
        }
        if (err) {
            callback(err instanceof Error ? err : new Error("[non-error thrown]"));
        } else {
            callback(null, res);
        }
    }, 0);
}
const fixOpts = (opts)=>{
    const out = {
        N: 16384,
        p: 1,
        r: 8,
        maxmem: 32 << 20
    };
    if (!opts) return out;
    if (opts.N) out.N = opts.N;
    else if (opts.cost) out.N = opts.cost;
    if (opts.p) out.p = opts.p;
    else if (opts.parallelization) out.p = opts.parallelization;
    if (opts.r) out.r = opts.r;
    else if (opts.blockSize) out.r = opts.blockSize;
    if (opts.maxmem) out.maxmem = opts.maxmem;
    return out;
};
function blockxor(S, Si, D, Di, len) {
    let i153 = -1;
    while(++i153 < len)D[Di + i153] ^= S[Si + i153];
}
function arraycopy(src, srcPos, dest, destPos, length) {
    src.copy(dest, destPos, srcPos, srcPos + length);
}
const R = (a, b29)=>a << b29 | a >>> 32 - b29;
class ScryptRom {
    B;
    r;
    N;
    p;
    XY;
    V;
    B32;
    x;
    _X;
    constructor(b30, r, N, p){
        this.B = b30;
        this.r = r;
        this.N = N;
        this.p = p;
        this.XY = Buffer.allocUnsafe(256 * r);
        this.V = Buffer.allocUnsafe(128 * r * N);
        this.B32 = new Int32Array(16);
        this.x = new Int32Array(16);
        this._X = Buffer.allocUnsafe(64);
    }
    run() {
        const p = this.p | 0;
        const r = this.r | 0;
        for(let i154 = 0; i154 < p; i154++)this.scryptROMix(i154, r);
        return this.B;
    }
    scryptROMix(i155, r) {
        const blockStart = i155 * 128 * r;
        const offset = (2 * r - 1) * 64;
        const blockLen = 128 * r;
        const B = this.B;
        const N = this.N | 0;
        const V = this.V;
        const XY = this.XY;
        B.copy(XY, 0, blockStart, blockStart + blockLen);
        for(let i156 = 0; i156 < N; i156++){
            XY.copy(V, i156 * blockLen, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        let j;
        for(let i2 = 0; i2 < N; i2++){
            j = XY.readUInt32LE(offset) & N - 1;
            blockxor(V, j * blockLen, XY, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        XY.copy(B, blockStart, 0, blockLen);
    }
    blockmix_salsa8(blockLen) {
        const BY = this.XY;
        const r = this.r;
        const _X = this._X;
        arraycopy(BY, (2 * r - 1) * 64, _X, 0, 64);
        let i157;
        for(i157 = 0; i157 < 2 * r; i157++){
            blockxor(BY, i157 * 64, _X, 0, 64);
            this.salsa20_8();
            arraycopy(_X, 0, BY, blockLen + i157 * 64, 64);
        }
        for(i157 = 0; i157 < r; i157++){
            arraycopy(BY, blockLen + i157 * 2 * 64, BY, i157 * 64, 64);
            arraycopy(BY, blockLen + (i157 * 2 + 1) * 64, BY, (i157 + r) * 64, 64);
        }
    }
    salsa20_8() {
        const B32 = this.B32;
        const B = this._X;
        const x = this.x;
        let i158;
        for(i158 = 0; i158 < 16; i158++){
            B32[i158] = (B[i158 * 4 + 0] & 0xff) << 0;
            B32[i158] |= (B[i158 * 4 + 1] & 0xff) << 8;
            B32[i158] |= (B[i158 * 4 + 2] & 0xff) << 16;
            B32[i158] |= (B[i158 * 4 + 3] & 0xff) << 24;
        }
        for(i158 = 0; i158 < 16; i158++)x[i158] = B32[i158];
        for(i158 = 0; i158 < 4; i158++){
            x[4] ^= R(x[0] + x[12], 7);
            x[8] ^= R(x[4] + x[0], 9);
            x[12] ^= R(x[8] + x[4], 13);
            x[0] ^= R(x[12] + x[8], 18);
            x[9] ^= R(x[5] + x[1], 7);
            x[13] ^= R(x[9] + x[5], 9);
            x[1] ^= R(x[13] + x[9], 13);
            x[5] ^= R(x[1] + x[13], 18);
            x[14] ^= R(x[10] + x[6], 7);
            x[2] ^= R(x[14] + x[10], 9);
            x[6] ^= R(x[2] + x[14], 13);
            x[10] ^= R(x[6] + x[2], 18);
            x[3] ^= R(x[15] + x[11], 7);
            x[7] ^= R(x[3] + x[15], 9);
            x[11] ^= R(x[7] + x[3], 13);
            x[15] ^= R(x[11] + x[7], 18);
            x[1] ^= R(x[0] + x[3], 7);
            x[2] ^= R(x[1] + x[0], 9);
            x[3] ^= R(x[2] + x[1], 13);
            x[0] ^= R(x[3] + x[2], 18);
            x[6] ^= R(x[5] + x[4], 7);
            x[7] ^= R(x[6] + x[5], 9);
            x[4] ^= R(x[7] + x[6], 13);
            x[5] ^= R(x[4] + x[7], 18);
            x[11] ^= R(x[10] + x[9], 7);
            x[8] ^= R(x[11] + x[10], 9);
            x[9] ^= R(x[8] + x[11], 13);
            x[10] ^= R(x[9] + x[8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }
        for(i158 = 0; i158 < 16; i158++)B32[i158] += x[i158];
        let bi;
        for(i158 = 0; i158 < 16; i158++){
            bi = i158 * 4;
            B[bi + 0] = B32[i158] >> 0 & 0xff;
            B[bi + 1] = B32[i158] >> 8 & 0xff;
            B[bi + 2] = B32[i158] >> 16 & 0xff;
            B[bi + 3] = B32[i158] >> 24 & 0xff;
        }
    }
    clean() {
        this.XY.fill(0);
        this.V.fill(0);
        this._X.fill(0);
        this.B.fill(0);
        for(let i159 = 0; i159 < 16; i159++){
            this.B32[i159] = 0;
            this.x[i159] = 0;
        }
    }
}
function scryptSync(password, salt, keylen, _opts) {
    const { N , r , p , maxmem  } = fixOpts(_opts);
    const blen = p * 128 * r;
    if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    const b31 = pbkdf2Sync(password, salt, 1, blen, "sha256");
    const scryptRom = new ScryptRom(b31, r, N, p);
    const out = scryptRom.run();
    const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
    scryptRom.clean();
    return fin;
}
function scrypt(password, salt, keylen, _opts, cb) {
    if (!cb) {
        cb = _opts;
        _opts = null;
    }
    const { N , r , p , maxmem  } = fixOpts(_opts);
    const blen = p * 128 * r;
    if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    try {
        const b32 = pbkdf2Sync(password, salt, 1, blen, "sha256");
        const scryptRom = new ScryptRom(b32, r, N, p);
        const out = scryptRom.run();
        const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
        scryptRom.clean();
        cb(null, result);
    } catch (err) {
        return cb(err);
    }
}
const timingSafeEqual = (a, b33)=>{
    if (a instanceof DataView) a = Buffer.from(a.buffer);
    if (b33 instanceof DataView) b33 = Buffer.from(b33.buffer);
    if (a instanceof ArrayBuffer) a = Buffer.from(a);
    if (b33 instanceof ArrayBuffer) b33 = Buffer.from(b33);
    let result = 0;
    if (a.byteLength !== b33.byteLength) {
        b33 = a;
        result = 1;
    }
    for(let i160 = 0; i160 < a.byteLength; i160++){
        result |= a[i160] ^ b33[i160];
    }
    return result === 0;
};
function assert3(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
}
function BN(number, base11, endian) {
    if (BN.isBN(number)) {
        return number;
    }
    this.negative = 0;
    this.words = null;
    this.length = 0;
    this.red = null;
    if (number !== null) {
        if (base11 === "le" || base11 === "be") {
            endian = base11;
            base11 = 10;
        }
        this._init(number || 0, base11 || 10, endian || "be");
    }
}
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
    if (num instanceof BN) {
        return true;
    }
    return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
};
BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
};
BN.prototype._init = function init(number, base12, endian) {
    if (typeof number === "number") {
        return this._initNumber(number, base12, endian);
    }
    if (typeof number === "object") {
        return this._initArray(number, base12, endian);
    }
    if (base12 === "hex") {
        base12 = 16;
    }
    assert3(base12 === (base12 | 0) && base12 >= 2 && base12 <= 36);
    number = number.toString().replace(/\s+/g, "");
    var start = 0;
    if (number[0] === "-") {
        start++;
        this.negative = 1;
    }
    if (start < number.length) {
        if (base12 === 16) {
            this._parseHex(number, start, endian);
        } else {
            this._parseBase(number, base12, start);
            if (endian === "le") {
                this._initArray(this.toArray(), base12, endian);
            }
        }
    }
};
BN.prototype._initNumber = function _initNumber(number, base13, endian) {
    if (number < 0) {
        this.negative = 1;
        number = -number;
    }
    if (number < 0x4000000) {
        this.words = [
            number & 0x3ffffff
        ];
        this.length = 1;
    } else if (number < 0x10000000000000) {
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff, 
        ];
        this.length = 2;
    } else {
        assert3(number < 0x20000000000000);
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff,
            1, 
        ];
        this.length = 3;
    }
    if (endian !== "le") return;
    this._initArray(this.toArray(), base13, endian);
};
BN.prototype._initArray = function _initArray(number, base, endian) {
    assert3(typeof number.length === "number");
    if (number.length <= 0) {
        this.words = [
            0
        ];
        this.length = 1;
        return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for(var i161 = 0; i161 < this.length; i161++){
        this.words[i161] = 0;
    }
    var j, w;
    var off = 0;
    if (endian === "be") {
        for(i161 = number.length - 1, j = 0; i161 >= 0; i161 -= 3){
            w = number[i161] | number[i161 - 1] << 8 | number[i161 - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    } else if (endian === "le") {
        for(i161 = 0, j = 0; i161 < number.length; i161 += 3){
            w = number[i161] | number[i161 + 1] << 8 | number[i161 + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    }
    return this._strip();
};
function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index);
    if (c >= 48 && c <= 57) {
        return c - 48;
    } else if (c >= 65 && c <= 70) {
        return c - 55;
    } else if (c >= 97 && c <= 102) {
        return c - 87;
    } else {
        assert3(false, "Invalid character in " + string);
    }
}
function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
}
BN.prototype._parseHex = function _parseHex(number, start, endian) {
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for(var i162 = 0; i162 < this.length; i162++){
        this.words[i162] = 0;
    }
    var off = 0;
    var j = 0;
    var w;
    if (endian === "be") {
        for(i162 = number.length - 1; i162 >= start; i162 -= 2){
            w = parseHexByte(number, start, i162) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    } else {
        var parseLength = number.length - start;
        for(i162 = parseLength % 2 === 0 ? start + 1 : start; i162 < number.length; i162 += 2){
            w = parseHexByte(number, start, i162) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    }
    this._strip();
};
function parseBase(str, start, end, mul) {
    var r = 0;
    var b34 = 0;
    var len = Math.min(str.length, end);
    for(var i163 = start; i163 < len; i163++){
        var c = str.charCodeAt(i163) - 48;
        r *= mul;
        if (c >= 49) {
            b34 = c - 49 + 0xa;
        } else if (c >= 17) {
            b34 = c - 17 + 0xa;
        } else {
            b34 = c;
        }
        assert3(c >= 0 && b34 < mul, "Invalid character");
        r += b34;
    }
    return r;
}
BN.prototype._parseBase = function _parseBase(number, base14, start) {
    this.words = [
        0
    ];
    this.length = 1;
    for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base14){
        limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base14 | 0;
    var total = number.length - start;
    var mod63 = total % limbLen;
    var end = Math.min(total, total - mod63) + start;
    var word = 0;
    for(var i164 = start; i164 < end; i164 += limbLen){
        word = parseBase(number, i164, i164 + limbLen, base14);
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    if (mod63 !== 0) {
        var pow = 1;
        word = parseBase(number, i164, number.length, base14);
        for(i164 = 0; i164 < mod63; i164++){
            pow *= base14;
        }
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    this._strip();
};
BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for(var i165 = 0; i165 < this.length; i165++){
        dest.words[i165] = this.words[i165];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
};
function move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
    move(dest, this);
};
BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
};
BN.prototype._expand = function _expand(size29) {
    while(this.length < size29){
        this.words[this.length++] = 0;
    }
    return this;
};
BN.prototype._strip = function strip() {
    while(this.length > 1 && this.words[this.length - 1] === 0){
        this.length--;
    }
    return this._normSign();
};
BN.prototype._normSign = function _normSign() {
    if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
    }
    return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
    try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect1;
    } catch (e) {
        BN.prototype.inspect = inspect1;
    }
} else {
    BN.prototype.inspect = inspect1;
}
function inspect1() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000", 
];
var groupSizes = [
    0,
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5, 
];
var groupBases = [
    0,
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    10000000,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64000000,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    24300000,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176, 
];
BN.prototype.toString = function toString(base15, padding) {
    base15 = base15 || 10;
    padding = padding | 0 || 1;
    var out;
    if (base15 === 16 || base15 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for(var i166 = 0; i166 < this.length; i166++){
            var w = this.words[i166];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;
            if (carry !== 0 || i166 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
            } else {
                out = word + out;
            }
            off += 2;
            if (off >= 26) {
                off -= 26;
                i166--;
            }
        }
        if (carry !== 0) {
            out = carry.toString(16) + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    if (base15 === (base15 | 0) && base15 >= 2 && base15 <= 36) {
        var groupSize = groupSizes[base15];
        var groupBase = groupBases[base15];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while(!c.isZero()){
            var r = c.modrn(groupBase).toString(base15);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
            } else {
                out = r + out;
            }
        }
        if (this.isZero()) {
            out = "0" + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    assert3(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
    var ret49 = this.words[0];
    if (this.length === 2) {
        ret49 += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
        ret49 += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
        assert3(false, "Number can only safely store up to 53 bits");
    }
    return this.negative !== 0 ? -ret49 : ret49;
};
BN.prototype.toJSON = function toJSON() {
    return this.toString(16, 2);
};
if (Buffer) {
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
}
BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate(ArrayType, size30) {
    if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size30);
    }
    return new ArrayType(size30);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    this._strip();
    var byteLength10 = this.byteLength();
    var reqLength = length || Math.max(1, byteLength10);
    assert3(byteLength10 <= reqLength, "byte array longer than desired length");
    assert3(reqLength > 0, "Requested array length <= 0");
    var res = allocate(ArrayType, reqLength);
    var postfix = endian === "le" ? "LE" : "BE";
    this["_toArrayLike" + postfix](res, byteLength10);
    return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
    var position = 0;
    var carry = 0;
    for(var i167 = 0, shift = 0; i167 < this.length; i167++){
        var word = this.words[i167] << shift | carry;
        res[position++] = word & 0xff;
        if (position < res.length) {
            res[position++] = word >> 8 & 0xff;
        }
        if (position < res.length) {
            res[position++] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position < res.length) {
                res[position++] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position < res.length) {
        res[position++] = carry;
        while(position < res.length){
            res[position++] = 0;
        }
    }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
    var position = res.length - 1;
    var carry = 0;
    for(var i168 = 0, shift = 0; i168 < this.length; i168++){
        var word = this.words[i168] << shift | carry;
        res[position--] = word & 0xff;
        if (position >= 0) {
            res[position--] = word >> 8 & 0xff;
        }
        if (position >= 0) {
            res[position--] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position >= 0) {
                res[position--] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position >= 0) {
        res[position--] = carry;
        while(position >= 0){
            res[position--] = 0;
        }
    }
};
if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
} else {
    BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
}
BN.prototype._zeroBits = function _zeroBits(w) {
    if (w === 0) return 26;
    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
    }
    if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
    }
    if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
    }
    if ((t & 0x1) === 0) {
        r++;
    }
    return r;
};
BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
};
function toBitArray(num) {
    var w = new Array(num.bitLength());
    for(var bit = 0; bit < w.length; bit++){
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 0x01;
    }
    return w;
}
BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;
    for(var i169 = 0; i169 < this.length; i169++){
        var b35 = this._zeroBits(this.words[i169]);
        r += b35;
        if (b35 !== 26) break;
    }
    return r;
};
BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
};
BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
};
BN.prototype.neg = function neg() {
    return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
        this.negative ^= 1;
    }
    return this;
};
BN.prototype.iuor = function iuor(num) {
    while(this.length < num.length){
        this.words[this.length++] = 0;
    }
    for(var i170 = 0; i170 < num.length; i170++){
        this.words[i170] = this.words[i170] | num.words[i170];
    }
    return this._strip();
};
BN.prototype.ior = function ior(num) {
    assert3((this.negative | num.negative) === 0);
    return this.iuor(num);
};
BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
    var b36;
    if (this.length > num.length) {
        b36 = num;
    } else {
        b36 = this;
    }
    for(var i171 = 0; i171 < b36.length; i171++){
        this.words[i171] = this.words[i171] & num.words[i171];
    }
    this.length = b36.length;
    return this._strip();
};
BN.prototype.iand = function iand(num) {
    assert3((this.negative | num.negative) === 0);
    return this.iuand(num);
};
BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
    var a;
    var b37;
    if (this.length > num.length) {
        a = this;
        b37 = num;
    } else {
        a = num;
        b37 = this;
    }
    for(var i172 = 0; i172 < b37.length; i172++){
        this.words[i172] = a.words[i172] ^ b37.words[i172];
    }
    if (this !== a) {
        for(; i172 < a.length; i172++){
            this.words[i172] = a.words[i172];
        }
    }
    this.length = a.length;
    return this._strip();
};
BN.prototype.ixor = function ixor(num) {
    assert3((this.negative | num.negative) === 0);
    return this.iuxor(num);
};
BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
    assert3(typeof width === "number" && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;
    this._expand(bytesNeeded);
    if (bitsLeft > 0) {
        bytesNeeded--;
    }
    for(var i173 = 0; i173 < bytesNeeded; i173++){
        this.words[i173] = ~this.words[i173] & 0x3ffffff;
    }
    if (bitsLeft > 0) {
        this.words[i173] = ~this.words[i173] & 0x3ffffff >> 26 - bitsLeft;
    }
    return this._strip();
};
BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
    assert3(typeof bit === "number" && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    this._expand(off + 1);
    if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
    } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this._strip();
};
BN.prototype.iadd = function iadd(num) {
    var r;
    if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
    } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
    }
    var a, b38;
    if (this.length > num.length) {
        a = this;
        b38 = num;
    } else {
        a = num;
        b38 = this;
    }
    var carry = 0;
    for(var i174 = 0; i174 < b38.length; i174++){
        r = (a.words[i174] | 0) + (b38.words[i174] | 0) + carry;
        this.words[i174] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    for(; carry !== 0 && i174 < a.length; i174++){
        r = (a.words[i174] | 0) + carry;
        this.words[i174] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    this.length = a.length;
    if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
    } else if (a !== this) {
        for(; i174 < a.length; i174++){
            this.words[i174] = a.words[i174];
        }
    }
    return this;
};
BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
    } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
    }
    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
    if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
    } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
    }
    var cmp = this.cmp(num);
    if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
    }
    var a, b39;
    if (cmp > 0) {
        a = this;
        b39 = num;
    } else {
        a = num;
        b39 = this;
    }
    var carry = 0;
    for(var i175 = 0; i175 < b39.length; i175++){
        r = (a.words[i175] | 0) - (b39.words[i175] | 0) + carry;
        carry = r >> 26;
        this.words[i175] = r & 0x3ffffff;
    }
    for(; carry !== 0 && i175 < a.length; i175++){
        r = (a.words[i175] | 0) + carry;
        carry = r >> 26;
        this.words[i175] = r & 0x3ffffff;
    }
    if (carry === 0 && i175 < a.length && a !== this) {
        for(; i175 < a.length; i175++){
            this.words[i175] = a.words[i175];
        }
    }
    this.length = Math.max(this.length, i175);
    if (a !== this) {
        this.negative = 1;
    }
    return this._strip();
};
BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
};
function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;
    var a = self.words[0] | 0;
    var b40 = num.words[0] | 0;
    var r = a * b40;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;
    for(var k29 = 1; k29 < len; k29++){
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k29, num.length - 1);
        for(var j = Math.max(0, k29 - self.length + 1); j <= maxJ; j++){
            var i176 = k29 - j | 0;
            a = self.words[i176] | 0;
            b40 = num.words[j] | 0;
            r = a * b40 + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
        }
        out.words[k29] = rword | 0;
        carry = ncarry | 0;
    }
    if (carry !== 0) {
        out.words[k29] = carry | 0;
    } else {
        out.length--;
    }
    return out._strip();
}
var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b41 = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b41[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b41[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b41[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b41[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b41[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b41[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b41[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b41[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b41[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b41[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
        o[19] = c;
        out.length++;
    }
    return out;
};
if (!Math.imul) {
    comb10MulTo = smallMulTo;
}
function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;
    for(var k30 = 0; k30 < out.length - 1; k30++){
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k30, num.length - 1);
        for(var j = Math.max(0, k30 - self.length + 1); j <= maxJ; j++){
            var i177 = k30 - j;
            var a = self.words[i177] | 0;
            var b42 = num.words[j] | 0;
            var r = a * b42;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
        }
        out.words[k30] = rword;
        carry = ncarry;
        ncarry = hncarry;
    }
    if (carry !== 0) {
        out.words[k30] = carry;
    } else {
        out.length--;
    }
    return out._strip();
}
function jumboMulTo(self, num, out) {
    return bigMulTo(self, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
    } else if (len < 63) {
        res = smallMulTo(this, num, out);
    } else if (len < 1024) {
        res = bigMulTo(this, num, out);
    } else {
        res = jumboMulTo(this, num, out);
    }
    return res;
};
function FFTM(x, y) {
    this.x = x;
    this.y = y;
}
FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for(var i178 = 0; i178 < N; i178++){
        t[i178] = this.revBin(i178, l, N);
    }
    return t;
};
FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;
    for(var i179 = 0; i179 < l; i179++){
        rb |= (x & 1) << l - i179 - 1;
        x >>= 1;
    }
    return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for(var i180 = 0; i180 < N; i180++){
        rtws[i180] = rws[rbt[i180]];
        itws[i180] = iws[rbt[i180]];
    }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);
    for(var s = 1; s < N; s <<= 1){
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for(var p = 0; p < N; p += l){
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for(var j = 0; j < s; j++){
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                    rtwdf_ = rx;
                }
            }
        }
    }
};
FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i181 = 0;
    for(N = N / 2 | 0; N; N = N >>> 1){
        i181++;
    }
    return 1 << i181 + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;
    for(var i182 = 0; i182 < N / 2; i182++){
        var t = rws[i182];
        rws[i182] = rws[N - i182 - 1];
        rws[N - i182 - 1] = t;
        t = iws[i182];
        iws[i182] = -iws[N - i182 - 1];
        iws[N - i182 - 1] = -t;
    }
};
FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for(var i183 = 0; i183 < N / 2; i183++){
        var w = Math.round(ws[2 * i183 + 1] / N) * 0x2000 + Math.round(ws[2 * i183] / N) + carry;
        ws[i183] = w & 0x3ffffff;
        if (w < 0x4000000) {
            carry = 0;
        } else {
            carry = w / 0x4000000 | 0;
        }
    }
    return ws;
};
FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for(var i184 = 0; i184 < len; i184++){
        carry = carry + (ws[i184] | 0);
        rws[2 * i184] = carry & 0x1fff;
        carry = carry >>> 13;
        rws[2 * i184 + 1] = carry & 0x1fff;
        carry = carry >>> 13;
    }
    for(i184 = 2 * len; i184 < N; ++i184){
        rws[i184] = 0;
    }
    assert3(carry === 0);
    assert3((carry & ~0x1fff) === 0);
};
FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for(var i185 = 0; i185 < N; i185++){
        ph[i185] = 0;
    }
    return ph;
};
FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);
    var _ = this.stub(N);
    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);
    for(var i186 = 0; i186 < N; i186++){
        var rx = rwst[i186] * nrwst[i186] - iwst[i186] * niwst[i186];
        iwst[i186] = rwst[i186] * niwst[i186] + iwst[i186] * nrwst[i186];
        rwst[i186] = rx;
    }
    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
};
BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert3(typeof num === "number");
    assert3(num < 0x4000000);
    var carry = 0;
    for(var i187 = 0; i187 < this.length; i187++){
        var w = (this.words[i187] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += w / 0x4000000 | 0;
        carry += lo >>> 26;
        this.words[i187] = lo & 0x3ffffff;
    }
    if (carry !== 0) {
        this.words[i187] = carry;
        this.length++;
    }
    return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
    return this.mul(this);
};
BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);
    var res = this;
    for(var i188 = 0; i188 < w.length; i188++, res = res.sqr()){
        if (w[i188] !== 0) break;
    }
    if (++i188 < w.length) {
        for(var q = res.sqr(); i188 < w.length; i188++, q = q.sqr()){
            if (w[i188] === 0) continue;
            res = res.mul(q);
        }
    }
    return res;
};
BN.prototype.iushln = function iushln(bits) {
    assert3(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i189;
    if (r !== 0) {
        var carry = 0;
        for(i189 = 0; i189 < this.length; i189++){
            var newCarry = this.words[i189] & carryMask;
            var c = (this.words[i189] | 0) - newCarry << r;
            this.words[i189] = c | carry;
            carry = newCarry >>> 26 - r;
        }
        if (carry) {
            this.words[i189] = carry;
            this.length++;
        }
    }
    if (s !== 0) {
        for(i189 = this.length - 1; i189 >= 0; i189--){
            this.words[i189 + s] = this.words[i189];
        }
        for(i189 = 0; i189 < s; i189++){
            this.words[i189] = 0;
        }
        this.length += s;
    }
    return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
    assert3(this.negative === 0);
    return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert3(typeof bits === "number" && bits >= 0);
    var h;
    if (hint) {
        h = (hint - hint % 26) / 26;
    } else {
        h = 0;
    }
    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h);
    if (maskedWords) {
        for(var i190 = 0; i190 < s; i190++){
            maskedWords.words[i190] = this.words[i190];
        }
        maskedWords.length = s;
    }
    if (s === 0) {} else if (this.length > s) {
        this.length -= s;
        for(i190 = 0; i190 < this.length; i190++){
            this.words[i190] = this.words[i190 + s];
        }
    } else {
        this.words[0] = 0;
        this.length = 1;
    }
    var carry = 0;
    for(i190 = this.length - 1; i190 >= 0 && (carry !== 0 || i190 >= h); i190--){
        var word = this.words[i190] | 0;
        this.words[i190] = carry << 26 - r | word >>> r;
        carry = word & mask;
    }
    if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
    }
    return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    assert3(this.negative === 0);
    return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
    assert3(typeof bit === "number" && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) return false;
    var w = this.words[s];
    return !!(w & q);
};
BN.prototype.imaskn = function imaskn(bits) {
    assert3(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert3(this.negative === 0, "imaskn works only with positive numbers");
    if (this.length <= s) {
        return this;
    }
    if (r !== 0) {
        s++;
    }
    this.length = Math.min(s, this.length);
    if (r !== 0) {
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        this.words[this.length - 1] &= mask;
    }
    return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
    assert3(typeof num === "number");
    assert3(num < 0x4000000);
    if (num < 0) return this.isubn(-num);
    if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
    }
    return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;
    for(var i191 = 0; i191 < this.length && this.words[i191] >= 0x4000000; i191++){
        this.words[i191] -= 0x4000000;
        if (i191 === this.length - 1) {
            this.words[i191 + 1] = 1;
        } else {
            this.words[i191 + 1]++;
        }
    }
    this.length = Math.max(this.length, i191 + 1);
    return this;
};
BN.prototype.isubn = function isubn(num) {
    assert3(typeof num === "number");
    assert3(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);
    if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
    } else {
        for(var i192 = 0; i192 < this.length && this.words[i192] < 0; i192++){
            this.words[i192] += 0x4000000;
            this.words[i192 + 1] -= 1;
        }
    }
    return this._strip();
};
BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
};
BN.prototype.abs = function abs() {
    return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i193;
    this._expand(len);
    var w;
    var carry = 0;
    for(i193 = 0; i193 < num.length; i193++){
        w = (this.words[i193 + shift] | 0) + carry;
        var right = (num.words[i193] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - (right / 0x4000000 | 0);
        this.words[i193 + shift] = w & 0x3ffffff;
    }
    for(; i193 < this.length - shift; i193++){
        w = (this.words[i193 + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i193 + shift] = w & 0x3ffffff;
    }
    if (carry === 0) return this._strip();
    assert3(carry === -1);
    carry = 0;
    for(i193 = 0; i193 < this.length; i193++){
        w = -(this.words[i193] | 0) + carry;
        carry = w >> 26;
        this.words[i193] = w & 0x3ffffff;
    }
    this.negative = 1;
    return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode18) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b43 = num;
    var bhi = b43.words[b43.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
        b43 = b43.ushln(shift);
        a.iushln(shift);
        bhi = b43.words[b43.length - 1] | 0;
    }
    var m = a.length - b43.length;
    var q;
    if (mode18 !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for(var i194 = 0; i194 < q.length; i194++){
            q.words[i194] = 0;
        }
    }
    var diff3 = a.clone()._ishlnsubmul(b43, 1, m);
    if (diff3.negative === 0) {
        a = diff3;
        if (q) {
            q.words[m] = 1;
        }
    }
    for(var j = m - 1; j >= 0; j--){
        var qj = (a.words[b43.length + j] | 0) * 0x4000000 + (a.words[b43.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 0x3ffffff);
        a._ishlnsubmul(b43, qj, j);
        while(a.negative !== 0){
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b43, 1, j);
            if (!a.isZero()) {
                a.negative ^= 1;
            }
        }
        if (q) {
            q.words[j] = qj;
        }
    }
    if (q) {
        q._strip();
    }
    a._strip();
    if (mode18 !== "div" && shift !== 0) {
        a.iushrn(shift);
    }
    return {
        div: q || null,
        mod: a
    };
};
BN.prototype.divmod = function divmod(num, mode19, positive) {
    assert3(!num.isZero());
    if (this.isZero()) {
        return {
            div: new BN(0),
            mod: new BN(0)
        };
    }
    var div, mod64, res;
    if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode19);
        if (mode19 !== "mod") {
            div = res.div.neg();
        }
        if (mode19 !== "div") {
            mod64 = res.mod.neg();
            if (positive && mod64.negative !== 0) {
                mod64.iadd(num);
            }
        }
        return {
            div: div,
            mod: mod64
        };
    }
    if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode19);
        if (mode19 !== "mod") {
            div = res.div.neg();
        }
        return {
            div: div,
            mod: res.mod
        };
    }
    if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode19);
        if (mode19 !== "div") {
            mod64 = res.mod.neg();
            if (positive && mod64.negative !== 0) {
                mod64.isub(num);
            }
        }
        return {
            div: res.div,
            mod: mod64
        };
    }
    if (num.length > this.length || this.cmp(num) < 0) {
        return {
            div: new BN(0),
            mod: this
        };
    }
    if (num.length === 1) {
        if (mode19 === "div") {
            return {
                div: this.divn(num.words[0]),
                mod: null
            };
        }
        if (mode19 === "mod") {
            return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
        };
    }
    return this._wordDiv(num, mode19);
};
BN.prototype.div = function div(num) {
    return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod(num) {
    return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
    return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);
    if (dm.mod.isZero()) return dm.div;
    var mod65 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod65.cmp(half);
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert3(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;
    for(var i195 = this.length - 1; i195 >= 0; i195--){
        acc = (p * acc + (this.words[i195] | 0)) % num;
    }
    return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
    return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert3(num <= 0x3ffffff);
    var carry = 0;
    for(var i196 = this.length - 1; i196 >= 0; i196--){
        var w = (this.words[i196] | 0) + carry * 0x4000000;
        this.words[i196] = w / num | 0;
        carry = w % num;
    }
    this._strip();
    return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p) {
    assert3(p.negative === 0);
    assert3(!p.isZero());
    var x = this;
    var y = p.clone();
    if (x.negative !== 0) {
        x = x.umod(p);
    } else {
        x = x.clone();
    }
    var A = new BN(1);
    var B = new BN(0);
    var C = new BN(0);
    var D = new BN(1);
    var g = 0;
    while(x.isEven() && y.isEven()){
        x.iushrn(1);
        y.iushrn(1);
        ++g;
    }
    var yp = y.clone();
    var xp = x.clone();
    while(!x.isZero()){
        for(var i197 = 0, im = 1; (x.words[0] & im) === 0 && i197 < 26; ++i197, im <<= 1);
        if (i197 > 0) {
            x.iushrn(i197);
            while(i197-- > 0){
                if (A.isOdd() || B.isOdd()) {
                    A.iadd(yp);
                    B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            y.iushrn(j);
            while(j-- > 0){
                if (C.isOdd() || D.isOdd()) {
                    C.iadd(yp);
                    D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
            }
        }
        if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
        } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
        }
    }
    return {
        a: C,
        b: D,
        gcd: y.iushln(g)
    };
};
BN.prototype._invmp = function _invmp(p) {
    assert3(p.negative === 0);
    assert3(!p.isZero());
    var a = this;
    var b44 = p.clone();
    if (a.negative !== 0) {
        a = a.umod(p);
    } else {
        a = a.clone();
    }
    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b44.clone();
    while(a.cmpn(1) > 0 && b44.cmpn(1) > 0){
        for(var i198 = 0, im = 1; (a.words[0] & im) === 0 && i198 < 26; ++i198, im <<= 1);
        if (i198 > 0) {
            a.iushrn(i198);
            while(i198-- > 0){
                if (x1.isOdd()) {
                    x1.iadd(delta);
                }
                x1.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (b44.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            b44.iushrn(j);
            while(j-- > 0){
                if (x2.isOdd()) {
                    x2.iadd(delta);
                }
                x2.iushrn(1);
            }
        }
        if (a.cmp(b44) >= 0) {
            a.isub(b44);
            x1.isub(x2);
        } else {
            b44.isub(a);
            x2.isub(x1);
        }
    }
    var res;
    if (a.cmpn(1) === 0) {
        res = x1;
    } else {
        res = x2;
    }
    if (res.cmpn(0) < 0) {
        res.iadd(p);
    }
    return res;
};
BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b45 = num.clone();
    a.negative = 0;
    b45.negative = 0;
    for(var shift = 0; a.isEven() && b45.isEven(); shift++){
        a.iushrn(1);
        b45.iushrn(1);
    }
    do {
        while(a.isEven()){
            a.iushrn(1);
        }
        while(b45.isEven()){
            b45.iushrn(1);
        }
        var r = a.cmp(b45);
        if (r < 0) {
            var t = a;
            a = b45;
            b45 = t;
        } else if (r === 0 || b45.cmpn(1) === 0) {
            break;
        }
        a.isub(b45);
    }while (true)
    return b45.iushln(shift);
};
BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
    assert3(typeof bit === "number");
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
    }
    var carry = q;
    for(var i199 = s; carry !== 0 && i199 < this.length; i199++){
        var w = this.words[i199] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i199] = w;
    }
    if (carry !== 0) {
        this.words[i199] = carry;
        this.length++;
    }
    return this;
};
BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this._strip();
    var res;
    if (this.length > 1) {
        res = 1;
    } else {
        if (negative) {
            num = -num;
        }
        assert3(num <= 0x3ffffff, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.ucmp = function ucmp(num) {
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;
    for(var i200 = this.length - 1; i200 >= 0; i200--){
        var a = this.words[i200] | 0;
        var b46 = num.words[i200] | 0;
        if (a === b46) continue;
        if (a < b46) {
            res = -1;
        } else if (a > b46) {
            res = 1;
        }
        break;
    }
    return res;
};
BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
};
BN.red = function red(num) {
    return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
    assert3(!this.red, "Already a number in reduction context");
    assert3(this.negative === 0, "red works only with positives");
    return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
    assert3(this.red, "fromRed works only with numbers in reduction context");
    return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
    assert3(!this.red, "Already a number in reduction context");
    return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
    assert3(this.red, "redAdd works only with red numbers");
    return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
    assert3(this.red, "redIAdd works only with red numbers");
    return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
    assert3(this.red, "redSub works only with red numbers");
    return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
    assert3(this.red, "redISub works only with red numbers");
    return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
    assert3(this.red, "redShl works only with red numbers");
    return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
    assert3(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
    assert3(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
    assert3(this.red, "redSqr works only with red numbers");
    this.red._verify1(this);
    return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
    assert3(this.red, "redISqr works only with red numbers");
    this.red._verify1(this);
    return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
    assert3(this.red, "redSqrt works only with red numbers");
    this.red._verify1(this);
    return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
    assert3(this.red, "redInvm works only with red numbers");
    this.red._verify1(this);
    return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
    assert3(this.red, "redNeg works only with red numbers");
    this.red._verify1(this);
    return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
    assert3(this.red && !num.red, "redPow(normalNum)");
    this.red._verify1(this);
    return this.red.pow(this, num);
};
var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
};
function MPrime(name54, p) {
    this.name = name54;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
    var r = num;
    var rlen;
    do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
    }while (rlen > this.n)
    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
    } else if (cmp > 0) {
        r.isub(this.p);
    } else {
        if (r.strip !== undefined) {
            r.strip();
        } else {
            r._strip();
        }
    }
    return r;
};
MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
};
function K256() {
    MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits(K256, MPrime);
K256.prototype.split = function split(input, output) {
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);
    for(var i201 = 0; i201 < outLen; i201++){
        output.words[i201] = input.words[i201];
    }
    output.length = outLen;
    if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
    }
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for(i201 = 10; i201 < input.length; i201++){
        var next = input.words[i201] | 0;
        input.words[i201 - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
    }
    prev >>>= 22;
    input.words[i201 - 10] = prev;
    if (prev === 0 && input.length > 10) {
        input.length -= 10;
    } else {
        input.length -= 9;
    }
};
K256.prototype.imulK = function imulK(num) {
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;
    var lo = 0;
    for(var i202 = 0; i202 < num.length; i202++){
        var w = num.words[i202] | 0;
        lo += w * 0x3d1;
        num.words[i202] = lo & 0x3ffffff;
        lo = w * 0x40 + (lo / 0x4000000 | 0);
    }
    if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
            num.length--;
        }
    }
    return num;
};
function P224() {
    MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits(P224, MPrime);
function P192() {
    MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits(P192, MPrime);
function P25519() {
    MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits(P25519, MPrime);
P25519.prototype.imulK = function imulK(num) {
    var carry = 0;
    for(var i203 = 0; i203 < num.length; i203++){
        var hi = (num.words[i203] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i203] = lo;
        carry = hi;
    }
    if (carry !== 0) {
        num.words[num.length++] = carry;
    }
    return num;
};
BN._prime = function prime(name55) {
    if (primes[name55]) return primes[name55];
    var prime;
    if (name55 === "k256") {
        prime = new K256();
    } else if (name55 === "p224") {
        prime = new P224();
    } else if (name55 === "p192") {
        prime = new P192();
    } else if (name55 === "p25519") {
        prime = new P25519();
    } else {
        throw new Error("Unknown prime " + name55);
    }
    primes[name55] = prime;
    return prime;
};
function Red(m) {
    if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
    } else {
        assert3(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
    }
}
Red.prototype._verify1 = function _verify1(a) {
    assert3(a.negative === 0, "red works only with positives");
    assert3(a.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a, b47) {
    assert3((a.negative | b47.negative) === 0, "red works only with positives");
    assert3(a.red && a.red === b47.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    move(a, a.umod(this.m)._forceRed(this));
    return a;
};
Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
        return a.clone();
    }
    return this.m.sub(a)._forceRed(this);
};
Red.prototype.add = function add(a, b48) {
    this._verify2(a, b48);
    var res = a.add(b48);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.iadd = function iadd(a, b49) {
    this._verify2(a, b49);
    var res = a.iadd(b49);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res;
};
Red.prototype.sub = function sub(a, b50) {
    this._verify2(a, b50);
    var res = a.sub(b50);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.isub = function isub(a, b51) {
    this._verify2(a, b51);
    var res = a.isub(b51);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res;
};
Red.prototype.shl = function shl(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
};
Red.prototype.imul = function imul(a, b52) {
    this._verify2(a, b52);
    return this.imod(a.imul(b52));
};
Red.prototype.mul = function mul(a, b53) {
    this._verify2(a, b53);
    return this.imod(a.mul(b53));
};
Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
};
Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
};
Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod310 = this.m.andln(3);
    assert3(mod310 % 2 === 1);
    if (mod310 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
    }
    var q = this.m.subn(1);
    var s = 0;
    while(!q.isZero() && q.andln(1) === 0){
        s++;
        q.iushrn(1);
    }
    assert3(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);
    while(this.pow(z, lpow).cmp(nOne) !== 0){
        z.redIAdd(nOne);
    }
    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while(t.cmp(one) !== 0){
        var tmp = t;
        for(var i204 = 0; tmp.cmp(one) !== 0; i204++){
            tmp = tmp.redSqr();
        }
        assert3(i204 < m);
        var b54 = this.pow(c, new BN(1).iushln(m - i204 - 1));
        r = r.redMul(b54);
        c = b54.redSqr();
        t = t.redMul(c);
        m = i204;
    }
    return r;
};
Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
    } else {
        return this.imod(inv);
    }
};
Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for(var i205 = 2; i205 < wnd.length; i205++){
        wnd[i205] = this.mul(wnd[i205 - 1], a);
    }
    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
        start = 26;
    }
    for(i205 = num.length - 1; i205 >= 0; i205--){
        var word = num.words[i205];
        for(var j = start - 1; j >= 0; j--){
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
                res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i205 !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
        }
        start = 26;
    }
    return res;
};
Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
};
Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
};
BN.mont = function mont(num) {
    return new Mont(num);
};
function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
    }
    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
}
inherits(Mont, Red);
Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
};
Mont.prototype.imul = function imul(a, b55) {
    if (a.isZero() || b55.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
    }
    var t = a.imul(b55);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.mul = function mul(a, b56) {
    if (a.isZero() || b56.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b56);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.invm = function invm(a) {
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
};
function Reporter(options) {
    this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
    };
}
Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
};
Reporter.prototype.save = function save() {
    const state63 = this._reporterState;
    return {
        obj: state63.obj,
        pathLen: state63.path.length
    };
};
Reporter.prototype.restore = function restore(data35) {
    const state64 = this._reporterState;
    state64.obj = data35.obj;
    state64.path = state64.path.slice(0, data35.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
};
Reporter.prototype.exitKey = function exitKey(index) {
    const state65 = this._reporterState;
    state65.path = state65.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    const state66 = this._reporterState;
    this.exitKey(index);
    if (state66.obj !== null) {
        state66.obj[key] = value;
    }
};
Reporter.prototype.path = function path() {
    return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
    const state67 = this._reporterState;
    const prev = state67.obj;
    state67.obj = {};
    return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
    const state68 = this._reporterState;
    const now = state68.obj;
    state68.obj = prev;
    return now;
};
Reporter.prototype.error = function error(msg) {
    let err;
    const state69 = this._reporterState;
    const inherited = msg instanceof ReporterError;
    if (inherited) {
        err = msg;
    } else {
        err = new ReporterError(state69.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
    }
    if (!state69.options.partial) {
        throw err;
    }
    if (!inherited) {
        state69.errors.push(err);
    }
    return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
    const state70 = this._reporterState;
    if (!state70.options.partial) {
        return result;
    }
    return {
        result: this.isError(result) ? null : result,
        errors: state70.errors
    };
};
function ReporterError(path114, msg) {
    this.path = path114;
    this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
    constructor: {
        value: ReporterError,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ReporterError);
    }
    if (!this.stack) {
        try {
            throw new Error(this.message);
        } catch (e) {
            this.stack = e.stack;
        }
    }
    return this;
};
function DecoderBuffer(base16, options) {
    Reporter.call(this, options);
    if (!Buffer.isBuffer(base16)) {
        this.error("Input not Buffer");
        return;
    }
    this.base = base16;
    this.offset = 0;
    this.length = base16.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
    constructor: {
        value: DecoderBuffer,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data36) {
    if (data36 instanceof DecoderBuffer) {
        return true;
    }
    const isCompatible = typeof data36 === "object" && Buffer.isBuffer(data36.base) && data36.constructor.name === "DecoderBuffer" && typeof data36.offset === "number" && typeof data36.length === "number" && typeof data36.save === "function" && typeof data36.restore === "function" && typeof data36.isEmpty === "function" && typeof data36.readUInt8 === "function" && typeof data36.skip === "function" && typeof data36.raw === "function";
    return isCompatible;
};
DecoderBuffer.prototype.save = function save() {
    return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
    };
};
DecoderBuffer.prototype.restore = function restore(save) {
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt8(fail1) {
    if (this.offset + 1 <= this.length) {
        return this.base.readUInt8(this.offset++, true);
    } else {
        return this.error(fail1 || "DecoderBuffer overrun");
    }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail2) {
    if (!(this.offset + bytes <= this.length)) {
        return this.error(fail2 || "DecoderBuffer overrun");
    }
    const res = new DecoderBuffer(this.base);
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
};
DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item)) {
                item = new EncoderBuffer(item, reporter);
            }
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === "number") {
        if (!(0 <= value && value <= 0xff)) {
            return reporter.error("non-byte EncoderBuffer value");
        }
        this.value = value;
        this.length = 1;
    } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer.byteLength(value);
    } else if (Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else {
        return reporter.error("Unsupported type: " + typeof value);
    }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data37) {
    if (data37 instanceof EncoderBuffer) {
        return true;
    }
    const isCompatible = typeof data37 === "object" && data37.constructor.name === "EncoderBuffer" && typeof data37.length === "number" && typeof data37.join === "function";
    return isCompatible;
};
EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out) {
        out = Buffer.alloc(this.length);
    }
    if (!offset) {
        offset = 0;
    }
    if (this.length === 0) {
        return out;
    }
    if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
        });
    } else {
        if (typeof this.value === "number") {
            out[offset] = this.value;
        } else if (typeof this.value === "string") {
            out.write(this.value, offset);
        } else if (Buffer.isBuffer(this.value)) {
            this.value.copy(out, offset);
        }
        offset += this.length;
    }
    return out;
};
const tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr", 
];
const methods = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains", 
].concat(tags);
const overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool", 
];
function Node(enc, parent, name56) {
    const state71 = {};
    this._baseState = state71;
    state71.name = name56;
    state71.enc = enc;
    state71.parent = parent || null;
    state71.children = null;
    state71.tag = null;
    state71.args = null;
    state71.reverseArgs = null;
    state71.choice = null;
    state71.optional = false;
    state71.any = false;
    state71.obj = false;
    state71.use = null;
    state71.useDecoder = null;
    state71.key = null;
    state71["default"] = null;
    state71.explicit = null;
    state71.implicit = null;
    state71.contains = null;
    if (!state71.parent) {
        state71.children = [];
        this._wrap();
    }
}
const stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains", 
];
Node.prototype.clone = function clone() {
    const state72 = this._baseState;
    const cstate = {};
    stateProps.forEach(function(prop) {
        cstate[prop] = state72[prop];
    });
    const res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
};
Node.prototype._wrap = function wrap() {
    const state73 = this._baseState;
    methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
            const clone = new this.constructor(this);
            state73.children.push(clone);
            return clone[method].apply(clone, arguments);
        };
    }, this);
};
Node.prototype._init = function init(body) {
    const state74 = this._baseState;
    assert(state74.parent === null);
    body.call(this);
    state74.children = state74.children.filter(function(child) {
        return child._baseState.parent === this;
    }, this);
    assertEquals(state74.children.length, 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
    const state75 = this._baseState;
    const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
        assert(state75.children === null);
        state75.children = children;
        children.forEach(function(child) {
            child._baseState.parent = this;
        }, this);
    }
    if (args.length !== 0) {
        assert(state75.args === null);
        state75.args = args;
        state75.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object) {
                return arg;
            }
            const res = {};
            Object.keys(arg).forEach(function(key) {
                if (key == (key | 0)) {
                    key |= 0;
                }
                const value = arg[key];
                res[value] = key;
            });
            return res;
        });
    }
};
overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
        const state76 = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state76.enc);
    };
});
tags.forEach(function(tag9) {
    Node.prototype[tag9] = function _tagMethod() {
        const state77 = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state77.tag === null);
        state77.tag = tag9;
        this._useArgs(args);
        return this;
    };
});
Node.prototype.use = function use(item) {
    assert(item);
    const state78 = this._baseState;
    assert(state78.use === null);
    state78.use = item;
    return this;
};
Node.prototype.optional = function optional() {
    const state79 = this._baseState;
    state79.optional = true;
    return this;
};
Node.prototype.def = function def(val) {
    const state80 = this._baseState;
    assert(state80["default"] === null);
    state80["default"] = val;
    state80.optional = true;
    return this;
};
Node.prototype.explicit = function explicit(num) {
    const state81 = this._baseState;
    assert(state81.explicit === null && state81.implicit === null);
    state81.explicit = num;
    return this;
};
Node.prototype.implicit = function implicit(num) {
    const state82 = this._baseState;
    assert(state82.explicit === null && state82.implicit === null);
    state82.implicit = num;
    return this;
};
Node.prototype.obj = function obj() {
    const state83 = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    state83.obj = true;
    if (args.length !== 0) {
        this._useArgs(args);
    }
    return this;
};
Node.prototype.key = function key(newKey) {
    const state84 = this._baseState;
    assert(state84.key === null);
    state84.key = newKey;
    return this;
};
Node.prototype.any = function any() {
    const state85 = this._baseState;
    state85.any = true;
    return this;
};
Node.prototype.choice = function choice(obj) {
    const state86 = this._baseState;
    assert(state86.choice === null);
    state86.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
    }));
    return this;
};
Node.prototype.contains = function contains(item) {
    const state87 = this._baseState;
    assert(state87.use === null);
    state87.contains = item;
    return this;
};
Node.prototype._decode = function decode(input, options) {
    const state88 = this._baseState;
    if (state88.parent === null) {
        return input.wrapResult(state88.children[0]._decode(input, options));
    }
    let result = state88["default"];
    let present = true;
    let prevKey = null;
    if (state88.key !== null) {
        prevKey = input.enterKey(state88.key);
    }
    if (state88.optional) {
        let tag10 = null;
        if (state88.explicit !== null) {
            tag10 = state88.explicit;
        } else if (state88.implicit !== null) {
            tag10 = state88.implicit;
        } else if (state88.tag !== null) {
            tag10 = state88.tag;
        }
        if (tag10 === null && !state88.any) {
            const save = input.save();
            try {
                if (state88.choice === null) {
                    this._decodeGeneric(state88.tag, input, options);
                } else {
                    this._decodeChoice(input, options);
                }
                present = true;
            } catch (_e) {
                present = false;
            }
            input.restore(save);
        } else {
            present = this._peekTag(input, tag10, state88.any);
            if (input.isError(present)) {
                return present;
            }
        }
    }
    let prevObj;
    if (state88.obj && present) {
        prevObj = input.enterObject();
    }
    if (present) {
        if (state88.explicit !== null) {
            const explicit = this._decodeTag(input, state88.explicit);
            if (input.isError(explicit)) {
                return explicit;
            }
            input = explicit;
        }
        const start = input.offset;
        if (state88.use === null && state88.choice === null) {
            let save;
            if (state88.any) {
                save = input.save();
            }
            const body = this._decodeTag(input, state88.implicit !== null ? state88.implicit : state88.tag, state88.any);
            if (input.isError(body)) {
                return body;
            }
            if (state88.any) {
                result = input.raw(save);
            } else {
                input = body;
            }
        }
        if (options && options.track && state88.tag !== null) {
            options.track(input.path(), start, input.length, "tagged");
        }
        if (options && options.track && state88.tag !== null) {
            options.track(input.path(), input.offset, input.length, "content");
        }
        if (state88.any) {} else if (state88.choice === null) {
            result = this._decodeGeneric(state88.tag, input, options);
        } else {
            result = this._decodeChoice(input, options);
        }
        if (input.isError(result)) {
            return result;
        }
        if (!state88.any && state88.choice === null && state88.children !== null) {
            state88.children.forEach(function decodeChildren(child) {
                child._decode(input, options);
            });
        }
        if (state88.contains && (state88.tag === "octstr" || state88.tag === "bitstr")) {
            const data38 = new DecoderBuffer(result);
            result = this._getUse(state88.contains, input._reporterState.obj)._decode(data38, options);
        }
    }
    if (state88.obj && present) {
        result = input.leaveObject(prevObj);
    }
    if (state88.key !== null && (result !== null || present === true)) {
        input.leaveKey(prevKey, state88.key, result);
    } else if (prevKey !== null) {
        input.exitKey(prevKey);
    }
    return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag11, input, options) {
    const state89 = this._baseState;
    if (tag11 === "seq" || tag11 === "set") {
        return null;
    }
    if (tag11 === "seqof" || tag11 === "setof") {
        return this._decodeList(input, tag11, state89.args[0], options);
    } else if (/str$/.test(tag11)) {
        return this._decodeStr(input, tag11, options);
    } else if (tag11 === "objid" && state89.args) {
        return this._decodeObjid(input, state89.args[0], state89.args[1], options);
    } else if (tag11 === "objid") {
        return this._decodeObjid(input, null, null, options);
    } else if (tag11 === "gentime" || tag11 === "utctime") {
        return this._decodeTime(input, tag11, options);
    } else if (tag11 === "null_") {
        return this._decodeNull(input, options);
    } else if (tag11 === "bool") {
        return this._decodeBool(input, options);
    } else if (tag11 === "objDesc") {
        return this._decodeStr(input, tag11, options);
    } else if (tag11 === "int" || tag11 === "enum") {
        return this._decodeInt(input, state89.args && state89.args[0], options);
    }
    if (state89.use !== null) {
        return this._getUse(state89.use, input._reporterState.obj)._decode(input, options);
    } else {
        return input.error("unknown tag: " + tag11);
    }
};
Node.prototype._getUse = function _getUse(entity, obj) {
    const state90 = this._baseState;
    state90.useDecoder = this._use(entity, obj);
    assert(state90.useDecoder._baseState.parent === null);
    state90.useDecoder = state90.useDecoder._baseState.children[0];
    if (state90.implicit !== state90.useDecoder._baseState.implicit) {
        state90.useDecoder = state90.useDecoder.clone();
        state90.useDecoder._baseState.implicit = state90.implicit;
    }
    return state90.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
    const state91 = this._baseState;
    let result = null;
    let match = false;
    Object.keys(state91.choice).some(function(key) {
        const save = input.save();
        const node = state91.choice[key];
        try {
            const value = node._decode(input, options);
            if (input.isError(value)) {
                return false;
            }
            result = {
                type: key,
                value: value
            };
            match = true;
        } catch (_e) {
            input.restore(save);
            return false;
        }
        return true;
    }, this);
    if (!match) {
        return input.error("Choice not matched");
    }
    return result;
};
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data39) {
    return new EncoderBuffer(data39, this.reporter);
};
Node.prototype._encode = function encode(data40, reporter, parent) {
    const state92 = this._baseState;
    if (state92["default"] !== null && state92["default"] === data40) {
        return;
    }
    const result = this._encodeValue(data40, reporter, parent);
    if (result === undefined) {
        return;
    }
    if (this._skipDefault(result, reporter, parent)) {
        return;
    }
    return result;
};
Node.prototype._encodeValue = function encode(data41, reporter, parent) {
    const state1 = this._baseState;
    if (state1.parent === null) {
        return state1.children[0]._encode(data41, reporter || new Reporter());
    }
    let result = null;
    this.reporter = reporter;
    if (state1.optional && data41 === undefined) {
        if (state1["default"] !== null) {
            data41 = state1["default"];
        } else {
            return;
        }
    }
    let content = null;
    let primitive = false;
    if (state1.any) {
        result = this._createEncoderBuffer(data41);
    } else if (state1.choice) {
        result = this._encodeChoice(data41, reporter);
    } else if (state1.contains) {
        content = this._getUse(state1.contains, parent)._encode(data41, reporter);
        primitive = true;
    } else if (state1.children) {
        content = state1.children.map(function(child) {
            if (child._baseState.tag === "null_") {
                return child._encode(null, reporter, data41);
            }
            if (child._baseState.key === null) {
                return reporter.error("Child should have a key");
            }
            const prevKey = reporter.enterKey(child._baseState.key);
            if (typeof data41 !== "object") {
                return reporter.error("Child expected, but input is not object");
            }
            const res = child._encode(data41[child._baseState.key], reporter, data41);
            reporter.leaveKey(prevKey);
            return res;
        }, this).filter(function(child) {
            return child;
        });
        content = this._createEncoderBuffer(content);
    } else {
        if (state1.tag === "seqof" || state1.tag === "setof") {
            if (!(state1.args && state1.args.length === 1)) {
                return reporter.error("Too many args for : " + state1.tag);
            }
            if (!Array.isArray(data41)) {
                return reporter.error("seqof/setof, but data is not Array");
            }
            const child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data41.map(function(item) {
                const state93 = this._baseState;
                return this._getUse(state93.args[0], data41)._encode(item, reporter);
            }, child));
        } else if (state1.use !== null) {
            result = this._getUse(state1.use, parent)._encode(data41, reporter);
        } else {
            content = this._encodePrimitive(state1.tag, data41);
            primitive = true;
        }
    }
    if (!state1.any && state1.choice === null) {
        const tag12 = state1.implicit !== null ? state1.implicit : state1.tag;
        const cls = state1.implicit === null ? "universal" : "context";
        if (tag12 === null) {
            if (state1.use === null) {
                reporter.error("Tag could be omitted only for .use()");
            }
        } else {
            if (state1.use === null) {
                result = this._encodeComposite(tag12, primitive, cls, content);
            }
        }
    }
    if (state1.explicit !== null) {
        result = this._encodeComposite(state1.explicit, false, "context", result);
    }
    return result;
};
Node.prototype._encodeChoice = function encodeChoice(data42, reporter) {
    const state94 = this._baseState;
    const node = state94.choice[data42.type];
    if (!node) {
        assert(false, data42.type + " not found in " + JSON.stringify(Object.keys(state94.choice)));
    }
    return node._encode(data42.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag13, data43) {
    const state95 = this._baseState;
    if (/str$/.test(tag13)) {
        return this._encodeStr(data43, tag13);
    } else if (tag13 === "objid" && state95.args) {
        return this._encodeObjid(data43, state95.reverseArgs[0], state95.args[1]);
    } else if (tag13 === "objid") {
        return this._encodeObjid(data43, null, null);
    } else if (tag13 === "gentime" || tag13 === "utctime") {
        return this._encodeTime(data43, tag13);
    } else if (tag13 === "null_") {
        return this._encodeNull();
    } else if (tag13 === "int" || tag13 === "enum") {
        return this._encodeInt(data43, state95.args && state95.reverseArgs[0]);
    } else if (tag13 === "bool") {
        return this._encodeBool(data43);
    } else if (tag13 === "objDesc") {
        return this._encodeStr(data43, tag13);
    } else {
        throw new Error("Unsupported tag: " + tag13);
    }
};
Node.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key) {
        if ((key | 0) == key) {
            key = key | 0;
        }
        const value = map[key];
        res[value] = key;
    });
    return res;
}
const tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
};
const tagClassByName = reverse(tagClass);
const tag = {
    0x00: "end",
    0x01: "bool",
    0x02: "int",
    0x03: "bitstr",
    0x04: "octstr",
    0x05: "null_",
    0x06: "objid",
    0x07: "objDesc",
    0x08: "external",
    0x09: "real",
    0x0a: "enum",
    0x0b: "embed",
    0x0c: "utf8str",
    0x0d: "relativeOid",
    0x10: "seq",
    0x11: "set",
    0x12: "numstr",
    0x13: "printstr",
    0x14: "t61str",
    0x15: "videostr",
    0x16: "ia5str",
    0x17: "utctime",
    0x18: "gentime",
    0x19: "graphstr",
    0x1a: "iso646str",
    0x1b: "genstr",
    0x1c: "unistr",
    0x1d: "charstr",
    0x1e: "bmpstr"
};
const tagByName = reverse(tag);
const mod54 = {
    tagClass: tagClass,
    tagClassByName: tagClassByName,
    tag: tag,
    tagByName: tagByName
};
function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode(data44, reporter) {
    return this.tree._encode(data44, reporter).join();
};
function DERNode(parent) {
    Node.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag14, primitive, cls, content) {
    const encodedTag = encodeTag(tag14, primitive, cls, this.reporter);
    if (content.length < 0x80) {
        const header = Buffer.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([
            header,
            content
        ]);
    }
    let lenOctets = 1;
    for(let i206 = content.length; i206 >= 0x100; i206 >>= 8){
        lenOctets++;
    }
    const header = Buffer.alloc(1 + 1 + lenOctets);
    header[0] = encodedTag;
    header[1] = 0x80 | lenOctets;
    for(let i1100 = 1 + lenOctets, j = content.length; j > 0; i1100--, j >>= 8){
        header[i1100] = j & 0xff;
    }
    return this._createEncoderBuffer([
        header,
        content
    ]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag15) {
    if (tag15 === "bitstr") {
        return this._createEncoderBuffer([
            str.unused | 0,
            str.data
        ]);
    } else if (tag15 === "bmpstr") {
        const buf = Buffer.alloc(str.length * 2);
        for(let i207 = 0; i207 < str.length; i207++){
            buf.writeUInt16BE(str.charCodeAt(i207), i207 * 2);
        }
        return this._createEncoderBuffer(buf);
    } else if (tag15 === "numstr") {
        if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports " + "only digits and space");
        }
        return this._createEncoderBuffer(str);
    } else if (tag15 === "printstr") {
        if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports " + "only latin upper and lower case letters, " + "digits, space, apostrophe, left and rigth " + "parenthesis, plus sign, comma, hyphen, " + "dot, slash, colon, equal sign, " + "question mark");
        }
        return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag15)) {
        return this._createEncoderBuffer(str);
    } else if (tag15 === "objDesc") {
        return this._createEncoderBuffer(str);
    } else {
        return this.reporter.error("Encoding of string type: " + tag15 + " unsupported");
    }
};
DERNode.prototype._encodeObjid = function encodeObjid(id7, values4, relative8) {
    if (typeof id7 === "string") {
        if (!values4) {
            return this.reporter.error("string objid given, but no values map found");
        }
        if (!values4.hasOwnProperty(id7)) {
            return this.reporter.error("objid not found in values map");
        }
        id7 = values4[id7].split(/[\s.]+/g);
        for(let i208 = 0; i208 < id7.length; i208++){
            id7[i208] |= 0;
        }
    } else if (Array.isArray(id7)) {
        id7 = id7.slice();
        for(let i209 = 0; i209 < id7.length; i209++){
            id7[i209] |= 0;
        }
    }
    if (!Array.isArray(id7)) {
        return this.reporter.error("objid() should be either array or string, " + "got: " + JSON.stringify(id7));
    }
    if (!relative8) {
        if (id7[1] >= 40) {
            return this.reporter.error("Second objid identifier OOB");
        }
        id7.splice(0, 2, id7[0] * 40 + id7[1]);
    }
    let size31 = 0;
    for(let i210 = 0; i210 < id7.length; i210++){
        let ident1 = id7[i210];
        for(size31++; ident1 >= 0x80; ident1 >>= 7){
            size31++;
        }
    }
    const objid = Buffer.alloc(size31);
    let offset = objid.length - 1;
    for(let i2 = id7.length - 1; i2 >= 0; i2--){
        let ident2 = id7[i2];
        objid[offset--] = ident2 & 0x7f;
        while((ident2 >>= 7) > 0){
            objid[offset--] = 0x80 | ident2 & 0x7f;
        }
    }
    return this._createEncoderBuffer(objid);
};
function two(num) {
    if (num < 10) {
        return "0" + num;
    } else {
        return num;
    }
}
DERNode.prototype._encodeTime = function encodeTime(time, tag16) {
    let str;
    const date = new Date(time);
    if (tag16 === "gentime") {
        str = [
            two(date.getUTCFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z", 
        ].join("");
    } else if (tag16 === "utctime") {
        str = [
            two(date.getUTCFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z", 
        ].join("");
    } else {
        this.reporter.error("Encoding " + tag16 + " time is not supported yet");
    }
    return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values5) {
    if (typeof num === "string") {
        if (!values5) {
            return this.reporter.error("String int or enum given, but no values map");
        }
        if (!values5.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values5[num];
    }
    if (typeof num !== "number" && !Buffer.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 0x80) {
            numArray.unshift(0);
        }
        num = Buffer.from(numArray);
    }
    if (Buffer.isBuffer(num)) {
        let size32 = num.length;
        if (num.length === 0) {
            size32++;
        }
        const out = Buffer.alloc(size32);
        num.copy(out);
        if (num.length === 0) {
            out[0] = 0;
        }
        return this._createEncoderBuffer(out);
    }
    if (num < 0x80) {
        return this._createEncoderBuffer(num);
    }
    if (num < 0x100) {
        return this._createEncoderBuffer([
            0,
            num
        ]);
    }
    let size33 = 1;
    for(let i211 = num; i211 >= 0x100; i211 >>= 8){
        size33++;
    }
    const out = new Array(size33);
    for(let i3 = out.length - 1; i3 >= 0; i3--){
        out[i3] = num & 0xff;
        num >>= 8;
    }
    if (out[0] & 0x80) {
        out.unshift(0);
    }
    return this._createEncoderBuffer(Buffer.from(out));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 0xff : 0);
};
DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state96 = this._baseState;
    let i212;
    if (state96["default"] === null) {
        return false;
    }
    const data45 = dataBuffer.join();
    if (state96.defaultBuffer === undefined) {
        state96.defaultBuffer = this._encodeValue(state96["default"], reporter, parent).join();
    }
    if (data45.length !== state96.defaultBuffer.length) {
        return false;
    }
    for(i212 = 0; i212 < data45.length; i212++){
        if (data45[i212] !== state96.defaultBuffer[i212]) {
            return false;
        }
    }
    return true;
};
function encodeTag(tag17, primitive, cls, reporter) {
    let res;
    if (tag17 === "seqof") {
        tag17 = "seq";
    } else if (tag17 === "setof") {
        tag17 = "set";
    }
    if (tagByName.hasOwnProperty(tag17)) {
        res = tagByName[tag17];
    } else if (typeof tag17 === "number" && (tag17 | 0) === tag17) {
        res = tag17;
    } else {
        return reporter.error("Unknown tag: " + tag17);
    }
    if (res >= 0x1f) {
        return reporter.error("Multi-octet tag encoding unsupported");
    }
    if (!primitive) {
        res |= 0x20;
    }
    res |= tagClassByName[cls || "universal"] << 6;
    return res;
}
function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
    constructor: {
        value: PEMEncoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMEncoder.prototype.encode = function encode(data46, options) {
    const buf = DEREncoder.prototype.encode.call(this, data46);
    const p = buf.toString("base64");
    const out = [
        "-----BEGIN " + options.label + "-----"
    ];
    for(let i213 = 0; i213 < p.length; i213 += 64){
        out.push(p.slice(i213, i213 + 64));
    }
    out.push("-----END " + options.label + "-----");
    return out.join("\n");
};
function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode1();
    this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode(data47, options) {
    if (!DecoderBuffer.isDecoderBuffer(data47)) {
        data47 = new DecoderBuffer(data47, options);
    }
    return this.tree._decode(data47, options);
};
function DERNode1(parent) {
    Node.call(this, "der", parent);
}
DERNode1.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode1.prototype._peekTag = function peekTag(buffer39, tag18, any) {
    if (buffer39.isEmpty()) {
        return false;
    }
    const state97 = buffer39.save();
    const decodedTag = derDecodeTag(buffer39, 'Failed to peek tag: "' + tag18 + '"');
    if (buffer39.isError(decodedTag)) {
        return decodedTag;
    }
    buffer39.restore(state97);
    return decodedTag.tag === tag18 || decodedTag.tagStr === tag18 || decodedTag.tagStr + "of" === tag18 || any;
};
DERNode1.prototype._decodeTag = function decodeTag(buffer40, tag19, any) {
    const decodedTag = derDecodeTag(buffer40, 'Failed to decode tag of "' + tag19 + '"');
    if (buffer40.isError(decodedTag)) {
        return decodedTag;
    }
    let len = derDecodeLen(buffer40, decodedTag.primitive, 'Failed to get length of "' + tag19 + '"');
    if (buffer40.isError(len)) {
        return len;
    }
    if (!any && decodedTag.tag !== tag19 && decodedTag.tagStr !== tag19 && decodedTag.tagStr + "of" !== tag19) {
        return buffer40.error('Failed to match tag: "' + tag19 + '"');
    }
    if (decodedTag.primitive || len !== null) {
        return buffer40.skip(len, 'Failed to match body of: "' + tag19 + '"');
    }
    const state98 = buffer40.save();
    const res = this._skipUntilEnd(buffer40, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer40.isError(res)) {
        return res;
    }
    len = buffer40.offset - state98.offset;
    buffer40.restore(state98);
    return buffer40.skip(len, 'Failed to match body of: "' + tag19 + '"');
};
DERNode1.prototype._skipUntilEnd = function skipUntilEnd(buffer41, fail3) {
    for(;;){
        const tag20 = derDecodeTag(buffer41, fail3);
        if (buffer41.isError(tag20)) {
            return tag20;
        }
        const len = derDecodeLen(buffer41, tag20.primitive, fail3);
        if (buffer41.isError(len)) {
            return len;
        }
        let res;
        if (tag20.primitive || len !== null) {
            res = buffer41.skip(len);
        } else {
            res = this._skipUntilEnd(buffer41, fail3);
        }
        if (buffer41.isError(res)) {
            return res;
        }
        if (tag20.tagStr === "end") {
            break;
        }
    }
};
DERNode1.prototype._decodeList = function decodeList(buffer42, _tag, decoder, options) {
    const result = [];
    while(!buffer42.isEmpty()){
        const possibleEnd = this._peekTag(buffer42, "end");
        if (buffer42.isError(possibleEnd)) {
            return possibleEnd;
        }
        const res = decoder.decode(buffer42, "der", options);
        if (buffer42.isError(res) && possibleEnd) {
            break;
        }
        result.push(res);
    }
    return result;
};
DERNode1.prototype._decodeStr = function decodeStr(buffer43, tag21) {
    if (tag21 === "bitstr") {
        const unused = buffer43.readUInt8();
        if (buffer43.isError(unused)) {
            return unused;
        }
        return {
            unused: unused,
            data: buffer43.raw()
        };
    } else if (tag21 === "bmpstr") {
        const raw = buffer43.raw();
        if (raw.length % 2 === 1) {
            return buffer43.error("Decoding of string type: bmpstr length mismatch");
        }
        let str = "";
        for(let i214 = 0; i214 < raw.length / 2; i214++){
            str += String.fromCharCode(raw.readUInt16BE(i214 * 2));
        }
        return str;
    } else if (tag21 === "numstr") {
        const numstr = buffer43.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
            return buffer43.error("Decoding of string type: " + "numstr unsupported characters");
        }
        return numstr;
    } else if (tag21 === "octstr") {
        return buffer43.raw();
    } else if (tag21 === "objDesc") {
        return buffer43.raw();
    } else if (tag21 === "printstr") {
        const printstr = buffer43.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
            return buffer43.error("Decoding of string type: " + "printstr unsupported characters");
        }
        return printstr;
    } else if (/str$/.test(tag21)) {
        return buffer43.raw().toString();
    } else {
        return buffer43.error("Decoding of string type: " + tag21 + " unsupported");
    }
};
DERNode1.prototype._decodeObjid = function decodeObjid(buffer44, values6, relative9) {
    let result;
    const identifiers = [];
    let ident3 = 0;
    let subident = 0;
    while(!buffer44.isEmpty()){
        subident = buffer44.readUInt8();
        ident3 <<= 7;
        ident3 |= subident & 0x7f;
        if ((subident & 0x80) === 0) {
            identifiers.push(ident3);
            ident3 = 0;
        }
    }
    if (subident & 0x80) {
        identifiers.push(ident3);
    }
    const first = identifiers[0] / 40 | 0;
    const second = identifiers[0] % 40;
    if (relative9) {
        result = identifiers;
    } else {
        result = [
            first,
            second
        ].concat(identifiers.slice(1));
    }
    if (values6) {
        let tmp = values6[result.join(" ")];
        if (tmp === undefined) {
            tmp = values6[result.join(".")];
        }
        if (tmp !== undefined) {
            result = tmp;
        }
    }
    return result;
};
DERNode1.prototype._decodeTime = function decodeTime(buffer45, tag22) {
    const str = buffer45.raw().toString();
    let year;
    let mon;
    let day;
    let hour;
    let min25;
    let sec;
    if (tag22 === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min25 = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
    } else if (tag22 === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min25 = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70) {
            year = 2000 + year;
        } else {
            year = 1900 + year;
        }
    } else {
        return buffer45.error("Decoding " + tag22 + " time is not supported yet");
    }
    return Date.UTC(year, mon - 1, day, hour, min25, sec, 0);
};
DERNode1.prototype._decodeNull = function decodeNull() {
    return null;
};
DERNode1.prototype._decodeBool = function decodeBool(buffer46) {
    const res = buffer46.readUInt8();
    if (buffer46.isError(res)) {
        return res;
    } else {
        return res !== 0;
    }
};
DERNode1.prototype._decodeInt = function decodeInt(buffer47, values7) {
    const raw = buffer47.raw();
    let res = new BN(raw);
    if (values7) {
        res = values7[res.toString(10)] || res;
    }
    return res;
};
DERNode1.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail4) {
    let tag23 = buf.readUInt8(fail4);
    if (buf.isError(tag23)) {
        return tag23;
    }
    const cls = tagClass[tag23 >> 6];
    const primitive = (tag23 & 0x20) === 0;
    if ((tag23 & 0x1f) === 0x1f) {
        let oct = tag23;
        tag23 = 0;
        while((oct & 0x80) === 0x80){
            oct = buf.readUInt8(fail4);
            if (buf.isError(oct)) {
                return oct;
            }
            tag23 <<= 7;
            tag23 |= oct & 0x7f;
        }
    } else {
        tag23 &= 0x1f;
    }
    const tagStr = tag[tag23];
    return {
        cls: cls,
        primitive: primitive,
        tag: tag23,
        tagStr: tagStr
    };
}
function derDecodeLen(buf, primitive, fail5) {
    let len = buf.readUInt8(fail5);
    if (buf.isError(len)) {
        return len;
    }
    if (!primitive && len === 0x80) {
        return null;
    }
    if ((len & 0x80) === 0) {
        return len;
    }
    const num = len & 0x7f;
    if (num > 4) {
        return buf.error("length octect is too long");
    }
    len = 0;
    for(let i215 = 0; i215 < num; i215++){
        len <<= 8;
        const j = buf.readUInt8(fail5);
        if (buf.isError(j)) {
            return j;
        }
        len |= j;
    }
    return len;
}
function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
    constructor: {
        value: PEMDecoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMDecoder.prototype.decode = function decode(data48, options) {
    const lines = data48.toString().split(/[\r\n]+/g);
    const label = options.label.toUpperCase();
    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start = -1;
    let end = -1;
    for(let i216 = 0; i216 < lines.length; i216++){
        const match = lines[i216].match(re);
        if (match === null) {
            continue;
        }
        if (match[2] !== label) {
            continue;
        }
        if (start === -1) {
            if (match[1] !== "BEGIN") {
                break;
            }
            start = i216;
        } else {
            if (match[1] !== "END") {
                break;
            }
            end = i216;
            break;
        }
    }
    if (start === -1 || end === -1) {
        throw new Error("PEM section not found for: " + label);
    }
    const base64 = lines.slice(start + 1, end).join("");
    base64.replace(/[^a-z0-9+/=]+/gi, "");
    const input = Buffer.from(base64, "base64");
    return DERDecoder.prototype.decode.call(this, input, options);
};
const base1 = {
    DecoderBuffer,
    EncoderBuffer,
    Node,
    Reporter
};
const encoders = {
    der: DEREncoder,
    pem: PEMEncoder
};
const decoders = {
    der: DERDecoder,
    pem: PEMDecoder
};
const constants4 = {
    der: mod54
};
function define(name57, body) {
    return new Entity(name57, body);
}
function Entity(name58, body) {
    this.name = name58;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
    const name110 = this.name;
    function Generated(entity) {
        this._initNamed(entity, name110);
    }
    Generated.prototype = Object.create(Base.prototype, {
        constructor: {
            value: Generated,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    Generated.prototype._initNamed = function _initNamed(entity, name59) {
        Base.call(this, entity, name59);
    };
    return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    if (!this.decoders.hasOwnProperty(enc)) {
        this.decoders[enc] = this._createNamed(decoders[enc]);
    }
    return this.decoders[enc];
};
Entity.prototype.decode = function decode(data49, enc, options) {
    return this._getDecoder(enc).decode(data49, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    if (!this.encoders.hasOwnProperty(enc)) {
        this.encoders[enc] = this._createNamed(encoders[enc]);
    }
    return this.encoders[enc];
};
Entity.prototype.encode = function encode(data50, enc, reporter) {
    return this._getEncoder(enc).encode(data50, reporter);
};
const __default11 = {
    base: base1,
    bignum: BN,
    constants: constants4,
    decoders,
    define,
    encoders
};
const Time = define("Time", function() {
    this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
    });
});
const AttributeTypeValue = define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
});
const AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
const SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
const RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
});
const RDNSequence = define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
});
const Name = define("Name", function() {
    this.choice({
        rdnSequence: this.use(RDNSequence)
    });
});
const Validity = define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
const Extension = define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
const TBSCertificate = define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
const X509Certificate = define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
const RSAPrivateKey = __default11.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
const RSAPublicKey = __default11.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
const PublicKey = __default11.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPublicKey").bitstr());
});
const AlgorithmIdentifier1 = __default11.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
const PrivateKey = __default11.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPrivateKey").octstr());
});
const EncryptedPrivateKey = __default11.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
const DSAPrivateKey = __default11.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
const DSAparam = __default11.define("DSAparam", function() {
    this.int();
});
const ECPrivateKey = __default11.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
const ECParameters = __default11.define("ECParameters", function() {
    this.choice({
        namedCurve: this.objid()
    });
});
const signature = __default11.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
});
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer.isBuffer(password)) password = Buffer.from(password, "binary");
    if (salt) {
        if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, "binary");
        if (salt.length !== 8) {
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
    }
    let keyLen = keyBits / 8;
    const key = Buffer.alloc(keyLen);
    const iv = Buffer.alloc(ivLen || 0);
    let tmp = Buffer.alloc(0);
    while(keyLen > 0 || ivLen > 0){
        const hash = createHash("md5");
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        let used = 0;
        if (keyLen > 0) {
            const keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
            const ivStart = iv.length - ivLen;
            const length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
        }
    }
    tmp.fill(0);
    return {
        key,
        iv
    };
}
const encrypt = function(self, block) {
    return self._cipher.encryptBlock(block);
};
const decrypt = function(self, block) {
    return self._cipher.decryptBlock(block);
};
const mod55 = {
    encrypt: encrypt,
    decrypt: decrypt
};
function xor(a, b57) {
    const length = Math.min(a.length, b57.length);
    const buffer48 = Buffer.allocUnsafe(length);
    for(let i217 = 0; i217 < length; ++i217){
        buffer48[i217] = a[i217] ^ b57[i217];
    }
    return buffer48;
}
const encrypt1 = function(self, block) {
    const data51 = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data51);
    return self._prev;
};
const decrypt1 = function(self, block) {
    const pad = self._prev;
    self._prev = block;
    const out = self._cipher.decryptBlock(block);
    return xor(out, pad);
};
const mod56 = {
    encrypt: encrypt1,
    decrypt: decrypt1
};
function encryptStart(self, data52, decrypt3) {
    const len = data52.length;
    const out = xor(data52, self._cache);
    self._cache = self._cache.slice(len);
    self._prev = Buffer.concat([
        self._prev,
        decrypt3 ? data52 : out
    ]);
    return out;
}
const encrypt2 = function(self, data53, decrypt4) {
    let out = Buffer.allocUnsafe(0);
    let len;
    while(data53.length){
        if (self._cache.length === 0) {
            self._cache = self._cipher.encryptBlock(self._prev);
            self._prev = Buffer.allocUnsafe(0);
        }
        if (self._cache.length <= data53.length) {
            len = self._cache.length;
            out = Buffer.concat([
                out,
                encryptStart(self, data53.slice(0, len), decrypt4), 
            ]);
            data53 = data53.slice(len);
        } else {
            out = Buffer.concat([
                out,
                encryptStart(self, data53, decrypt4)
            ]);
            break;
        }
    }
    return out;
};
const mod57 = {
    encrypt: encrypt2
};
function encryptByte(self, byteParam, decrypt5) {
    const pad = self._cipher.encryptBlock(self._prev);
    const out = pad[0] ^ byteParam;
    self._prev = Buffer.concat([
        self._prev.slice(1),
        Buffer.from([
            decrypt5 ? byteParam : out
        ]), 
    ]);
    return out;
}
const encrypt3 = function(self, chunk, decrypt6) {
    const len = chunk.length;
    const out = Buffer.allocUnsafe(len);
    let i218 = -1;
    while(++i218 < len){
        out[i218] = encryptByte(self, chunk[i218], decrypt6);
    }
    return out;
};
const mod58 = {
    encrypt: encrypt3
};
function encryptByte1(self, byteParam, decrypt7) {
    let pad;
    let i219 = -1;
    let out = 0;
    let bit, value;
    while(++i219 < 8){
        pad = self._cipher.encryptBlock(self._prev);
        bit = byteParam & 1 << 7 - i219 ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += (value & 0x80) >> i219 % 8;
        self._prev = shiftIn(self._prev, decrypt7 ? bit : value);
    }
    return out;
}
function shiftIn(buffer49, value) {
    const len = buffer49.length;
    let i220 = -1;
    const out = Buffer.allocUnsafe(buffer49.length);
    buffer49 = Buffer.concat([
        buffer49,
        Buffer.from([
            value
        ])
    ]);
    while(++i220 < len){
        out[i220] = buffer49[i220] << 1 | buffer49[i220 + 1] >> 7;
    }
    return out;
}
const encrypt4 = function(self, chunk, decrypt8) {
    const len = chunk.length;
    const out = Buffer.allocUnsafe(len);
    let i221 = -1;
    while(++i221 < len){
        out[i221] = encryptByte1(self, chunk[i221], decrypt8);
    }
    return out;
};
const mod59 = {
    encrypt: encrypt4
};
function getBlock(self) {
    self._prev = self._cipher.encryptBlock(self._prev);
    return self._prev;
}
const encrypt5 = function(self, chunk) {
    while(self._cache.length < chunk.length){
        self._cache = Buffer.concat([
            self._cache,
            getBlock(self)
        ]);
    }
    const pad = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod60 = {
    encrypt: encrypt5
};
function incr32(iv) {
    let len = iv.length;
    let item;
    while(len--){
        item = iv.readUInt8(len);
        if (item === 255) {
            iv.writeUInt8(0, len);
        } else {
            item++;
            iv.writeUInt8(item, len);
            break;
        }
    }
}
function getBlock1(self) {
    const out = self._cipher.encryptBlockRaw(self._prev);
    incr32(self._prev);
    return out;
}
const blockSize = 16;
const encrypt6 = function(self, chunk) {
    const chunkNum = Math.ceil(chunk.length / 16);
    const start = self._cache.length;
    self._cache = Buffer.concat([
        self._cache,
        Buffer.allocUnsafe(chunkNum * blockSize), 
    ]);
    for(let i222 = 0; i222 < chunkNum; i222++){
        const out = getBlock1(self);
        const offset = start + i222 * 16;
        self._cache.writeUInt32BE(out[0], offset + 0);
        self._cache.writeUInt32BE(out[1], offset + 4);
        self._cache.writeUInt32BE(out[2], offset + 8);
        self._cache.writeUInt32BE(out[3], offset + 12);
    }
    const pad = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod61 = {
    encrypt: encrypt6
};
const modeModules = {
    ECB: mod55,
    CBC: mod56,
    CFB: mod57,
    CFB8: mod58,
    CFB1: mod59,
    OFB: mod60,
    CTR: mod61,
    GCM: mod61
};
const MODES = {
    "aes-128-ecb": {
        "cipher": "AES",
        "key": 128,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-192-ecb": {
        "cipher": "AES",
        "key": 192,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-256-ecb": {
        "cipher": "AES",
        "key": 256,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-128-cbc": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-192-cbc": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-256-cbc": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes128": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes192": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes256": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-128-cfb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-192-cfb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-256-cfb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-128-cfb8": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-192-cfb8": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-256-cfb8": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-128-cfb1": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-192-cfb1": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-256-cfb1": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-128-ofb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-192-ofb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-256-ofb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-128-ctr": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-192-ctr": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-256-ctr": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-128-gcm": {
        "cipher": "AES",
        "key": 128,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-192-gcm": {
        "cipher": "AES",
        "key": 192,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-256-gcm": {
        "cipher": "AES",
        "key": 256,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    }
};
for (const mode of Object.values(MODES)){
    mode.module = modeModules[mode.mode];
}
function asUInt32Array(buf) {
    if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);
    for(var i223 = 0; i223 < len; i223++){
        out[i223] = buf.readUInt32BE(i223 * 4);
    }
    return out;
}
function scrubVec(v) {
    for(var i224 = 0; i224 < v.length; v++){
        v[i224] = 0;
    }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for(var round = 1; round < nRounds; round++){
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [
        t0,
        t1,
        t2,
        t3
    ];
}
var RCON = [
    0x00,
    0x01,
    0x02,
    0x04,
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
    0x1b,
    0x36
];
var G = function() {
    var d = new Array(256);
    for(var j = 0; j < 256; j++){
        if (j < 128) {
            d[j] = j << 1;
        } else {
            d[j] = j << 1 ^ 0x11b;
        }
    }
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var INV_SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var x = 0;
    var xi = 0;
    for(var i225 = 0; i225 < 256; ++i225){
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
            x = xi = 1;
        } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
        }
    }
    return {
        SBOX: SBOX,
        INV_SBOX: INV_SBOX,
        SUB_MIX: SUB_MIX,
        INV_SUB_MIX: INV_SUB_MIX
    };
}();
function AES(key) {
    this._key = asUInt32Array(key);
    this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for(var k31 = 0; k31 < keySize; k31++){
        keySchedule[k31] = keyWords[k31];
    }
    for(k31 = keySize; k31 < ksRows; k31++){
        var t = keySchedule[k31 - 1];
        if (k31 % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
            t ^= RCON[k31 / keySize | 0] << 24;
        } else if (keySize > 6 && k31 % keySize === 4) {
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
        }
        keySchedule[k31] = keySchedule[k31 - keySize] ^ t;
    }
    var invKeySchedule = [];
    for(var ik = 0; ik < ksRows; ik++){
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
        } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
        }
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
    M = asUInt32Array(M);
    return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
};
AES.prototype.decryptBlock = function(M) {
    M = asUInt32Array(M);
    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
};
AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
};
function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
    } else {
        this.final = this._finalOrDigest;
    }
    if (this._final) {
        this.__final = this._final;
        this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
}
CipherBase.prototype = Object.create(Transform.prototype, {
    constructor: {
        value: CipherBase,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
CipherBase.prototype.update = function(data54, inputEnc, outputEnc) {
    if (typeof data54 === "string") {
        data54 = Buffer.from(data54, inputEnc);
    }
    var outData = this._update(data54);
    if (this.hashMode) return this;
    if (outputEnc) {
        outData = this._toString(outData, outputEnc);
    }
    return outData;
};
CipherBase.prototype.setAutoPadding = function() {};
CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data55, _, next) {
    var err;
    try {
        if (this.hashMode) {
            this._update(data55);
        } else {
            this.push(this._update(data55));
        }
    } catch (e) {
        err = e;
    } finally{
        next(err);
    }
};
CipherBase.prototype._flush = function(done) {
    var err;
    try {
        this.push(this.__final());
    } catch (e) {
        err = e;
    }
    done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);
    if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
    }
    return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) {
        out += this._decoder.end();
    }
    return out;
};
var ZEROES = Buffer.alloc(16, 0);
function toArray(buf) {
    return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12), 
    ];
}
function fromArray(out) {
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
}
function GHASH(key) {
    this.h = key;
    this.state = Buffer.alloc(16, 0);
    this.cache = Buffer.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
    var i226 = -1;
    while(++i226 < block.length){
        this.state[i226] ^= block[i226];
    }
    this._multiply();
};
GHASH.prototype._multiply = function() {
    var Vi = toArray(this.h);
    var Zi = [
        0,
        0,
        0,
        0
    ];
    var j, xi, lsbVi;
    var i227 = -1;
    while(++i227 < 128){
        xi = (this.state[~~(i227 / 8)] & 1 << 7 - i227 % 8) !== 0;
        if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for(j = 3; j > 0; j--){
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
            Vi[0] = Vi[0] ^ 0xe1 << 24;
        }
    }
    this.state = fromArray(Zi);
};
GHASH.prototype.update = function(buf) {
    this.cache = Buffer.concat([
        this.cache,
        buf
    ]);
    var chunk;
    while(this.cache.length >= 16){
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
    }
};
GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) {
        this.ghash(Buffer.concat([
            this.cache,
            ZEROES
        ], 16));
    }
    this.ghash(fromArray([
        0,
        abl,
        0,
        bl
    ]));
    return this.state;
};
function xorTest(a, b58) {
    var out = 0;
    if (a.length !== b58.length) out++;
    var len = Math.min(a.length, b58.length);
    for(var i228 = 0; i228 < len; ++i228){
        out += a[i228] ^ b58[i228];
    }
    return out;
}
function calcIv(self, iv, ck) {
    if (iv.length === 12) {
        self._finID = Buffer.concat([
            iv,
            Buffer.from([
                0,
                0,
                0,
                1
            ])
        ]);
        return Buffer.concat([
            iv,
            Buffer.from([
                0,
                0,
                0,
                2
            ])
        ]);
    }
    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);
    if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer.alloc(toPad, 0));
    }
    ghash.update(Buffer.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer.alloc(8);
    tail.writeUIntBE(ivBits, 2, 6);
    ghash.update(tail);
    self._finID = ghash.state;
    var out = Buffer.from(self._finID);
    incr32(out);
    return out;
}
function StreamCipher(mode20, key, iv, decrypt9) {
    CipherBase.call(this);
    var h = Buffer.alloc(4, 0);
    this._cipher = new AES(key);
    var ck = this._cipher.encryptBlock(h);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    this._decrypt = decrypt9;
    this._alen = 0;
    this._len = 0;
    this._mode = mode20;
    this._authTag = null;
    this._called = false;
}
StreamCipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
            rump = Buffer.alloc(rump, 0);
            this._ghash.update(rump);
        }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) {
        this._ghash.update(chunk);
    } else {
        this._ghash.update(out);
    }
    this._len += chunk.length;
    return out;
};
StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    var tag24 = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag24, this._authTag)) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    this._authTag = tag24;
    this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer.isBuffer(this._authTag)) {
        throw new Error("Attempting to get auth tag in unsupported state");
    }
    return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag25) {
    if (!this._decrypt) {
        throw new Error("Attempting to set auth tag in unsupported state");
    }
    this._authTag = tag25;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) {
        throw new Error("Attempting to set AAD in unsupported state");
    }
    this._ghash.update(buf);
    this._alen += buf.length;
};
function StreamCipher1(mode21, key, iv, decrypt10) {
    CipherBase.call(this);
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    this._decrypt = decrypt10;
    this._mode = mode21;
}
StreamCipher1.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher1.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher1.prototype._final = function() {
    this._cipher.scrub();
};
function Cipher(mode22, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter();
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._mode = mode22;
    this._autopadding = true;
}
Cipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Cipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Cipher.prototype._update = function(data56) {
    this._cache.add(data56);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get()){
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
    }
    return Buffer.concat(out);
};
var PADDING = Buffer.alloc(16, 0x10);
Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
    }
    if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
    }
};
Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter() {
    this.cache = Buffer.allocUnsafe(0);
}
Splitter.prototype.add = function(data57) {
    this.cache = Buffer.concat([
        this.cache,
        data57
    ]);
};
Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
        const out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
    }
    return null;
};
Splitter.prototype.flush = function() {
    var len = 16 - this.cache.length;
    var padBuff = Buffer.allocUnsafe(len);
    var i229 = -1;
    while(++i229 < len){
        padBuff.writeUInt8(len, i229);
    }
    return Buffer.concat([
        this.cache,
        padBuff
    ]);
};
function Decipher(mode23, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter1();
    this._last = void 0;
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._mode = mode23;
    this._autopadding = true;
}
Decipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Decipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Decipher.prototype._update = function(data58) {
    this._cache.add(data58);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get(this._autopadding)){
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
    }
    return Buffer.concat(out);
};
Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
    } else if (chunk) {
        throw new Error("data not multiple of block length");
    }
};
Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter1() {
    this.cache = Buffer.allocUnsafe(0);
}
Splitter1.prototype.add = function(data59) {
    this.cache = Buffer.concat([
        this.cache,
        data59
    ]);
};
Splitter1.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
        if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    } else {
        if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    }
    return null;
};
Splitter1.prototype.flush = function() {
    if (this.cache.length) return this.cache;
};
function unpad(last44) {
    var padded = last44[15];
    if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
    }
    var i230 = -1;
    while(++i230 < padded){
        if (last44[i230 + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
        }
    }
    if (padded === 16) return;
    return last44.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) {
        throw new TypeError("invalid iv length " + iv.length);
    }
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) {
        throw new TypeError("invalid key length " + password.length);
    }
    if (config.type === "stream") {
        return new StreamCipher1(config.module, password, iv, true);
    } else if (config.type === "auth") {
        return new StreamCipher(config.module, password, iv, true);
    }
    return new Decipher(config.module, password, iv);
}
const findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
const startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
const fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function __default12(okey, password) {
    const key = okey.toString();
    const match = key.match(findProc);
    let decrypted;
    if (!match) {
        const match2 = key.match(fullRegex);
        decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
        const suite = "aes" + match[1];
        const iv = Buffer.from(match[2], "hex");
        const cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ""), "base64");
        const cipherKey = EVP_BytesToKey(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        const out = [];
        const cipher = createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer.concat(out);
    }
    const tag26 = key.match(startRegex)[1];
    return {
        tag: tag26,
        data: decrypted
    };
}
const aesid = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer50) {
    let password;
    if (typeof buffer50 === "object" && !Buffer.isBuffer(buffer50)) {
        password = buffer50.passphrase;
        buffer50 = buffer50.key;
    }
    if (typeof buffer50 === "string") {
        buffer50 = Buffer.from(buffer50);
    }
    const stripped = __default12(buffer50, password);
    const type52 = stripped.tag;
    let data60 = stripped.data;
    let subtype, ndata;
    switch(type52){
        case "CERTIFICATE":
            ndata = X509Certificate.decode(data60, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            if (!ndata) {
                ndata = PublicKey.decode(data60, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                    return {
                        type: "ec",
                        data: ndata
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
                    return {
                        type: "dsa",
                        data: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "ENCRYPTED PRIVATE KEY":
            data60 = EncryptedPrivateKey.decode(data60, "der");
            data60 = decrypt2(data60, password);
        case "PRIVATE KEY":
            ndata = PrivateKey.decode(data60, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                    return {
                        curve: ndata.algorithm.curve,
                        privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
                    return {
                        type: "dsa",
                        params: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "RSA PUBLIC KEY":
            return RSAPublicKey.decode(data60, "der");
        case "RSA PRIVATE KEY":
            return RSAPrivateKey.decode(data60, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: DSAPrivateKey.decode(data60, "der")
            };
        case "EC PRIVATE KEY":
            data60 = ECPrivateKey.decode(data60, "der");
            return {
                curve: data60.parameters.value,
                privateKey: data60.privateKey
            };
        default:
            throw new Error("unknown key type " + type52);
    }
}
parseKeys.signature = signature;
function decrypt2(data61, password) {
    const salt = data61.algorithm.decrypt.kde.kdeparams.salt;
    const iters = parseInt(data61.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    const algo = aesid[data61.algorithm.decrypt.cipher.algo.join(".")];
    const iv = data61.algorithm.decrypt.cipher.iv;
    const cipherText = data61.subjectPrivateKey;
    const keylen = parseInt(algo.split("-")[1], 10) / 8;
    const key = pbkdf2Sync(password, salt, iters, keylen, "sha1");
    const cipher = createDecipheriv(algo, key, iv);
    const out = [];
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    return Buffer.concat(out);
}
const MAX_BYTES = 65536;
function randomBytes1(size34, cb) {
    if (size34 > 4294967295) {
        throw new RangeError("requested too many random bytes");
    }
    const bytes = Buffer.allocUnsafe(size34);
    if (size34 > 0) {
        if (size34 > 65536) {
            for(let generated = 0; generated < size34; generated += MAX_BYTES){
                crypto.getRandomValues(bytes.slice(generated, generated + 65536));
            }
        } else {
            crypto.getRandomValues(bytes);
        }
    }
    if (typeof cb === "function") {
        return nextTick2(function() {
            cb(null, bytes);
        });
    }
    return bytes;
}
function __default13(seed, len) {
    let t = Buffer.alloc(0);
    let i231 = 0;
    let c;
    while(t.length < len){
        c = i2ops(i231++);
        t = Buffer.concat([
            t,
            createHash("sha1").update(seed).update(c).digest()
        ]);
    }
    return t.slice(0, len);
}
function i2ops(c) {
    const out = Buffer.allocUnsafe(4);
    out.writeUInt32BE(c, 0);
    return out;
}
function xor1(a, b59) {
    const len = a.length;
    let i232 = -1;
    while(++i232 < len){
        a[i232] ^= b59[i232];
    }
    return a;
}
function withPublic(paddedMsg, key) {
    return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}
function blind(priv) {
    const r = getr(priv);
    const blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
    return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
    };
}
function getr(priv) {
    const len = priv.modulus.byteLength();
    let r;
    do {
        r = new BN(randomBytes1(len));
    }while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
    return r;
}
function crt(msg, priv) {
    const blinds = blind(priv);
    const len = priv.modulus.byteLength();
    const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
    const c1 = blinded.toRed(BN.mont(priv.prime1));
    const c2 = blinded.toRed(BN.mont(priv.prime2));
    const qinv = priv.coefficient;
    const p = priv.prime1;
    const q = priv.prime2;
    const m1 = c1.redPow(priv.exponent1).fromRed();
    const m2 = c2.redPow(priv.exponent2).fromRed();
    const h = m1.isub(m2).imul(qinv).umod(p).imul(q);
    return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, "be", len);
}
crt.getr = getr;
function publicEncrypt(publicKey, msg, reverse2) {
    let padding;
    if (publicKey.padding) {
        padding = publicKey.padding;
    } else if (reverse2) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(publicKey);
    let paddedMsg;
    if (padding === 4) {
        paddedMsg = oaep(key, msg);
    } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse2);
    } else if (padding === 3) {
        paddedMsg = new BN(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
            throw new Error("data too long for modulus");
        }
    } else {
        throw new Error("unknown padding");
    }
    if (reverse2) {
        return crt(paddedMsg, key);
    } else {
        return withPublic(paddedMsg, key);
    }
}
function oaep(key, msg) {
    const k32 = key.modulus.byteLength();
    const mLen = msg.length;
    const iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
    const hLen = iHash.length;
    const hLen2 = 2 * hLen;
    if (mLen > k32 - hLen2 - 2) {
        throw new Error("message too long");
    }
    const ps = Buffer.alloc(k32 - mLen - hLen2 - 2);
    const dblen = k32 - hLen - 1;
    const seed = randomBytes1(hLen);
    const maskedDb = xor1(Buffer.concat([
        iHash,
        ps,
        Buffer.alloc(1, 1),
        msg
    ], dblen), __default13(seed, dblen));
    const maskedSeed = xor1(seed, __default13(maskedDb, hLen));
    return new BN(Buffer.concat([
        Buffer.alloc(1),
        maskedSeed,
        maskedDb
    ], k32));
}
function pkcs1(key, msg, reverse3) {
    const mLen = msg.length;
    const k33 = key.modulus.byteLength();
    if (mLen > k33 - 11) {
        throw new Error("message too long");
    }
    let ps;
    if (reverse3) {
        ps = Buffer.alloc(k33 - mLen - 3, 0xff);
    } else {
        ps = nonZero(k33 - mLen - 3);
    }
    return new BN(Buffer.concat([
        Buffer.from([
            0,
            reverse3 ? 1 : 2, 
        ]),
        ps,
        Buffer.alloc(1),
        msg, 
    ], k33));
}
function nonZero(len) {
    const out = Buffer.allocUnsafe(len);
    let i233 = 0;
    let cache = randomBytes1(len * 2);
    let cur = 0;
    let num;
    while(i233 < len){
        if (cur === cache.length) {
            cache = randomBytes1(len * 2);
            cur = 0;
        }
        num = cache[cur++];
        if (num) {
            out[i233++] = num;
        }
    }
    return out;
}
function privateDecrypt(privateKey, enc, reverse4) {
    let padding;
    if (privateKey.padding) {
        padding = privateKey.padding;
    } else if (reverse4) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(privateKey);
    const k34 = key.modulus.byteLength();
    if (enc.length > k34 || new BN(enc).cmp(key.modulus) >= 0) {
        throw new Error("decryption error");
    }
    let msg;
    if (reverse4) {
        msg = withPublic(new BN(enc), key);
    } else {
        msg = crt(enc, key);
    }
    const zBuffer = Buffer.alloc(k34 - msg.length);
    msg = Buffer.concat([
        zBuffer,
        msg
    ], k34);
    if (padding === 4) {
        return oaep1(key, msg);
    } else if (padding === 1) {
        return pkcs11(key, msg, reverse4);
    } else if (padding === 3) {
        return msg;
    } else {
        throw new Error("unknown padding");
    }
}
function oaep1(key, msg) {
    const k35 = key.modulus.byteLength();
    const iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
    const hLen = iHash.length;
    if (msg[0] !== 0) {
        throw new Error("decryption error");
    }
    const maskedSeed = msg.slice(1, hLen + 1);
    const maskedDb = msg.slice(hLen + 1);
    const seed = xor1(maskedSeed, __default13(maskedDb, hLen));
    const db = xor1(maskedDb, __default13(seed, k35 - hLen - 1));
    if (compare(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
    }
    let i234 = hLen;
    while(db[i234] === 0){
        i234++;
    }
    if (db[i234++] !== 1) {
        throw new Error("decryption error");
    }
    return db.slice(i234);
}
function pkcs11(_key, msg, reverse5) {
    const p1 = msg.slice(0, 2);
    let i235 = 2;
    let status = 0;
    while(msg[i235++] !== 0){
        if (i235 >= msg.length) {
            status++;
            break;
        }
    }
    const ps = msg.slice(2, i235 - 1);
    if (p1.toString("hex") !== "0002" && !reverse5 || p1.toString("hex") !== "0001" && reverse5) {
        status++;
    }
    if (ps.length < 8) {
        status++;
    }
    if (status) {
        throw new Error("decryption error");
    }
    return msg.slice(i235);
}
function compare(a, b60) {
    a = Buffer.from(a);
    b60 = Buffer.from(b60);
    let dif = 0;
    let len = a.length;
    if (a.length !== b60.length) {
        dif++;
        len = Math.min(a.length, b60.length);
    }
    let i236 = -1;
    while(++i236 < len){
        dif += a[i236] ^ b60[i236];
    }
    return dif;
}
function privateEncrypt(key, buf) {
    return publicEncrypt(key, buf, true);
}
function publicDecrypt(key, buf) {
    return privateDecrypt(key, buf, true);
}
const randomUUID = ()=>crypto.randomUUID();
const webcrypto = crypto;
const __default14 = {
    Hash,
    createHash,
    getHashes,
    randomFill,
    randomInt,
    randomFillSync,
    pbkdf2,
    pbkdf2Sync,
    privateDecrypt,
    privateEncrypt,
    publicDecrypt,
    publicEncrypt,
    randomBytes,
    randomUUID,
    scrypt,
    scryptSync,
    timingSafeEqual,
    webcrypto
};
class Result extends Array {
    constructor(){
        super();
        Object.defineProperties(this, {
            count: {
                value: null,
                writable: true
            },
            state: {
                value: null,
                writable: true
            },
            command: {
                value: null,
                writable: true
            },
            columns: {
                value: null,
                writable: true
            },
            statement: {
                value: null,
                writable: true
            }
        });
    }
    static get [Symbol.species]() {
        return Array;
    }
}
function Queue(initial = []) {
    let xs = initial.slice();
    let index1 = 0;
    return {
        get length () {
            return xs.length - index1;
        },
        remove: (x)=>{
            const index = xs.indexOf(x);
            return index === -1 ? null : (xs.splice(index, 1), x);
        },
        push: (x)=>(xs.push(x), x),
        shift: ()=>{
            const out = xs[index1++];
            if (index1 === xs.length) {
                index1 = 0;
                xs = [];
            } else {
                xs[index1 - 1] = undefined;
            }
            return out;
        }
    };
}
const size = 256;
let buffer = Buffer.allocUnsafe(256);
const messages = 'BCcDdEFfHPpQSX'.split('').reduce((acc, x)=>{
    const v = x.charCodeAt(0);
    acc[x] = ()=>{
        buffer[0] = v;
        b.i = 5;
        return b;
    };
    return acc;
}, {});
const b = Object.assign(reset, messages, {
    N: String.fromCharCode(0),
    i: 0,
    inc (x) {
        b.i += x;
        return b;
    },
    str (x) {
        const length = Buffer.byteLength(x);
        fit(length);
        b.i += buffer.write(x, b.i, length, 'utf8');
        return b;
    },
    i16 (x) {
        fit(2);
        buffer.writeUInt16BE(x, b.i);
        b.i += 2;
        return b;
    },
    i32 (x, i237) {
        if (i237 || i237 === 0) {
            buffer.writeUInt32BE(x, i237);
            return b;
        }
        fit(4);
        buffer.writeUInt32BE(x, b.i);
        b.i += 4;
        return b;
    },
    z (x) {
        fit(x);
        buffer.fill(0, b.i, b.i + x);
        b.i += x;
        return b;
    },
    raw (x) {
        buffer = Buffer.concat([
            buffer.slice(0, b.i),
            x
        ]);
        b.i = buffer.length;
        return b;
    },
    end (at = 1) {
        buffer.writeUInt32BE(b.i - at, at);
        const out = buffer.slice(0, b.i);
        b.i = 0;
        buffer = Buffer.allocUnsafe(size);
        return out;
    }
});
function fit(x) {
    if (buffer.length - b.i < x) {
        const prev = buffer, length = prev.length;
        buffer = Buffer.allocUnsafe(length + (length >> 1) + x);
        prev.copy(buffer);
    }
}
function reset() {
    b.i = 0;
    return b;
}
let uid = 1;
const Sync = b().S().end(), Flush = b().H().end(), SSLRequest = b().i32(8).i32(80877103).end(8), ExecuteUnnamed = Buffer.concat([
    b().E().str(b.N).i32(0).end(),
    Sync
]), DescribeUnnamed = b().D().str('S').str(b.N).end(), noop1 = ()=>{};
const retryRoutines = new Set([
    'FetchPreparedStatement',
    'RevalidateCachedQuery',
    'transformAssignedExpr'
]);
const errorFields = {
    83: 'severity_local',
    86: 'severity',
    67: 'code',
    77: 'message',
    68: 'detail',
    72: 'hint',
    80: 'position',
    112: 'internal_position',
    113: 'internal_query',
    87: 'where',
    115: 'schema_name',
    116: 'table_name',
    99: 'column_name',
    100: 'data type_name',
    110: 'constraint_name',
    70: 'file',
    76: 'line',
    82: 'routine'
};
function Connection(options, queues = {}, { onopen =noop1 , onend =noop1 , onclose =noop1  } = {}) {
    const { ssl , max , user , host , port: port5 , database , parsers: parsers1 , transform , onnotice , onnotify , onparameter , max_pipeline , keep_alive , backoff: backoff1 , target_session_attrs  } = options;
    const sent = Queue(), id8 = uid++, backend = {
        pid: null,
        secret: null
    }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
    let socket = null, cancelMessage, result = new Result(), incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length1 = 0, delay1 = 0, rows1 = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream2 = null, chunk1 = null, ended = null, nonce = null, query1 = null, __final3 = null;
    const connection1 = {
        queue: queues.closed,
        idleTimer,
        connect (query) {
            initial = query;
            reconnect();
        },
        terminate,
        execute,
        cancel,
        end,
        count: 0,
        id: id8
    };
    queues.closed && queues.closed.push(connection1);
    return connection1;
    async function createSocket() {
        let x;
        try {
            x = options.socket ? await Promise.resolve(options.socket(options)) : net.Socket();
        } catch (e) {
            error1(e);
            return;
        }
        x.on('error', error1);
        x.on('close', closed);
        x.on('drain', drain);
        return x;
    }
    async function cancel({ pid: pid4 , secret  }, resolve20, reject) {
        try {
            cancelMessage = b().i32(16).i32(80877102).i32(pid4).i32(secret).end(16);
            await connect();
            socket.once('error', reject);
            socket.once('close', resolve20);
        } catch (error21) {
            reject(error21);
        }
    }
    function execute(q) {
        if (terminated) return queryError(q, Errors.connection('CONNECTION_DESTROYED', options));
        if (q.cancelled) return;
        try {
            q.state = backend;
            query1 ? sent.push(q) : (query1 = q, query1.active = true);
            build(q);
            return write2(toBuffer1(q)) && !q.describeFirst && sent.length < max_pipeline && (!q.options.onexecute || q.options.onexecute(connection1));
        } catch (error22) {
            sent.length === 0 && write2(Sync);
            errored(error22);
            return true;
        }
    }
    function toBuffer1(q) {
        if (q.parameters.length >= 65534) throw Errors.generic('MAX_PARAMETERS_EXCEEDED', 'Max number of parameters (65534) exceeded');
        return q.options.simple ? b().Q().str(q.strings[0] + b.N).end() : q.describeFirst ? Buffer.concat([
            describe(q),
            Flush
        ]) : q.prepare ? q.prepared ? prepared(q) : Buffer.concat([
            describe(q),
            prepared(q)
        ]) : unnamed(q);
    }
    function describe(q) {
        return Buffer.concat([
            Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),
            Describe('S', q.statement.name)
        ]);
    }
    function prepared(q) {
        return Buffer.concat([
            Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),
            q.cursorFn ? Execute('', q.cursorRows) : ExecuteUnnamed
        ]);
    }
    function unnamed(q) {
        return Buffer.concat([
            Parse(q.statement.string, q.parameters, q.statement.types),
            DescribeUnnamed,
            prepared(q)
        ]);
    }
    function build(q) {
        const parameters = [], types13 = [];
        const string = stringify1(q, q.strings[0], q.args[0], parameters, types13, options);
        !q.tagged && q.args.forEach((x)=>handleValue(x, parameters, types13, options));
        q.prepare = options.prepare && ('prepare' in q.options ? q.options.prepare : true);
        q.string = string;
        q.signature = q.prepare && types13 + string;
        q.onlyDescribe && delete statements[q.signature];
        q.parameters = q.parameters || parameters;
        q.prepared = q.prepare && q.signature in statements;
        q.describeFirst = q.onlyDescribe || parameters.length && !q.prepared;
        q.statement = q.prepared ? statements[q.signature] : {
            string,
            types: types13,
            name: q.prepare ? statementId + statementCount++ : ''
        };
        typeof options.debug === 'function' && options.debug(id8, string, parameters, types13);
    }
    function write2(x, fn) {
        chunk1 = chunk1 ? Buffer.concat([
            chunk1,
            x
        ]) : Buffer.from(x);
        if (fn || chunk1.length >= 1024) return nextWrite(fn);
        nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
        return true;
    }
    function nextWrite(fn) {
        const x = socket.write(chunk1, fn);
        nextWriteTimer !== null && clearImmediate(nextWriteTimer);
        chunk1 = nextWriteTimer = null;
        return x;
    }
    function connectTimedOut() {
        errored(Errors.connection('CONNECT_TIMEOUT', options, socket));
        socket.destroy();
    }
    async function secure() {
        write2(SSLRequest);
        const canSSL = await new Promise((r)=>socket.once('data', (x)=>r(x[0] === 83)));
        if (!canSSL && ssl === 'prefer') return connected();
        socket.removeAllListeners();
        socket = tls.connect({
            socket,
            ...ssl === 'require' || ssl === 'allow' || ssl === 'prefer' ? {
                rejectUnauthorized: false
            } : ssl === 'verify-full' ? {} : typeof ssl === 'object' ? ssl : {}
        });
        socket.on('secureConnect', connected);
        socket.on('error', error1);
        socket.on('close', closed);
        socket.on('drain', drain);
    }
    function drain() {
        !query1 && onopen(connection1);
    }
    function data62(x) {
        if (incomings) {
            incomings.push(x);
            remaining -= x.length;
            if (remaining >= 0) return;
        }
        incoming = incomings ? Buffer.concat(incomings, length1 - remaining) : incoming.length === 0 ? x : Buffer.concat([
            incoming,
            x
        ], incoming.length + x.length);
        while(incoming.length > 4){
            length1 = incoming.readUInt32BE(1);
            if (length1 >= incoming.length) {
                remaining = length1 - incoming.length;
                incomings = [
                    incoming
                ];
                break;
            }
            try {
                handle(incoming.slice(0, length1 + 1));
            } catch (e) {
                query1 && (query1.cursorFn || query1.describeFirst) && write2(Sync);
                errored(e);
            }
            incoming = incoming.slice(length1 + 1);
            remaining = 0;
            incomings = null;
        }
    }
    async function connect() {
        terminated = false;
        backendParameters = {};
        socket || (socket = await createSocket());
        if (!socket) return;
        connectTimer.start();
        if (options.socket) return ssl ? secure() : connected();
        socket.on('connect', ssl ? secure : connected);
        if (options.path) return socket.connect(options.path);
        socket.connect(port5[hostIndex], host[hostIndex]);
        hostIndex = (hostIndex + 1) % port5.length;
    }
    function reconnect() {
        setTimeout(connect, closedDate ? closedDate + delay1 - Number(process1.hrtime.bigint() / 1000000n) : 0);
    }
    function connected() {
        try {
            statements = {};
            needsTypes = options.fetch_types;
            statementId = Math.random().toString(36).slice(2);
            statementCount = 1;
            lifeTimer.start();
            socket.on('data', data62);
            keep_alive && socket.setKeepAlive(true);
            const s = StartupMessage();
            write2(s);
        } catch (err) {
            error1(err);
        }
    }
    function error1(err) {
        if (connection1.queue === queues.connecting && options.host[retries + 1]) return;
        errored(err);
        while(sent.length)queryError(sent.shift(), err);
    }
    function errored(err) {
        stream2 && (stream2.destroy(err), stream2 = null);
        query1 && queryError(query1, err);
        initial && (queryError(initial, err), initial = null);
    }
    function queryError(query, err) {
        query.reject(Object.create(err, {
            stack: {
                value: err.stack + query.origin.replace(/.*\n/, '\n'),
                enumerable: options.debug
            },
            query: {
                value: query.string,
                enumerable: options.debug
            },
            parameters: {
                value: query.parameters,
                enumerable: options.debug
            },
            args: {
                value: query.args,
                enumerable: options.debug
            },
            types: {
                value: query.statement && query.statement.types,
                enumerable: options.debug
            }
        }));
    }
    function end() {
        return ending || (!connection1.reserved && onend(connection1), !connection1.reserved && !initial && !query1 && sent.length === 0 ? (terminate(), new Promise((r)=>socket && socket.readyState !== 'closed' ? socket.once('close', r) : r())) : ending = new Promise((r)=>ended = r));
    }
    function terminate() {
        terminated = true;
        if (stream2 || query1 || initial || sent.length) error1(Errors.connection('CONNECTION_DESTROYED', options));
        clearImmediate(nextWriteTimer);
        if (socket) {
            socket.removeListener('data', data62);
            socket.removeListener('connect', connected);
            socket.readyState === 'open' && socket.end(b().X().end());
        }
        ended && (ended(), ending = ended = null);
    }
    async function closed(hadError) {
        incoming = Buffer.alloc(0);
        remaining = 0;
        incomings = null;
        clearImmediate(nextWriteTimer);
        socket.removeListener('data', data62);
        socket.removeListener('connect', connected);
        idleTimer.cancel();
        lifeTimer.cancel();
        connectTimer.cancel();
        if (socket.encrypted) {
            socket.removeAllListeners();
            socket = null;
        }
        if (initial) return reconnect();
        !hadError && (query1 || sent.length) && error1(Errors.connection('CONNECTION_CLOSED', options, socket));
        closedDate = Number(process1.hrtime.bigint() / 1000000n);
        hadError && options.shared.retries++;
        delay1 = (typeof backoff1 === 'function' ? backoff1(options.shared.retries) : backoff1) * 1000;
        onclose(connection1);
    }
    function handle(xs, x = xs[0]) {
        (x === 68 ? DataRow : x === 100 ? CopyData : x === 65 ? NotificationResponse : x === 83 ? ParameterStatus : x === 90 ? ReadyForQuery : x === 67 ? CommandComplete : x === 50 ? BindComplete : x === 49 ? ParseComplete : x === 116 ? ParameterDescription : x === 84 ? RowDescription : x === 82 ? Authentication : x === 110 ? NoData : x === 75 ? BackendKeyData : x === 69 ? ErrorResponse : x === 115 ? PortalSuspended : x === 51 ? CloseComplete : x === 71 ? CopyInResponse : x === 78 ? NoticeResponse : x === 72 ? CopyOutResponse : x === 99 ? CopyDone : x === 73 ? EmptyQueryResponse : x === 86 ? FunctionCallResponse : x === 118 ? NegotiateProtocolVersion : x === 87 ? CopyBothResponse : UnknownMessage)(xs);
    }
    function DataRow(x) {
        let index = 7;
        let length;
        let column;
        let value;
        const row = query1.isRaw ? new Array(query1.statement.columns.length) : {};
        for(let i238 = 0; i238 < query1.statement.columns.length; i238++){
            column = query1.statement.columns[i238];
            length = x.readInt32BE(index);
            index += 4;
            value = length === -1 ? null : query1.isRaw === true ? x.slice(index, index += length) : column.parser === undefined ? x.toString('utf8', index, index += length) : column.parser.array === true ? column.parser(x.toString('utf8', index + 1, index += length)) : column.parser(x.toString('utf8', index, index += length));
            query1.isRaw ? row[i238] = query1.isRaw === true ? value : transform.value.from ? transform.value.from(value) : value : row[column.name] = transform.value.from ? transform.value.from(value) : value;
        }
        query1.forEachFn ? query1.forEachFn(transform.row.from ? transform.row.from(row) : row, result) : result[rows1++] = transform.row.from ? transform.row.from(row) : row;
    }
    function ParameterStatus(x) {
        const [k36, v] = x.toString('utf8', 5, x.length - 1).split(b.N);
        backendParameters[k36] = v;
        if (options.parameters[k36] !== v) {
            options.parameters[k36] = v;
            onparameter && onparameter(k36, v);
        }
    }
    function ReadyForQuery(x) {
        query1 && query1.options.simple && query1.resolve(results || result);
        query1 = results = null;
        result = new Result();
        connectTimer.cancel();
        if (initial) {
            if (target_session_attrs) {
                if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only) return fetchState();
                else if (tryNext(target_session_attrs, backendParameters)) return terminate();
            }
            if (needsTypes) return fetchArrayTypes();
            execute(initial);
            options.shared.retries = retries = initial = 0;
            return;
        }
        while(sent.length && (query1 = sent.shift()) && (query1.active = true, query1.cancelled))Connection(options).cancel(query1.state, query1.cancelled.resolve, query1.cancelled.reject);
        if (query1) return;
        connection1.reserved ? x[5] === 73 ? ending ? terminate() : (connection1.reserved = null, onopen(connection1)) : connection1.reserved() : ending ? terminate() : onopen(connection1);
    }
    function CommandComplete(x) {
        rows1 = 0;
        for(let i239 = x.length - 1; i239 > 0; i239--){
            if (x[i239] === 32 && x[i239 + 1] < 58 && result.count === null) result.count = +x.toString('utf8', i239 + 1, x.length - 1);
            if (x[i239 - 1] >= 65) {
                result.command = x.toString('utf8', 5, i239);
                result.state = backend;
                break;
            }
        }
        __final3 && (__final3(), __final3 = null);
        if (result.command === 'BEGIN' && max !== 1 && !connection1.reserved) return errored(Errors.generic('UNSAFE_TRANSACTION', 'Only use sql.begin or max: 1'));
        if (query1.options.simple) return BindComplete();
        if (query1.cursorFn) {
            result.count && query1.cursorFn(result);
            write2(Sync);
        }
        query1.resolve(result);
    }
    function ParseComplete() {
        query1.parsing = false;
    }
    function BindComplete() {
        !result.statement && (result.statement = query1.statement);
        result.columns = query1.statement.columns;
    }
    function ParameterDescription(x) {
        const length = x.readUInt16BE(5);
        for(let i240 = 0; i240 < length; ++i240)!query1.statement.types[i240] && (query1.statement.types[i240] = x.readUInt32BE(7 + i240 * 4));
        query1.prepare && (statements[query1.signature] = query1.statement);
        query1.describeFirst && !query1.onlyDescribe && (write2(prepared(query1)), query1.describeFirst = false);
    }
    function RowDescription(x) {
        if (result.command) {
            results = results || [
                result
            ];
            results.push(result = new Result());
            result.count = null;
            query1.statement.columns = null;
        }
        const length = x.readUInt16BE(5);
        let index = 7;
        let start;
        query1.statement.columns = Array(length);
        for(let i241 = 0; i241 < length; ++i241){
            start = index;
            while(x[index++] !== 0);
            const type53 = x.readUInt32BE(index + 6);
            query1.statement.columns[i241] = {
                name: transform.column.from ? transform.column.from(x.toString('utf8', start, index - 1)) : x.toString('utf8', start, index - 1),
                parser: parsers1[type53],
                type: type53
            };
            index += 18;
        }
        result.statement = query1.statement;
        if (query1.onlyDescribe) return query1.resolve(query1.statement), write2(Sync);
    }
    async function Authentication(x, type54 = x.readUInt32BE(5)) {
        (type54 === 3 ? AuthenticationCleartextPassword : type54 === 5 ? AuthenticationMD5Password : type54 === 10 ? SASL : type54 === 11 ? SASLContinue : type54 === 12 ? SASLFinal : type54 !== 0 ? UnknownAuth : noop1)(x, type54);
    }
    async function AuthenticationCleartextPassword() {
        write2(b().p().str(await Pass()).z(1).end());
    }
    async function AuthenticationMD5Password(x) {
        write2(b().p().str('md5' + md5(Buffer.concat([
            Buffer.from(md5(await Pass() + user)),
            x.slice(9)
        ]))).z(1).end());
    }
    function SASL() {
        b().p().str('SCRAM-SHA-256' + b.N);
        const i242 = b.i;
        nonce = __default14.randomBytes(18).toString('base64');
        write2(b.inc(4).str('n,,n=*,r=' + nonce).i32(b.i - i242 - 4, i242).end());
    }
    async function SASLContinue(x1) {
        const res = x1.toString('utf8', 9).split(',').reduce((acc, x)=>(acc[x[0]] = x.slice(2), acc), {});
        const saltedPassword = __default14.pbkdf2Sync(await Pass(), Buffer.from(res.s, 'base64'), parseInt(res.i), 32, 'sha256');
        const clientKey = hmac(saltedPassword, 'Client Key');
        const auth = 'n=*,r=' + nonce + ',' + 'r=' + res.r + ',s=' + res.s + ',i=' + res.i + ',c=biws,r=' + res.r;
        serverSignature = hmac(hmac(saltedPassword, 'Server Key'), auth).toString('base64');
        write2(b().p().str('c=biws,r=' + res.r + ',p=' + xor2(clientKey, hmac(sha256(clientKey), auth)).toString('base64')).end());
    }
    function SASLFinal(x) {
        if (x.toString('utf8', 9).split(b.N, 1)[0].slice(2) === serverSignature) return;
        errored(Errors.generic('SASL_SIGNATURE_MISMATCH', 'The server did not return the correct signature'));
        socket.destroy();
    }
    function Pass() {
        return Promise.resolve(typeof options.pass === 'function' ? options.pass() : options.pass);
    }
    function NoData() {
        result.statement = query1.statement;
        result.statement.columns = [];
        if (query1.onlyDescribe) return query1.resolve(query1.statement), write2(Sync);
    }
    function BackendKeyData(x) {
        backend.pid = x.readUInt32BE(5);
        backend.secret = x.readUInt32BE(9);
    }
    async function fetchArrayTypes() {
        needsTypes = false;
        const types14 = await new Query([
            `
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `
        ], [], execute);
        types14.forEach(({ oid , typarray  })=>addArrayType(oid, typarray));
    }
    function addArrayType(oid, typarray) {
        const parser = options.parsers[oid];
        options.shared.typeArrayMap[oid] = typarray;
        options.parsers[typarray] = (xs)=>arrayParser(xs, parser);
        options.parsers[typarray].array = true;
        options.serializers[typarray] = (xs)=>arraySerializer(xs, options.serializers[oid], options);
    }
    function tryNext(x, xs) {
        return x === 'read-write' && xs.default_transaction_read_only === 'on' || x === 'read-only' && xs.default_transaction_read_only === 'off' || x === 'primary' && xs.in_hot_standby === 'off' || x === 'standby' && xs.in_hot_standby === 'on' || x === 'prefer-standby' && xs.in_hot_standby === 'off' && options.host[retries];
    }
    function fetchState() {
        const query = new Query([
            `
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `
        ], [], execute, null, {
            simple: true
        });
        query.resolve = ([[a], [b1]])=>{
            backendParameters.default_transaction_read_only = a.transaction_read_only;
            backendParameters.in_hot_standby = b1.pg_is_in_recovery ? 'on' : 'off';
        };
        query.execute();
    }
    function ErrorResponse(x) {
        query1 && (query1.cursorFn || query1.describeFirst) && write2(Sync);
        const error23 = Errors.postgres(parseError(x));
        query1 && query1.retried ? errored(query1.retried) : query1 && retryRoutines.has(error23.routine) ? retry(query1, error23) : errored(error23);
    }
    function retry(q, error24) {
        delete statements[q.signature];
        q.retried = error24;
        execute(q);
    }
    function NotificationResponse(x) {
        if (!onnotify) return;
        let index = 9;
        while(x[index++] !== 0);
        onnotify(x.toString('utf8', 9, index - 1), x.toString('utf8', index, x.length - 1));
    }
    async function PortalSuspended() {
        try {
            const x = await Promise.resolve(query1.cursorFn(result));
            rows1 = 0;
            x === CLOSE ? write2(Close(query1.portal)) : (result = new Result(), write2(Execute('', query1.cursorRows)));
        } catch (err) {
            write2(Sync);
            query1.reject(err);
        }
    }
    function CloseComplete() {
        result.count && query1.cursorFn(result);
        query1.resolve(result);
    }
    function CopyInResponse() {
        stream2 = new Stream.Writable({
            autoDestroy: true,
            write (chunk, encoding, callback) {
                socket.write(b().d().raw(chunk).end(), callback);
            },
            destroy (error25, callback) {
                callback(error25);
                socket.write(b().f().str(error25 + b.N).end());
                stream2 = null;
            },
            final (callback) {
                socket.write(b().c().end());
                __final3 = callback;
            }
        });
        query1.resolve(stream2);
    }
    function CopyOutResponse() {
        stream2 = new Stream.Readable({
            read () {
                socket.resume();
            }
        });
        query1.resolve(stream2);
    }
    function CopyBothResponse() {
        stream2 = new Stream.Duplex({
            autoDestroy: true,
            read () {
                socket.resume();
            },
            write (chunk, encoding, callback) {
                socket.write(b().d().raw(chunk).end(), callback);
            },
            destroy (error26, callback) {
                callback(error26);
                socket.write(b().f().str(error26 + b.N).end());
                stream2 = null;
            },
            final (callback) {
                socket.write(b().c().end());
                __final3 = callback;
            }
        });
        query1.resolve(stream2);
    }
    function CopyData(x) {
        stream2.push(x.slice(5)) || socket.pause();
    }
    function CopyDone() {
        stream2.push(null);
        stream2 = null;
    }
    function NoticeResponse(x) {
        onnotice ? onnotice(parseError(x)) : console.log(parseError(x));
    }
    function EmptyQueryResponse() {}
    function FunctionCallResponse() {
        errored(Errors.notSupported('FunctionCallResponse'));
    }
    function NegotiateProtocolVersion() {
        errored(Errors.notSupported('NegotiateProtocolVersion'));
    }
    function UnknownMessage(x) {
        console.error('Postgres.js : Unknown Message:', x[0]);
    }
    function UnknownAuth(x, type55) {
        console.error('Postgres.js : Unknown Auth:', type55);
    }
    function Bind(parameters, types15, statement = '', portal = '') {
        let prev, type56;
        b().B().str(portal + b.N).str(statement + b.N).i16(0).i16(parameters.length);
        parameters.forEach((x, i243)=>{
            if (x === null) return b.i32(0xFFFFFFFF);
            type56 = types15[i243];
            parameters[i243] = x = type56 in options.serializers ? options.serializers[type56](x) : '' + x;
            prev = b.i;
            b.inc(4).str(x).i32(b.i - prev - 4, prev);
        });
        b.i16(0);
        return b.end();
    }
    function Parse(str, parameters, types16, name60 = '') {
        b().P().str(name60 + b.N).str(str + b.N).i16(parameters.length);
        parameters.forEach((x, i244)=>b.i32(types16[i244] || 0));
        return b.end();
    }
    function Describe(x, name61 = '') {
        return b().D().str(x).str(name61 + b.N).end();
    }
    function Execute(portal = '', rows = 0) {
        return Buffer.concat([
            b().E().str(portal + b.N).i32(rows).end(),
            Flush
        ]);
    }
    function Close(portal = '') {
        return Buffer.concat([
            b().C().str('P').str(portal + b.N).end(),
            b().S().end()
        ]);
    }
    function StartupMessage() {
        return cancelMessage || b().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
            user,
            database,
            client_encoding: 'UTF8'
        }, options.connection)).filter(([, v])=>v).map(([k37, v])=>k37 + b.N + v).join(b.N)).z(2).end(0);
    }
}
function parseError(x) {
    const error27 = {};
    let start = 5;
    for(let i245 = 5; i245 < x.length - 1; i245++){
        if (x[i245] === 0) {
            error27[errorFields[x[start]]] = x.toString('utf8', start + 1, i245);
            start = i245 + 1;
        }
    }
    return error27;
}
function md5(x) {
    return __default14.createHash('md5').update(x).digest('hex');
}
function hmac(key, x) {
    return Buffer.from(new HmacSha256(key).update(x).digest());
}
function sha256(x) {
    return __default14.createHash('sha256').update(x).digest();
}
function xor2(a, b2) {
    const length = Math.max(a.length, b2.length);
    const buffer51 = Buffer.allocUnsafe(length);
    for(let i246 = 0; i246 < length; i246++)buffer51[i246] = a[i246] ^ b2[i246];
    return buffer51;
}
function timer(fn, seconds) {
    seconds = typeof seconds === 'function' ? seconds() : seconds;
    if (!seconds) return {
        cancel: noop1,
        start: noop1
    };
    let timer1;
    return {
        cancel () {
            timer1 && (clearTimeout(timer1), timer1 = null);
        },
        start () {
            timer1 && clearTimeout(timer1);
            timer1 = setTimeout(done, seconds * 1000, arguments);
        }
    };
    function done(args) {
        fn.apply(null, args);
        timer1 = null;
    }
}
const noop2 = ()=>{};
function Subscribe(postgres1, options) {
    const subscribers = new Map(), slot1 = 'postgresjs_' + Math.random().toString(36).slice(2), state1 = {};
    let connection2, stream1, ended = false;
    const sql1 = subscribe.sql = postgres1({
        ...options,
        max: 1,
        fetch_types: false,
        idle_timeout: null,
        max_lifetime: null,
        connection: {
            ...options.connection,
            replication: 'database'
        },
        onclose: async function() {
            if (ended) return;
            stream1 = null;
            state1.pid = state1.secret = undefined;
            connected(await init(sql1, slot1, options.publications));
            subscribers.forEach((event)=>event.forEach(({ onsubscribe  })=>onsubscribe()));
        },
        no_subscribe: true
    });
    const end = sql1.end, close5 = sql1.close;
    sql1.end = async ()=>{
        ended = true;
        stream1 && await new Promise((r)=>(stream1.once('end', r), stream1.end()));
        return end();
    };
    sql1.close = async ()=>{
        stream1 && await new Promise((r)=>(stream1.once('end', r), stream1.end()));
        return close5();
    };
    return subscribe;
    async function subscribe(event, fn, onsubscribe = noop2) {
        event = parseEvent(event);
        if (!connection2) connection2 = init(sql1, slot1, options.publications);
        const subscriber = {
            fn,
            onsubscribe
        };
        const fns = subscribers.has(event) ? subscribers.get(event).add(subscriber) : subscribers.set(event, new Set([
            subscriber
        ])).get(event);
        const unsubscribe = ()=>{
            fns.delete(subscriber);
            fns.size === 0 && subscribers.delete(event);
        };
        return connection2.then((x)=>{
            connected(x);
            onsubscribe();
            return {
                unsubscribe,
                state: state1,
                sql: sql1
            };
        });
    }
    function connected(x) {
        stream1 = x.stream;
        state1.pid = x.state.pid;
        state1.secret = x.state.secret;
    }
    async function init(sql, slot, publications) {
        if (!publications) throw new Error('Missing publication names');
        const xs = await sql.unsafe(`CREATE_REPLICATION_SLOT ${slot} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
        const [x1] = xs;
        const stream3 = await sql.unsafe(`START_REPLICATION SLOT ${slot} LOGICAL ${x1.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
        const state99 = {
            lsn: Buffer.concat(x1.consistent_point.split('/').map((x)=>Buffer.from(('00000000' + x).slice(-8), 'hex')))
        };
        stream3.on('data', data63);
        stream3.on('error', sql.close);
        stream3.on('close', sql.close);
        return {
            stream: stream3,
            state: xs.state
        };
        function data63(x) {
            if (x[0] === 0x77) parse9(x.slice(25), state99, sql.options.parsers, handle);
            else if (x[0] === 0x6b && x[17]) pong();
        }
        function handle(a, b61) {
            const path115 = b61.relation.schema + '.' + b61.relation.table;
            call('*', a, b61);
            call('*:' + path115, a, b61);
            b61.relation.keys.length && call('*:' + path115 + '=' + b61.relation.keys.map((x)=>a[x.name]), a, b61);
            call(b61.command, a, b61);
            call(b61.command + ':' + path115, a, b61);
            b61.relation.keys.length && call(b61.command + ':' + path115 + '=' + b61.relation.keys.map((x)=>a[x.name]), a, b61);
        }
        function pong() {
            const x = Buffer.alloc(34);
            x[0] = 'r'.charCodeAt(0);
            x.fill(state99.lsn, 1);
            x.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
            stream3.write(x);
        }
    }
    function call(x, a, b62) {
        subscribers.has(x) && subscribers.get(x).forEach(({ fn  })=>fn(a, b62, x));
    }
}
function Time1(x) {
    return new Date(Date.UTC(2000, 0, 1) + Number(x / BigInt(1000)));
}
function parse9(x2, state100, parsers2, handle) {
    const __char = (acc, [k38, v])=>(acc[k38.charCodeAt(0)] = v, acc);
    Object.entries({
        R: (x)=>{
            let i247 = 1;
            const r = state100[x.readUInt32BE(i247)] = {
                schema: String(x.slice(i247 += 4, i247 = x.indexOf(0, i247))) || 'pg_catalog',
                table: String(x.slice(i247 + 1, i247 = x.indexOf(0, i247 + 1))),
                columns: Array(x.readUInt16BE(i247 += 2)),
                keys: []
            };
            i247 += 2;
            let columnIndex = 0, column;
            while(i247 < x.length){
                column = r.columns[columnIndex++] = {
                    key: x[i247++],
                    name: String(x.slice(i247, i247 = x.indexOf(0, i247))),
                    type: x.readUInt32BE(i247 += 1),
                    parser: parsers2[x.readUInt32BE(i247)],
                    atttypmod: x.readUInt32BE(i247 += 4)
                };
                column.key && r.keys.push(column);
                i247 += 4;
            }
        },
        Y: ()=>{},
        O: ()=>{},
        B: (x)=>{
            state100.date = Time1(x.readBigInt64BE(9));
            state100.lsn = x.slice(1, 9);
        },
        I: (x)=>{
            let i248 = 1;
            const relation = state100[x.readUInt32BE(i248)];
            const row = {};
            tuples(x, row, relation.columns, i248 += 7);
            handle(row, {
                command: 'insert',
                relation
            });
        },
        D: (x)=>{
            let i249 = 1;
            const relation = state100[x.readUInt32BE(i249)];
            i249 += 4;
            const key = x[i249] === 75;
            const row = key || x[i249] === 79 ? {} : null;
            tuples(x, row, key ? relation.keys : relation.columns, i249 += 3);
            handle(row, {
                command: 'delete',
                relation,
                key
            });
        },
        U: (x)=>{
            let i250 = 1;
            const relation = state100[x.readUInt32BE(i250)];
            i250 += 4;
            const key = x[i250] === 75;
            const old = key || x[i250] === 79 ? {} : null;
            old && (i250 = tuples(x, old, key ? relation.keys : relation.columns, i250 += 3));
            const row = {};
            tuples(x, row, relation.columns, i250 + 3);
            handle(row, {
                command: 'update',
                relation,
                key,
                old
            });
        },
        T: ()=>{},
        C: ()=>{}
    }).reduce(__char, {})[x2[0]](x2);
}
function tuples(x, row, columns, xi) {
    let type57, column;
    for(let i251 = 0; i251 < columns.length; i251++){
        type57 = x[xi++];
        column = columns[i251];
        row[column.name] = type57 === 110 ? null : type57 === 117 ? undefined : column.parser === undefined ? x.toString('utf8', xi + 4, xi += 4 + x.readUInt32BE(xi)) : column.parser.array === true ? column.parser(x.toString('utf8', xi + 5, xi += 4 + x.readUInt32BE(xi))) : column.parser(x.toString('utf8', xi + 4, xi += 4 + x.readUInt32BE(xi)));
    }
    return xi;
}
function parseEvent(x) {
    const xs = x.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
    if (!xs) throw new Error('Malformed subscribe pattern: ' + x);
    const [, command, path116, key] = xs;
    return (command || '*') + (path116 ? ':' + (path116.indexOf('.') === -1 ? 'public.' + path116 : path116) : '') + (key ? '=' + key : '');
}
function largeObject(sql1, oid, mode24 = 0x00020000 | 0x00040000) {
    return new Promise(async (resolve21, reject)=>{
        await sql1.begin(async (sql)=>{
            let finish3;
            !oid && ([{ oid  }] = await sql`select lo_creat(-1) as oid`);
            const [{ fd  }] = await sql`select lo_open(${oid}, ${mode24}) as fd`;
            const lo = {
                writable,
                readable,
                close: ()=>sql`select lo_close(${fd})`.then(finish3),
                tell: ()=>sql`select lo_tell64(${fd})`,
                read: (x)=>sql`select loread(${fd}, ${x}) as data`,
                write: (x)=>sql`select lowrite(${fd}, ${x})`,
                truncate: (x)=>sql`select lo_truncate64(${fd}, ${x})`,
                seek: (x, whence = 0)=>sql`select lo_lseek64(${fd}, ${x}, ${whence})`,
                size: ()=>sql`
          select
            lo_lseek64(${fd}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
            };
            resolve21(lo);
            return new Promise(async (r)=>finish3 = r);
            async function readable({ highWaterMark =2048 * 8 , start =0 , end =Infinity  } = {}) {
                let max = end - start;
                start && await lo.seek(start);
                return new Stream.Readable({
                    highWaterMark,
                    async read (size35) {
                        const l = size35 > max ? size35 - max : size35;
                        max -= size35;
                        const [{ data: data64  }] = await lo.read(l);
                        this.push(data64);
                        if (data64.length < size35) this.push(null);
                    }
                });
            }
            async function writable({ highWaterMark =2048 * 8 , start =0  } = {}) {
                start && await lo.seek(start);
                return new Stream.Writable({
                    highWaterMark,
                    write (chunk, encoding, callback) {
                        lo.write(chunk).then(()=>callback(), callback);
                    }
                });
            }
        }).catch(reject);
    });
}
Object.assign(Postgres, {
    PostgresError,
    toPascal,
    toCamel,
    toKebab,
    fromPascal,
    fromCamel,
    fromKebab,
    BigInt: {
        to: 20,
        from: [
            20
        ],
        parse: (x)=>BigInt(x),
        serialize: (x)=>x.toString()
    }
});
function Postgres(a, b63) {
    const options1 = parseOptions(a, b63), subscribe = options1.no_subscribe || Subscribe(Postgres, {
        ...options1
    });
    let ending = false;
    const queries1 = Queue(), connecting = Queue(), reserved = Queue(), closed = Queue(), ended = Queue(), open3 = Queue(), busy = Queue(), full = Queue(), queues = {
        connecting,
        reserved,
        closed,
        ended,
        open: open3,
        busy,
        full
    };
    const connections = [
        ...Array(options1.max)
    ].map(()=>Connection(options1, queues, {
            onopen,
            onend,
            onclose
        }));
    const sql1 = Sql(handler1);
    Object.assign(sql1, {
        get parameters () {
            return options1.parameters;
        },
        largeObject: largeObject.bind(null, sql1),
        subscribe,
        CLOSE,
        END: CLOSE,
        PostgresError,
        options: options1,
        listen,
        notify,
        begin,
        close: close6,
        end
    });
    return sql1;
    function Sql(handler, instant) {
        handler.debug = options1.debug;
        Object.entries(options1.types).reduce((acc, [name62, type58])=>{
            acc[name62] = (x)=>new Parameter(x, type58.to);
            return acc;
        }, typed);
        Object.assign(sql, {
            types: typed,
            typed,
            unsafe,
            array,
            json,
            file
        });
        return sql;
        function typed(value, type59) {
            return new Parameter(value, type59);
        }
        function sql(strings, ...args) {
            const query = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler, cancel) : typeof strings === 'string' && !args.length ? new Identifier(options1.transform.column.to ? options1.transform.column.to(strings) : strings) : new Builder(strings, args);
            instant && query instanceof Query && query.execute();
            return query;
        }
        function unsafe(string, args = [], options = {}) {
            arguments.length === 2 && !Array.isArray(args) && (options = args, args = []);
            const query = new Query([
                string
            ], args, handler, cancel, {
                prepare: false,
                ...options,
                simple: 'simple' in options ? options.simple : args.length === 0
            });
            instant && query.execute();
            return query;
        }
        function file(path117, args = [], options = {}) {
            arguments.length === 2 && !Array.isArray(args) && (options = args, args = []);
            const query1 = new Query([], args, (query)=>{
                __default10.readFile(path117, 'utf8', (err, string)=>{
                    if (err) return query.reject(err);
                    query.strings = [
                        string
                    ];
                    handler(query);
                });
            }, cancel, {
                ...options,
                simple: 'simple' in options ? options.simple : args.length === 0
            });
            instant && query1.execute();
            return query1;
        }
    }
    async function listen(name111, fn, onlisten) {
        const listener = {
            fn,
            onlisten
        };
        const sql = listen.sql || (listen.sql = Postgres({
            ...options1,
            max: 1,
            idle_timeout: null,
            max_lifetime: null,
            fetch_types: false,
            onclose () {
                Object.entries(listen.channels).forEach(([name63, { listeners  }])=>{
                    delete listen.channels[name63];
                    Promise.all(listeners.map((l)=>listen(name63, l.fn, l.onlisten).catch(()=>{})));
                });
            },
            onnotify (c, x) {
                c in listen.channels && listen.channels[c].listeners.forEach((l)=>l.fn(x));
            }
        }));
        const channels = listen.channels || (listen.channels = {}), exists1 = name111 in channels, channel = exists1 ? channels[name111] : channels[name111] = {
            listeners: [
                listener
            ]
        };
        if (exists1) {
            channel.listeners.push(listener);
            listener.onlisten && listener.onlisten();
            return Promise.resolve({
                ...channel.result,
                unlisten
            });
        }
        channel.result = await sql`listen ${sql(name111)}`;
        listener.onlisten && listener.onlisten();
        channel.result.unlisten = unlisten;
        return channel.result;
        async function unlisten() {
            if (name111 in channels === false) return;
            channel.listeners = channel.listeners.filter((x)=>x !== listener);
            if (channels[name111].listeners.length) return;
            delete channels[name111];
            return sql`unlisten ${sql(name111)}`;
        }
    }
    async function notify(channel, payload) {
        return await sql1`select pg_notify(${channel}, ${'' + payload})`;
    }
    async function begin(options, fn1) {
        !fn1 && (fn1 = options, options = '');
        const queries = Queue();
        let savepoints = 0, connection3;
        try {
            await sql1.unsafe('begin ' + options.replace(/[^a-z ]/ig, ''), [], {
                onexecute
            }).execute();
            return await scope(connection3, fn1);
        } catch (error28) {
            throw error28;
        }
        async function scope(c, fn2, name2) {
            const sql2 = Sql(handler);
            sql2.savepoint = savepoint;
            let uncaughtError, result;
            name2 && await sql2`savepoint ${sql2(name2)}`;
            try {
                result = await new Promise((resolve22, reject)=>{
                    const x = fn2(sql2);
                    Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve22, reject);
                });
                if (uncaughtError) throw uncaughtError;
            } catch (e1) {
                await (name2 ? sql2`rollback to ${sql2(name2)}` : sql2`rollback`);
                throw e1 instanceof PostgresError && e1.code === '25P02' && uncaughtError || e1;
            }
            !name2 && await sql2`commit`;
            return result;
            function savepoint(name64, fn) {
                if (name64 && Array.isArray(name64.raw)) return savepoint((sql)=>sql.apply(sql, arguments));
                arguments.length === 1 && (fn = name64, name64 = null);
                return scope(c, fn, 's' + savepoints++ + (name64 ? '_' + name64 : ''));
            }
            function handler(q) {
                q.catch((e)=>uncaughtError || (uncaughtError = e));
                c.queue === full ? queries.push(q) : c.execute(q) || move1(c, full);
            }
        }
        function onexecute(c) {
            connection3 = c;
            move1(c, reserved);
            c.reserved = ()=>queries.length ? c.execute(queries.shift()) : move1(c, reserved);
        }
    }
    function move1(c, queue1) {
        c.queue.remove(c);
        queue1.push(c);
        c.queue = queue1;
        queue1 === open3 ? c.idleTimer.start() : c.idleTimer.cancel();
    }
    function json(x) {
        return new Parameter(x, 3802);
    }
    function array(x, type60) {
        if (!Array.isArray(x)) return array(Array.from(arguments));
        return new Parameter(x, type60 || (x.length ? inferType(x) || 25 : 0), options1.shared.typeArrayMap);
    }
    function handler1(query) {
        if (ending) return query.reject(Errors.connection('CONNECTION_ENDED', options1, options1));
        if (open3.length) return go(open3.shift(), query);
        if (closed.length) return connect(closed.shift(), query);
        busy.length ? go(busy.shift(), query) : queries1.push(query);
    }
    function go(c, query) {
        return c.execute(query) ? move1(c, busy) : move1(c, full);
    }
    function cancel(query) {
        return new Promise((resolve23, reject)=>{
            query.state ? query.active ? Connection(options1).cancel(query.state, resolve23, reject) : query.cancelled = {
                resolve: resolve23,
                reject
            } : (queries1.remove(query), query.cancelled = true, query.reject(Errors.generic('57014', 'canceling statement due to user request')), resolve23());
        });
    }
    async function end({ timeout =null  } = {}) {
        if (ending) return ending;
        await 1;
        let timer2;
        return ending = Promise.race([
            new Promise((r)=>timeout !== null && (timer2 = setTimeout(destroy3, timeout * 1000, r))),
            Promise.all(connections.map((c)=>c.end()).concat(listen.sql ? listen.sql.end({
                timeout: 0
            }) : [], subscribe.sql ? subscribe.sql.end({
                timeout: 0
            }) : []))
        ]).then(()=>clearTimeout(timer2));
    }
    async function close6() {
        await Promise.all(connections.map((c)=>c.end()));
    }
    async function destroy3(resolve24) {
        await Promise.all(connections.map((c)=>c.terminate()));
        while(queries1.length)queries1.shift().reject(Errors.connection('CONNECTION_DESTROYED', options1));
        resolve24();
    }
    function connect(c, query) {
        move1(c, connecting);
        c.connect(query);
    }
    function onend(c) {
        move1(c, ended);
    }
    function onopen(c) {
        if (queries1.length === 0) return move1(c, open3);
        let max = Math.ceil(queries1.length / (connecting.length + 1)), ready = true;
        while(ready && queries1.length && max-- > 0)ready = c.execute(queries1.shift());
        ready ? move1(c, busy) : move1(c, full);
    }
    function onclose(c) {
        move1(c, closed);
        c.reserved = null;
        options1.onclose && options1.onclose(c.id);
        queries1.length && connect(c, queries1.shift());
    }
}
function parseOptions(a1, b1) {
    if (a1 && a1.shared) return a1;
    const env1 = process1.env, o = (typeof a1 === 'string' ? b1 : a1) || {}, { url , multihost  } = parseUrl(a1), query = [
        ...url.searchParams
    ].reduce((a, [b65, c])=>(a[b65] = c, a), {}), host = o.hostname || o.host || multihost || url.hostname || env1.PGHOST || 'localhost', port6 = o.port || url.port || env1.PGPORT || 5432, user = o.user || o.username || url.username || env1.PGUSERNAME || env1.PGUSER || osUsername();
    o.no_prepare && (o.prepare = false);
    query.sslmode && (query.ssl = query.sslmode, delete query.sslmode);
    'timeout' in o && (console.log('The timeout option is deprecated, use idle_timeout instead'), o.idle_timeout = o.timeout);
    const defaults = {
        max: 10,
        ssl: false,
        idle_timeout: null,
        connect_timeout: 30,
        max_lifetime: max_lifetime,
        max_pipeline: 100,
        backoff: backoff,
        keep_alive: 60,
        prepare: true,
        debug: false,
        fetch_types: true,
        publications: 'alltables',
        target_session_attrs: null
    };
    return {
        host: Array.isArray(host) ? host : host.split(',').map((x)=>x.split(':')[0]),
        port: Array.isArray(port6) ? port6 : host.split(',').map((x)=>parseInt(x.split(':')[1] || port6)),
        path: o.path || host.indexOf('/') > -1 && host + '/.s.PGSQL.' + port6,
        database: o.database || o.db || (url.pathname || '').slice(1) || env1.PGDATABASE || user,
        user: user,
        pass: o.pass || o.password || url.password || env1.PGPASSWORD || '',
        ...Object.entries(defaults).reduce((acc, [k39, d])=>(acc[k39] = k39 in o ? o[k39] : k39 in query ? query[k39] === 'disable' || query[k39] === 'false' ? false : query[k39] : env1['PG' + k39.toUpperCase()] || d, acc), {}),
        connection: {
            application_name: 'postgres.js',
            ...o.connection,
            ...Object.entries(query).reduce((acc, [k40, v])=>(k40 in defaults || (acc[k40] = v), acc), {})
        },
        types: o.types || {},
        target_session_attrs: tsa(o, url, env1),
        onnotice: o.onnotice,
        onnotify: o.onnotify,
        onclose: o.onclose,
        onparameter: o.onparameter,
        socket: o.socket,
        transform: parseTransform(o.transform || {
            undefined: undefined
        }),
        parameters: {},
        shared: {
            retries: 0,
            typeArrayMap: {}
        },
        ...mergeUserTypes(o.types)
    };
}
function tsa(o, url, env2) {
    const x = o.target_session_attrs || url.searchParams.get('target_session_attrs') || env2.PGTARGETSESSIONATTRS;
    if (!x || [
        'read-write',
        'read-only',
        'primary',
        'standby',
        'prefer-standby'
    ].includes(x)) return x;
    throw new Error('target_session_attrs ' + x + ' is not supported');
}
function backoff(retries) {
    return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
}
function max_lifetime() {
    return 60 * (30 + Math.random() * 30);
}
function parseTransform(x) {
    return {
        undefined: x.undefined,
        column: {
            from: typeof x.column === 'function' ? x.column : x.column && x.column.from,
            to: x.column && x.column.to
        },
        value: {
            from: typeof x.value === 'function' ? x.value : x.value && x.value.from,
            to: x.value && x.value.to
        },
        row: {
            from: typeof x.row === 'function' ? x.row : x.row && x.row.from,
            to: x.row && x.row.to
        }
    };
}
function parseUrl(url) {
    if (typeof url !== 'string') return {
        url: {
            searchParams: new Map()
        }
    };
    let host = url;
    host = host.slice(host.indexOf('://') + 3).split(/[?/]/)[0];
    host = decodeURIComponent(host.slice(host.indexOf('@') + 1));
    return {
        url: new URL(url.replace(host, host.split(',')[0])),
        multihost: host.indexOf(',') > -1 && host
    };
}
function osUsername() {
    try {
        return __default5.userInfo().username;
    } catch (_) {
        return process1.env.USERNAME || process1.env.USER || process1.env.LOGNAME;
    }
}
async function testConnection(uri) {
    const sql = Postgres(uri);
    console.log("Connected to ", await sql`SELECT version()`);
}
export { testConnection as testConnection };
