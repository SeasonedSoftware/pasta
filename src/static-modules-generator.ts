function header() {
  return `// Automatically generated by PASTA`;
}

function generatePgCatalog() {
  return `${header()}
type UUIDFunctionCall = { returnType: "uuid" };
type TimestampFunctionCall = { returnType: "timestamp" };
type JSONValue =
  | string
  | number
  | boolean
  | { [x: string]: JSONValue }
  | Array<JSONValue>;

function uuid() {
  return {
    "type": "call",
    "function": { "name": "gen_random_uuid" },
    "args": [],
    "returnType": "uuid",
  } as UUIDFunctionCall;
}

function now() {
  return (
    {
      "type": "call",
      "function": { "name": "now" },
      "args": [],
      "returnType": "timestamp",
    } as TimestampFunctionCall
  );
}

const functions = {
  now,
  uuid,
};
export type { JSONValue, TimestampFunctionCall };
export { functions, now, uuid };
`;
}

function generateSchema() {
  return `${header()}
import type { TableName, Tables } from "./custom-schema.ts";
import { associations } from "./custom-schema.ts";

type KeysOf<T extends TableName> = Tables[T]["keys"];
type ColumnsOf<T extends TableName> = Tables[T]["columns"];
type ColumnNamesOf<T extends TableName> = (keyof ColumnsOf<T>)[];
type AssociationsOf<T extends TableName> = Tables[T]["associations"];

type MxNAssociation = {
  kind: "MxN";
  table: TableName;
  associativeTable: TableName;
  fks: Record<string, [string, string]>;
};

type NAssociation = {
  kind: "1xN";
  table: TableName;
  fks: Record<string, string>;
};

type Association =
  | NAssociation
  | MxNAssociation;

type Associations = Record<TableName, Record<string, Association>>;

export type {
  Association,
  Associations,
  AssociationsOf,
  ColumnNamesOf,
  ColumnsOf,
  KeysOf,
  MxNAssociation,
  NAssociation,
  TableName,
  Tables,
};
export { associations };

`;
}

function generateTypedStatementBuilder() {
  return `${header()}
import {
  associations,
  AssociationsOf,
  ColumnNamesOf,
  ColumnsOf,
  KeysOf,
  MxNAssociation,
  NAssociation,
  TableName,
} from "./schema.ts";

import * as sql from "./sql-builder.ts";
import type { SqlBuilder } from "./sql-builder.ts";

type ReturningBuilder<T extends TableName> = SqlBuilder & {
  returning: (options: ColumnNamesOf<T>) => ReturningBuilder<T>;
};
type InsertBuilder<T extends TableName> = ReturningBuilder<T> & {
  associate: (associationMap: AssociationsOf<T>) => InsertBuilder<T>;
};
type SelectBuilder<T extends TableName> = ReturningBuilder<T> & {
  where: (whereMap: ColumnsOf<T>) => SelectBuilder<T>;
  unique: (whereMap: KeysOf<T>) => SelectBuilder<T>;
};

function addReturning<T extends TableName>(builder: SqlBuilder): ReturningBuilder<T> {
  return {
    ...builder,
    returning: function (
      options: ColumnNamesOf<T>,
    ): ReturningBuilder<T> {
      return addReturning(sql.returning(builder, options.map(String)));
    },
  };
}

function addSelectReturning<T extends TableName>(builder: SqlBuilder) {
  return {
    ...builder,
    returning: function (options: ColumnNamesOf<T>): ReturningBuilder<T> {
      return addSelectReturning(sql.selection(builder, options.map(String)));
    },
  };
}

function addWhere<T extends TableName>(builder: ReturningBuilder<T>) {
  return {
    ...builder,
    where: function (whereMap: ColumnsOf<T>): ReturningBuilder<T> {
      return addSelectReturning(sql.where(builder, whereMap));
    },
  } as SelectBuilder<T>;
}

function addUnique<T extends TableName>(builder: ReturningBuilder<T>) {
  return {
    ...builder,
    unique: function (whereMap: KeysOf<T>): ReturningBuilder<T> {
      return addSelectReturning(sql.where(builder, whereMap));
    },
  } as SelectBuilder<T>;
}

function addAssociate<T extends TableName>(
  table: T,
  builder: ReturningBuilder<T>,
): InsertBuilder<T> {
  const builderWithMxNAssociation = <T extends TableName>(
    builder: ReturningBuilder<T>,
    association: MxNAssociation,
    associatedValues: Record<string, unknown>,
  ) => {
    const { fks, associativeTable } = association;
    const targetAssociationColumns = Object.keys(fks);
    const sourceColumns = targetAssociationColumns.map((
      c,
    ) => (sql.column(...fks[c])));
    const returningFksAssociation = Object.values(fks).filter((
      [fkTable],
    ) => (fkTable == association.table))
      .map(([_, fkColumn]) => (fkColumn));

    const withStatement = sql.makeInsertWith(
      association.table,
      sql.returning(
        sql.makeInsert(association.table, associatedValues),
        returningFksAssociation,
      ),
      sql.makeInsertWith(
        table,
        builder,
        sql.makeInsertFrom(associativeTable, sourceColumns, targetAssociationColumns),
      ),
    );
    return addReturning<T>(withStatement);
  };

  const builderWith1xNAssociation = (
    builder: ReturningBuilder<T>,
    association: NAssociation,
    associatedValues: Record<string, unknown>,
  ) => {
    const { fks, table: associedTable } = association;

    const returningFksAssociation = Object.values(fks);

    const sourceFkColumns = Object.keys(fks).map((
      k,
    ) => (sql.column(table, fks[k])));

    const sourceValueColumns = Object.keys(associatedValues).map((
      k,
    ) => (sql.column(String(associatedValues[k]))));

    const withStatement = sql.makeInsertWith(
      table,
      sql.returning(builder, returningFksAssociation),
      sql.makeInsertFrom(
        associedTable,
        [...sourceFkColumns, ...sourceValueColumns],
        [...Object.keys(fks), ...Object.keys(associatedValues)],
      ),
    );
    return addReturning<T>(withStatement);
  };

  const associate = (associationMap: AssociationsOf<T>) => {
    const newBuilder = Object.entries(associationMap).reduce(
      (previous, [associated, associatedValues]) => {
        const association = associations[table][associated];
        const pks = association.kind === "1xN"
          ? Object.values(association.fks)
          : Object.values(association.fks).filter((
            [associatedTable, _column],
          ) => associatedTable === table).map(([_table, column]) => column);

        const returningPks = previous.returning(pks as ColumnNamesOf<T>);

        return association.kind === "1xN"
          ? builderWith1xNAssociation(returningPks, association, associatedValues)
          : builderWithMxNAssociation(returningPks, association, associatedValues);
      },
      builder,
    );

    return addAssociate(table, newBuilder);
  };
  return { ...builder, associate };
}

// Public functions

function insert<T extends TableName>(table: T): (valueMap: ColumnsOf<T>) => InsertBuilder<T> {
  return function (valueMap) {
    return addAssociate<T>(
      table,
      addReturning<T>(sql.makeInsert(table, valueMap)),
    );
  };
}

function upsert<T extends TableName>(
  table: T,
): (insertValues: ColumnsOf<T>, updateValues?: ColumnsOf<T>) => ReturningBuilder<T> {
  return (insertValues, updateValues) =>
    addReturning(sql.makeUpsert(table, insertValues, updateValues));
}

function update<T extends TableName>(
  table: T,
): (keyValues: KeysOf<T>, setValues: ColumnsOf<T>) => ReturningBuilder<T> {
  return (keyValues, setValues) =>
    addReturning(sql.makeUpdate(table, keyValues, setValues));
}

function insertWith<T1 extends TableName>(contextTable: T1, context: ReturningBuilder<T1>) {
  return function <T2 extends TableName>(insert: ReturningBuilder<T2>) {
    return addReturning<T2>(
      sql.makeInsertWith(contextTable, context, insert),
    );
  };
}

function select<T extends TableName>(table: T): () => SelectBuilder<T> {
  return () => addUnique<T>(addWhere<T>(addSelectReturning<T>(sql.makeSelect(table))));
}

export { insert, insertWith, select, update, upsert };
export type { InsertBuilder, ReturningBuilder, SelectBuilder, SqlBuilder };
`;
}

function generateTransaction() {
  return `${header()}
import postgres from "https://deno.land/x/postgresjs@v3.2.4/mod.js";
import type { SqlBuilder } from "./typed-statement-builder.ts";

function connection(uri: string) {
  const sql = postgres(uri);
  return sql;
}

async function transaction(statement: SqlBuilder) {
  const uri = Deno.env.get("DATABASE_URL");
  if (!uri) {
    throw new Error("Please set DATABASE_URL to use database access functions");
  }
  const sql = postgres(uri);
  const r = await sql.unsafe(statement.toSql());
  await sql.end({ timeout: 5 });
  return r;
}

async function transactionReturning(statement: SqlBuilder) {
  const r = await transaction(statement);
  if (r.length === 0) {
    throw new Error(
      "Statement" + statement.toSql() + " did not return any rows",
    );
  }
  return r;
}

const db = {
  transaction,
  transactionReturning,
};

export { connection, db, transaction, transactionReturning };
`;
}

function generateIndex() {
  return `${header()}
export { db } from "./transaction.ts";
export { tables } from "./builders.ts";
export { functions } from "./pg-catalog.ts";
`;
}

function generateSqlBuilder() {
  return `${header()}
import {
  astMapper,
  Expr,
  ExprRef,
  ExprString,
  From,
  InsertStatement,
  Name,
  SelectedColumn,
  SelectStatement,
  Statement,
  toSql,
  UpdateStatement,
  WithStatement,
} from "https://deno.land/x/pgsql_ast_parser@11.0.0/mod.ts";

type SqlBuilder = {
  statement:
    | SelectStatement
    | InsertStatement
    | UpdateStatement
    | WithStatement;
  toSql: () => string;
};

function returning(builder: SqlBuilder, columns: string[]): SqlBuilder {
  const returningMapper = (columnNames: string[]) =>
    astMapper((_map) => ({
      with: (t) => {
        if (t.in.type === "insert") {
          return {
            ...t,
            in: {
              ...t.in,
              returning: columnNames.map((c) => ({
                expr: { type: "ref", name: c },
              })),
            },
          };
        }
      },
      insert: (t) => {
        if (t.insert) {
          return {
            ...t,
            returning: columnNames.map((c) => ({
              expr: { type: "ref", name: c },
            })),
          };
        }
      },
    }));
  const statementWithReturning = returningMapper(columns)
    .statement(
      builder.statement,
    ) as InsertStatement;
  return {
    statement: statementWithReturning,
    toSql: () => toSql.statement(statementWithReturning),
  };
}

const binaryOp = (op: string) => (left: Expr, right: Expr) =>
  (
    {
      "type": "binary",
      left,
      right,
      op,
    }
  ) as Expr;

function refExpr(name: string): ExprRef {
  return { "type": "ref", name };
}

function columnRef(table: string, name: string): ExprRef {
  return { table: { name: table }, ...refExpr(name) };
}

function stringExpr(value: string): ExprString {
  return { "type": "string", value };
}

const eqList = (valuesMap: Record<string, unknown>) =>
  binaryOp("=")({
    type: "list",
    expressions: Object.keys(valuesMap).map((k) => refExpr(k)),
  }, {
    type: "list",
    expressions: Object.values(valuesMap).map((v) => stringExpr(String(v))),
  }) as Expr;

function makeUpdate(
  table: string,
  keyValues: Record<string, unknown>,
  setValues: Record<string, unknown>,
): SqlBuilder {
  const statement: Statement = {
    "type": "update",
    "table": { "name": table },
    "sets": Object.keys(setValues).map((k) => ({
      "column": { "name": k },
      "value": {
        "type": "string",
        "value": String(setValues[k]),
      },
    })),
    "where": eqList(keyValues),
  };
  return {
    statement,
    toSql: () => toSql.statement(statement),
  };
}

function where(builder: SqlBuilder, columns: Record<string, unknown>) {
  const whereMapper = (columns: Record<string, unknown>) =>
    astMapper((_map) => ({
      selection: (s) => ({
        ...s,
        where: eqList(columns),
      }),
    }));

  const statementWithWhere = whereMapper(columns)
    .statement(
      builder.statement,
    )! as SelectStatement;
  return {
    statement: statementWithWhere,
    toSql: () => toSql.statement(statementWithWhere),
  };
}

function makeSelect(table: string): SqlBuilder {
  const statement: Statement = {
    "columns": [],
    "from": [{ "type": "table", "name": { "name": table } }],
    "type": "select",
  };

  return {
    statement,
    toSql: () => toSql.statement(statement),
  };
}

function selection(builder: SqlBuilder, columns: string[]): SqlBuilder {
  const returningMapper = (columnNames: string[]) =>
    astMapper((_map) => ({
      selection: (s) => ({
        ...s,
        columns: columnNames.map((c) => ({
          expr: { type: "ref", name: c },
        })),
      }),
    }));

  const statementWithReturning = returningMapper(columns)
    .statement(
      builder.statement,
    )! as SelectStatement;
  return {
    statement: statementWithReturning,
    toSql: () => toSql.statement(statementWithReturning),
  };
}

function makeInsert(
  table: string,
  valueMap: Record<string, unknown>,
): SqlBuilder {
  const columns = Object.keys(valueMap).map((k) => ({ name: k }));
  const values = [
    Object.values(valueMap).map((
      value,
    ) => (typeof value === "string"
      ? { value, type: "string" }
      : (typeof value === "object" && value !== null &&
          ("returnType" in value ||
            ("type" in value &&
              (value as Record<string, unknown>)["type"] == "ref")))
      ? value
      : { value: JSON.stringify(value), type: "string" })
    ),
  ] as Expr[][];
  const statement: InsertStatement = {
    "type": "insert",
    "into": { "name": table },
    "insert": {
      "type": "values",
      values,
    },
    columns,
  };
  return {
    toSql: () => toSql.statement(statement),
    statement,
  };
}

function makeInsertFrom(
  table: string,
  sourceColumns: SelectedColumn[],
  columns: string[],
): SqlBuilder {
  function unique(s: string[]) {
    return Object.keys(Object.fromEntries(s.map((el) => [el, null])));
  }

  const tables = unique(
    sourceColumns.map((
      s,
    ) => ((s.expr as ExprRef)?.table?.name)).filter((t) => (t ?? "").length > 0).map(String),
  );

  const from: From[] = tables.map((t) => ({
    "type": "table",
    "name": {
      "name": t,
    },
  }));

  const targetColumns: Name[] = columns.map((c) => ({ name: c }));

  const statement: InsertStatement = {
    "type": "insert",
    "into": { "name": table },
    "insert": {
      "type": "select",
      columns: Object.values(sourceColumns),
      from,
    },
    columns: targetColumns,
  };
  return {
    toSql: () => toSql.statement(statement),
    statement,
  };
}

function makeInsertWith(
  contextTable: string,
  context: SqlBuilder,
  insert: SqlBuilder,
): SqlBuilder {
  const statement: WithStatement = insert.statement.type === "with"
    ? {
      ...insert.statement,
      "bind": [...insert.statement.bind, {
        "alias": { "name": contextTable },
        "statement": context.statement,
      }],
    }
    : {
      "type": "with",
      "bind": [{
        "alias": { "name": contextTable },
        "statement": context.statement,
      }],
      "in": insert.statement,
    };
  return {
    statement,
    toSql: () => toSql.statement(statement),
  };
}

function makeUpsert(
  table: string,
  insertValues: Record<string, unknown>,
  updateValues?: Record<string, unknown>,
): SqlBuilder {
  const onConflictMapper = (conflictValues: Record<string, unknown>) =>
    astMapper((_map) => ({
      insert: (t) => {
        if (t.insert) {
          return {
            ...t,
            onConflict: {
              "do": {
                "sets": Object.keys(conflictValues).map((k) => ({
                  "column": { "name": k },
                  "value": {
                    "type": "string",
                    "value": String(conflictValues[k]),
                  },
                })),
              },
            },
          };
        }
      },
    }));

  const { statement } = makeInsert(table, insertValues);
  const withOnConflict = onConflictMapper(updateValues || insertValues)
    .statement(statement)! as InsertStatement;
  return {
    toSql: () => toSql.statement(statement),
    statement: withOnConflict,
  };
}

function column(table: string, name: string): SelectedColumn;
function column(literal: string): SelectedColumn;
function column(tableOrValue: string, name?: string): SelectedColumn {
  if (name) {
    return { expr: columnRef(tableOrValue, name) };
  } else {
    return { expr: stringExpr(tableOrValue) };
  }
}

export {
  column,
  makeInsert,
  makeInsertFrom,
  makeInsertWith,
  makeSelect,
  makeUpdate,
  makeUpsert,
  returning,
  selection,
  where,
};
export type { SqlBuilder };
`;
}
export {
  generateIndex,
  generatePgCatalog,
  generateSchema,
  generateSqlBuilder,
  generateTransaction,
  generateTypedStatementBuilder,
};
